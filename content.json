{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"BeautifulSoup解析中国最好大学排行页面","text":"根据如下页面源代码可以看到需要爬取的信息都在tbody标签下的的tr标签中，基本思路如下：首先通过requests库得到页面源码，然后用bs4库在源码中查找到tbody标签，遍历tbody标签中的tr标签，每一个tr标签对应一条数据，前四个td标签要别为所需要的排名，学校名称，省市，总分，最后再对数据进行格式化输出。 示例代码:1234567891011121314151617181920212223242526272829303132333435import requestsfrom bs4 import BeautifulSoupimport bs4 def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot; def fillUnivList(ulist, html): soup = BeautifulSoup(html, &quot;html.parser&quot;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) ulist.append([tds[0].string, tds[1].string, tds[1].string,tds[3].string]) def printUnivList(ulist, num): tplt = &quot;{0:^10}\\t{1:{4}^10}\\t{2:^10}\\t{3:^6}&quot; print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;省市&quot;,&quot;总分&quot;,chr(12288))) for i in range(num): u=ulist[i] print(tplt.format(u[0],u[1],u[2],u[3],chr(12288))) def main(): uinfo = [] url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos; html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 输出结果：","link":"/2017/12/07/BeautifulSoup解析中国最好大学排行页面/"},{"title":"ElasticSearch入门和中文分词插件的基本使用","text":"ElasticSearch是基于lucener的封装，提供一套REST API, 使得用户能够快速的对海量数据进行存储，检索和分析。但是对中文的处理还需要一些额外的插件，本文就以ik为进行基本使用说明 1. 资源准备a. 由于ik插件没有对最新版es进行适配，因此在官网历史发行版本（https://www.elastic.co/downloads/past-releases）中选择6.3.0这个版本进行下载，解压后启动bin目录下的elasticsearch.bat文件即启动了es服务器，默认端口为9200， 因此访问localhost:9200就可以验证是否启动成功，成功返回如下json串1234567891011121314151617{ &quot;name&quot;: &quot;cc5-WZ7&quot;, &quot;cluster_name&quot;: &quot;elasticsearch&quot;, &quot;cluster_uuid&quot;: &quot;_5r724yQTs6Lkdc2rP_ncQ&quot;, &quot;version&quot;: { &quot;number&quot;: &quot;6.3.0&quot;, &quot;build_flavor&quot;: &quot;default&quot;, &quot;build_type&quot;: &quot;zip&quot;, &quot;build_hash&quot;: &quot;424e937&quot;, &quot;build_date&quot;: &quot;2018-06-11T23:38:03.357887Z&quot;, &quot;build_snapshot&quot;: false, &quot;lucene_version&quot;: &quot;7.3.1&quot;, &quot;minimum_wire_compatibility_version&quot;: &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot;: &quot;5.0.0&quot; }, &quot;tagline&quot;: &quot;You Know, for Search&quot;} b. 在ik的github页面即可下载对应版本的插件https://github.com/medcl/elasticsearch-analysis-ik/releases， 下载后在es安装目录中plugin文件夹下新建ik目录，并在此目录解压下载下来的压缩包，重启es即可使用 2. 基本使用在正式使用之前先了解几个es中的基本概念：Cluster: 集群，由多个es服务器组成Node: 节点，表示一个es服务器Index: 索引，也是最重要的概念Type: 类别，一个Index可以对应多个，但是太多会影响性能，最好一个，后面这个概念可能会移除Document: Index中的单条记录即为一个Document， 也是核心数据可以将es理解成一个分布式数据库服务器， 说到数据库最基本的操作当然是增删改查，所以接下来就演示怎么样进行基本的增删改查。 2.1 新建Index新建一个url为’localhost:9200/user_index’PUT请求，body内容如下： 1234567891011121314151617181920212223{ &quot;mappings&quot;: { &quot;person&quot;: { &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;title&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;desc&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; } } } }} 成功后返回:12345{ &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;user_index&quot;} 此处采用的的是postman工具，如下图所示： 该过程表示创建一个名称为 user_index的Index, 里面有一个名称为person的Type, person有user,title,desc三个字段， 并且三个字段类型都是text, 字段文本和搜索词的分词的分析器都是’ik_max_word’, 由ik插件提供。 访问localhost:9200/_cat/indices?v查看所有的Index情况：12health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open user_index djAudaiaT8qdyPrGQMkMTA 5 1 0 0 1.2kb 1.2kb 2.2 新建Document发送一个url为localhost:9200/user_index/person/1的PUT请求，body如下：12345{ &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;} 返回：1234567891011121314{ &quot;_index&quot;: &quot;user_index&quot;, &quot;_type&quot;: &quot;person&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1} 注意url最后面的1可以不要，系统会自动给你生成一个随机字符串作为id, 当需要更新时重新发送一个PUT请求就好，需要删除时将PUT请求改为DELETE， 并且不带body。 2.3 查询查询分为单个查询，即将创建的PUT方法改为GET即可查， 所有查询用localhost:9200/user_index/person/_search, 如下可以看到耗时(单位为毫秒)以及其它的很多信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849{ &quot;took&quot;: 12, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: 3, &quot;max_score&quot;: 1, &quot;hits&quot;: [ { &quot;_index&quot;: &quot;user_index&quot;, &quot;_type&quot;: &quot;person&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: { &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot; } }, { &quot;_index&quot;: &quot;user_index&quot;, &quot;_type&quot;: &quot;person&quot;, &quot;_id&quot;: &quot;Gk3ga2UBjmkW6Yw8zoQ4&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: { &quot;user&quot;: &quot;王五&quot;, &quot;title&quot;: &quot;JAVA&quot;, &quot;desc&quot;: &quot;后端开发工程师&quot; } }, { &quot;_index&quot;: &quot;user_index&quot;, &quot;_type&quot;: &quot;person&quot;, &quot;_id&quot;: &quot;GU3ga2UBjmkW6Yw8P4R6&quot;, &quot;_score&quot;: 1, &quot;_source&quot;: { &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库专家&quot; } } ] }} 接下来看看怎么用全文搜索:在上面的url加上一个body即可：123{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;数据&quot; }}} 如果多个的话用空格隔开表示or，满足一个词就行123{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;数据 后端&quot; }}} 如果需要and则应该如下， 需要同时满足两个词:12345678910{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;desc&quot;: &quot;数据&quot; } }, { &quot;match&quot;: { &quot;desc&quot;: &quot;专家&quot; } } ] } }} 参考文章:http://www.ruanyifeng.com/blog/2017/08/elasticsearch.htmlhttps://blog.csdn.net/yejingtao703/article/details/78392902","link":"/2018/08/24/ElasticSearch入门和中文分词插件的基本使用/"},{"title":"Head First 设计模式学习系列(一)   策略模式","text":"定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 1. 实例描述给客户开发一款模拟鸭子游戏，游戏中会出现各种鸭子，所有的鸭子都会都会游泳，但不同鸭子外观不一样，并且有的鸭子不会叫，有的会叫且叫声不同，有的鸭子不会飞有的会飞且飞的方式不一样。在这个过程中会增加新的鸭子种类，同一种鸭子叫的方式和飞行方式可能发生改变。 ##2. 分析思路首先创建所有的鸭子的基类（Duck)，不同的鸭子(MallarDuck,RedHeadDuck,RubberDuch,DecoyDuck,ModelDuck)都是该基类的实现类。因所有鸭子都会游泳，在基类就定义并实现游泳方法(swin)。每个鸭子都有外观(display)，外观不会改变，所以将外观方法定义为抽象方法，在具体子类里面去实现。不同鸭子的叫声(Quack)和飞行方式(Fly)不一样，而且可能发生改变，所以将这两种行为都抽象为两个接口(QuackBehavior,FlyBehavior)，并且每个接口有不同的实现方法(Quack,Squeak,MuteQuack,FakeQuack;FlyNoWay,FlyWithWings,FlyRocketPowered)。在鸭子基类里面定义有以这两个接口为成员变量的属性(FlyBehavior flyBehavior;QuackBehavior quackBehavior;)且提供更改方式(setFlyBehavior (FlyBehavior fb);setQuackBehavior(QuackBehavior qb))，不同鸭子在创建时(构造方法里）可以定义这两个字段的具体实现类，并且可以改变该属性。 3.类图实现：客户：可以使用下面封装好的算法族 算法族1：封装飞行行为 算法族2：封装呱呱叫行为 4. 代码实现：Duck：所有鸭子的基类12345678910111213141516171819202122232425262728293031package headFirst.designPatterns.day01_strategy;public abstract class Duck { FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck() { } public void setFlyBehavior (FlyBehavior fb) { flyBehavior = fb; } public void setQuackBehavior(QuackBehavior qb) { quackBehavior = qb; } abstract void display(); public void performFly() { flyBehavior.fly(); } public void performQuack() { quackBehavior.quack(); } public void swim() { System.out.println(&quot;All ducks float, even decoys!&quot;); }} MallardDuck：鸭子实现类112345678910111213141516package headFirst.designPatterns.day01_strategy;public class MallardDuck extends Duck { public MallardDuck() { quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); } public void display() { System.out.println(&quot;I&apos;m a real Mallard duck&quot;); }} RedHeadDuck：鸭子实现类212345678910111213package headFirst.designPatterns.day01_strategy;public class RedHeadDuck extends Duck { public RedHeadDuck() { flyBehavior = new FlyWithWings(); quackBehavior = new Quack(); } public void display() { System.out.println(&quot;I&apos;m a real Red Headed duck&quot;); }} RubberDuck：鸭子实现类312345678910111213package headFirst.designPatterns.day01_strategy;public class RubberDuck extends Duck { public RubberDuck() { flyBehavior = new FlyNoWay(); quackBehavior = new Squeak(); } public void display() { System.out.println(&quot;I&apos;m a rubber duckie&quot;); }} DecoyDuck：鸭子实现类41234567891011package headFirst.designPatterns.day01_strategy;public class DecoyDuck extends Duck { public DecoyDuck() { setFlyBehavior(new FlyNoWay()); setQuackBehavior(new MuteQuack()); } public void display() { System.out.println(&quot;I&apos;m a duck Decoy&quot;); }} ModelDuck：鸭子实现类5123456789101112package headFirst.designPatterns.day01_strategy;public class ModelDuck extends Duck { public ModelDuck() { flyBehavior = new FlyNoWay(); quackBehavior = new Quack(); } public void display() { System.out.println(&quot;I&apos;m a model duck&quot;); }} FlyBehavior：封装飞行行为的接口12345package headFirst.designPatterns.day01_strategy;public interface FlyBehavior { public void fly();} FlyNoWay：飞行方式11234567package headFirst.designPatterns.day01_strategy;public class FlyNoWay implements FlyBehavior { public void fly() { System.out.println(&quot;I can&apos;t fly&quot;); }} FlyWithWings：飞行方式21234567package headFirst.designPatterns.day01_strategy;public class FlyWithWings implements FlyBehavior { public void fly() { System.out.println(&quot;I&apos;m flying!!&quot;); }} FlyRocketPowered：飞行方式31234567package headFirst.designPatterns.day01_strategy;public class FlyRocketPowered implements FlyBehavior { public void fly() { System.out.println(&quot;I&apos;m flying with a rocket&quot;); }} QuackBehavior：封装呱呱叫的接口12345package headFirst.designPatterns.day01_strategy;public interface QuackBehavior { public void quack();} Quack：呱呱叫方式11234567package headFirst.designPatterns.day01_strategy;public class Quack implements QuackBehavior { public void quack() { System.out.println(&quot;Quack&quot;); }} Squeak：呱呱叫方式21234567package headFirst.designPatterns.day01_strategy;public class Squeak implements QuackBehavior { public void quack() { System.out.println(&quot;Squeak&quot;); }} MuteQuack：呱呱叫方式312345public class MuteQuack implements QuackBehavior { public void quack() { System.out.println(&quot;&lt;&lt; Silence &gt;&gt;&quot;); }} FakeQuack：呱呱叫方式41234567package headFirst.designPatterns.day01_strategy;public class FakeQuack implements QuackBehavior { public void quack() { System.out.println(&quot;Qwak&quot;); }} 5.模拟运行MiniDuckSimulator：1234567891011121314151617181920package headFirst.designPatterns.day01_strategy;public class MiniDuckSimulator { public static void main(String[] args) { MallardDuck mallard = new MallardDuck(); RubberDuck rubberDuckie = new RubberDuck(); DecoyDuck decoy = new DecoyDuck(); ModelDuck model = new ModelDuck(); mallard.performQuack(); rubberDuckie.performQuack(); decoy.performQuack(); model.performFly(); model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); }} Result: QuackSqueak&lt;&lt; Silence &gt;&gt;I can’t flyI’m flying with a rocket MiniDuckSimulator1：1234567891011121314151617package headFirst.designPatterns.day01_strategy;public class MiniDuckSimulator1 { public static void main(String[] args) { Duck mallard = new MallardDuck(); mallard.performQuack(); mallard.performFly(); Duck model = new ModelDuck(); model.performFly(); model.setFlyBehavior(new FlyRocketPowered()); model.performFly(); }} Result: QuackI’m flying!!I can’t flyI’m flying with a rocket","link":"/2017/06/06/Head First 设计模式学习系列(一)   策略模式/"},{"title":"Head First 设计模式学习系列(二)   观察者模式","text":"观察者模式定义了一系列对象之间的一对多关系，当一个对象(主题，也称被观察者)改变状态，其他依赖者(观察者)都会收到通知. ##1.实例描述现有负责追踪天气状况(温度，湿度，气压)的WeatherData对象，利用该对象建立一个气象观测站应用，有三种布告板，分别显示目前的状况，气象统计及简单的预报，当WeatherData里面有最新的数据测量时，三种布告板必段实时更新。并要求我们能灵活的增加观察者，移除观察者。同时在布告板的块数可能增加，如增加酷热指数布告板。 ##2.分析思路根据定义和描述，我们可以将WeatherDate作为主题，三块布告板作为观察者。首先创建Subjec接口，里面定义添加，移除，通知观察者功能，实现该接口的WeatherData通过ArrayList字段来模拟所有观察者，还有温度，湿度，气压字段，实现接口的方法。然后创建Observer接口，定义更新功能，由于每个布告板还有不同的展示方式，我们还需创建一个DispayElement接口，里面定义展示行为。所有的布告板都实现了Observer和DispayElement接口，并且定义了私有的Subject和相关私有字段。WeatherData里面实现了注册和移除观察者的方法。当要增加一个布告板时，我们只需要实现Observer,DisplayElement两个接口，并且注册。 ##3.类图实现主题： 观察者： ##4.代码实现Subject:主题接口12345public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();} WeatherData：主题的具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.*;public class WeatherData implements Subject { private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList(); } public void registerObserver(Observer o) { observers.add(o); } public void removeObserver(Observer o) { int i = observers.indexOf(o); if (i &gt;= 0) { observers.remove(i); } } public void notifyObservers() { for (int i = 0; i &lt; observers.size(); i++) { Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); } } public void measurementsChanged() { notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); } // other WeatherData methods here public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; }} Observer：观察者核心接口123public interface Observer { public void update(float temp, float humidity, float pressure);} DisplayElement：布告板展示行为的接口123public interface DisplayElement { public void display();} CurrentConditionsDisplay：观察者1，即提供目前状况的布告板123456789101112131415161718192021public class CurrentConditionsDisplay implements Observer, DisplayElement { private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; display(); } public void display() { System.out.println(&quot;Current conditions: &quot; + temperature + &quot;F degrees and &quot; + humidity + &quot;% humidity&quot;); }} StatisticsDisplay：观察者2，即提供气象统计的布告板1234567891011121314151617181920212223242526272829303132public class StatisticsDisplay implements Observer, DisplayElement { private float maxTemp = 0.0f; private float minTemp = 200; private float tempSum = 0.0f; private int numReadings; private Subject weatherData; public StatisticsDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } public void update(float temp, float humidity, float pressure) { tempSum += temp; numReadings++; if (temp &gt; maxTemp) { maxTemp = temp; } if (temp &lt; minTemp) { minTemp = temp; } display(); } public void display() { System.out.println(&quot;Avg/Max/Min temperature = &quot; + (tempSum / numReadings) + &quot;/&quot; + maxTemp + &quot;/&quot; + minTemp); }} ForecastDisplay： 观察者3,即提供简单预报功能的布告板12345678910111213141516171819202122232425262728public class ForecastDisplay implements Observer, DisplayElement { private float currentPressure = 29.92f; private float lastPressure; private Subject weatherData; public ForecastDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } public void update(float temp, float humidity, float pressure) { lastPressure = currentPressure; currentPressure = pressure; display(); } public void display() { System.out.print(&quot;Forecast: &quot;); if (currentPressure &gt; lastPressure) { System.out.println(&quot;Improving weather on the way!&quot;); } else if (currentPressure == lastPressure) { System.out.println(&quot;More of the same&quot;); } else if (currentPressure &lt; lastPressure) { System.out.println(&quot;Watch out for cooler, rainy weather&quot;); } }} HeatIndexDisplay：观察者4，即新增加的提供酷热指数的布告板123456789101112131415161718192021222324252627282930313233public class HeatIndexDisplay implements Observer, DisplayElement { float heatIndex = 0.0f; private Subject weatherData; public HeatIndexDisplay(WeatherData weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } public void update(float t, float rh, float pressure) { heatIndex = computeHeatIndex(t, rh); display(); } private float computeHeatIndex(float t, float rh) { float index = (float) ((16.923 + (0.185212 * t) + (5.37941 * rh) - (0.100254 * t * rh) + (0.00941695 * (t * t)) + (0.00728898 * (rh * rh)) + (0.000345372 * (t * t * rh)) - (0.000814971 * (t * rh * rh)) + (0.0000102102 * (t * t * rh * rh)) - (0.000038646 * (t * t * t)) + (0.0000291583 * (rh * rh * rh)) + (0.00000142721 * (t * t * t * rh)) + (0.000000197483 * (t * rh * rh * rh)) - (0.0000000218429 * (t * t * t * rh * rh)) + 0.000000000843296 * (t * t * rh * rh * rh)) - (0.0000000000481975 * (t * t * t * rh * rh * rh))); return index; } public void display() { System.out.println(&quot;Heat index is &quot; + heatIndex); }}","link":"/2017/06/06/Head First 设计模式学习系列(二)   观察者模式/"},{"title":"JAVA基础系列（一） 概述与相关概念","text":"万事开头难，来这个平台上已经有一段时间了，看到了很多高质量的文章，也很喜欢这种简约的风格。一直也想把自己的零散的知识体系组织起来，但苦于自己拙劣的文笔和不成流派的风格让大家笑话，直到现在才开始。可是从哪方面开始，JavaWeb?JVM？Oracle?.Net?数据结构？算法？组成原理？操作系统？...细想这些东西在自己脑海中都是半调子水平。万丈高楼平地起，还是从基础的开始，在这里和大家一起学习成长，培养写作总结的习惯。在系列文章中要尽量用多点思维导图，流程图，Demo代码来取代一些臃肿的文字. #####JAVA学习系列之知识体系将分以下几个部分进行归纳总结 ###概述内容 ####1.概念 Java 是一门面向对象编程语言,是一项用于开发应用程序的技术.特性：简单性，解释性，面向对象，高性能，分布式处理，多线程，健壮性，动态，结构中立，安全性，开源，跨平台。 ####2.平台版本 #####J2SE(Java 2 Platform Standard Edition)标准版是为开发普通桌面和商务应用程序提供的解决方案;该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 #####J2ME(Java 2 Platform Micro Edition)小型版是为开发电子消费产品和嵌入式设备提供的解决方案 #####J2EE(Java 2 Platform Enterprise Edition)企业版是为开发企业环境下的应用程序提供的一套解决方案该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发####3.跨平台性 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。实现通过Java语言编写的应用程序在不同的系统平台上都可以运行。 #####图解 ####4.工作原理 ####5.JRE与JDK #####JRE(Java Runtime Environment Java运行环境)包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 #####JDK(Java Development Kit Java开发工具包)JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等简单而言：使用JDK开发完成的java程序，交给JRE去运行。 ####6.环境变量","link":"/2017/06/04/JAVA基础系列（一） 概述与相关概念/"},{"title":"JAVA基础系列（六） 异常","text":"1. Throwable&gt; 程序出现了不正常的情况,JAVA对不正常情况进行描述后的对象体现。### 1.1 分类图解### 1.2 JVM的默认处理方案- 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台- 程序停止执行### 1.3 异常处理方案- try…catch…finally12345678910111213141516171819try { 可能出现问题的代码; }catch(异常名 变量) { 针对问题的处理; }finally { 释放资源; } // 变形 1. try...catch 2. try...finally 3. try...catch...catch... 4. try...catch...catch...finally//JDK7出现了一个新的异常处理方案：try{ 可能出现问题的代码; }catch(异常名1 | 异常名2 | ... 变量 ) { 针对问题的处理;} throws 1.4 编译时异常和运行时异常的区别 编译期异常：Java程序必须显示处理，否则程序就会发生错误，无法通过编译 运行期异常：无需显示处理，也可以和编译时异常一样处理 1.5 Throwable 在try里面发现问题后，jvm会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配。如果该对象是某个类型的，就会执行该catch里面的处理信息。 成员方法12345678getMessage()//获取异常信息，返回字符串。toString()//获取异常类名和异常信息，返回字符串。printStackTrace()//获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。printStackTrace(PrintStream s)//通常用该方法将异常内容保存在日志文件中，以便查阅。 2. throws,throw,finally关键字2.1 throws 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识。 Demo:123456789101112131415161718192021222324252627282930313233import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class ExceptionDemo { public static void main(String[] args) { System.out.println(&quot;今天天气很好&quot;); try { method(); } catch (ParseException e) { e.printStackTrace(); } System.out.println(&quot;但是就是不该有雾霾&quot;); method2(); } // 运行期异常的抛出 public static void method2() throws ArithmeticException { int a = 10; int b = 0; System.out.println(a / b); } // 编译期异常的抛出 // 在方法声明上抛出，是为了告诉调用者，你注意了，我有问题。 public static void method() throws ParseException { String s = &quot;2014-11-20&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = sdf.parse(s); System.out.println(d); }} 2. 2 throw 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。 Demo:123456789101112131415161718192021222324252627282930 public class ExceptionDemo { public static void main(String[] args) { try { method2(); } catch (Exception e) { e.printStackTrace(); } method(); } public static void method() { int a = 10; int b = 0; if (b == 0) { throw new ArithmeticException(); } else { System.out.println(a / b); } } public static void method2() throws Exception { int a = 10; int b = 0; if (b == 0) { throw new Exception(); } else { System.out.println(a / b); } }} throws和throw的区别 2.3 finally2.3.1 特点被finally控制的语句体一定会执行特殊情况：在执行到finally之前jvm退出了(比如System.exit(0)) 2.3.2 作用用于释放资源，在IO流操作和数据库操作中会见到 2.3.3 相关面试题A. final,finally和finalize的区别 final：最终的意思，可以修饰类，成员变量，成员方法修饰类，类不能被继承修饰变量，变量是常量修饰方法，方法不能被重写finally：是异常处理的一部分，用于释放资源。一般来说，代码肯定会执行，特殊情况：在执行到finally之前jvm退出了 finalize：是Object类的一个方法，用于垃圾回收 Demo: 12345678910111213141516171819public class FinallyDemo { public static void main(String[] args) { String s = &quot;2014-11-20&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = null; try { // System.out.println(10 / 0); d = sdf.parse(s); } catch (ParseException e) { e.printStackTrace(); //System.exit(0); } finally { System.out.println(&quot;这里的代码是可以执行的&quot;); } System.out.println(d); }} B. 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。 会，前。 Demo: 12345678910111213141516171819202122232425public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a在程序执行到这一步的时候，这里不是return a而是return 30;这个返回路径就形成了。 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 再次回到以前的返回路径，继续走return * 30; */ } finally { a = 40; return a * 10;// 如果这样结果就是40了。 } // return a; }} 3. 自定义异常 java不可能对所有的情况都考虑到，所以，在实际的开发中，我们可能需要自己定义异常。 而我们自己随意的写一个类，是不能作为异常类来看的，要想你的类是一个异常类，就必须继承自Exception或者RuntimeException Demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 两种方式：import java.util.Scanner;/* * 自定义异常测试类 */public class MyExceptionDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入学生成绩：&quot;); int score = sc.nextInt(); Teacher t = new Teacher(); try { t.check(score); } catch (MyException e) { e.printStackTrace(); } }}class MyException extends Exception { public MyException() { } public MyException(String message) { super(message); }}class Teacher { public void check(int score) throws MyException { if (score &gt; 100 || score &lt; 0) { throw new MyException(&quot;分数必须在0-100之间&quot;); } else { System.out.println(&quot;分数没有问题&quot;); } } // 针对MyException继承自RuntimeException // public void check(int score) { // if (score &gt; 100 || score &lt; 0) { // throw new MyException(); // } else { // System.out.println(&quot;分数没有问题&quot;); // } // }} 4.异常注意事项A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)B:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常C:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws Demo:1234567891011121314151617181920212223242526public class ExceptionDemo {}class Fu { public void show() throws Exception { } public void method() { }}class Zi extends Fu { @Override public void show() throws ArithmeticException { } @Override public void method() { // String s = &quot;2014-11-20&quot;; // SimpleDateFormat sdf = new SimpleDateFormat(); // Date d = sdf.parse(s); // System.out.println(d); }}","link":"/2017/06/02/JAVA基础系列（六） 异常/"},{"title":"JavaWeb基础之Filter详解","text":"Filter也称之为过滤器，如下图所示，浏览器在访问web资源时，如果服务器配置了过滤器，则该访问在获取到web资源之间会经过过滤器，在访问完后又会回到过滤器，最后经过服务器才返回浏览器。通过这种方法，我们可以实现权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 1.Filter开发步骤开发过滤器很简单，只需要经过编写java类，进行相关配置，就可以使用了。 1.1 编写java类 Servlet API中提供了一个Filter接口,我们通过实现该接口重写里面的方法就可以实现过滤器的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.IOException;import java.util.Enumeration;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class HelloFilter implements Filter{ // 创建实例 public HelloFilter(){ System.out.println(&quot;1. 创建过滤器实例&quot;); } @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(&quot;2. 执行过滤器初始化方法&quot;); // 获取过滤器在web.xml中配置的初始化参数 String encoding = filterConfig.getInitParameter(&quot;encoding&quot;); System.out.println(encoding); // 获取过滤器在web.xml中配置的初始化参数 的名称 Enumeration&lt;String&gt; enums = filterConfig.getInitParameterNames(); while (enums.hasMoreElements()){ // 获取所有参数名称：encoding、path String name = enums.nextElement(); // 获取名称对应的值 String value = filterConfig.getInitParameter(name); System.out.println(name + &quot;\\t&quot; + value); } } // 过滤器业务处理方法： 在请求到达servlet之前先进入此方法处理公用的业务逻辑操作 @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;3. 执行过滤器业务处理方法&quot;); // 放行 (去到Servlet) // 如果有下一个过滤器，进入下一个过滤器，否则就执行访问servlet chain.doFilter(request, response); System.out.println(&quot;5. Servlet处理完成，又回到过滤器&quot;); } @Override public void destroy() { System.out.println(&quot;6. 销毁过滤器实例&quot;); }} 1.2 进行相关配置 在web.xml中添加如下内容： 1234567891011121314151617181920212223 &lt;filter&gt; &lt;!-- 过滤器名称 --&gt; &lt;filter-name&gt;hello_filter&lt;/filter-name&gt; &lt;!-- 过滤器对应的实现类 --&gt; &lt;filter-class&gt;cn.itcast.a_filter_hello.HelloFilter&lt;/filter-class&gt; &lt;!-- 过滤器初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;path&lt;/param-name&gt; &lt;param-value&gt;c:/...&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hello_filter&lt;/filter-name&gt; &lt;!-- 过滤器过滤模式，/* 表示过滤所有资源 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 辅助servlet:123456public class ServletTest extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(&quot;I&apos;m a test servlet!&quot;); }} 当我们两次访问辅助测试servlet时效果如下： 2.FilterChain 即Filter链，在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 3.Filter生命周期 通过上面实例， 可以看到在启动tomcat服务器时就执行了过滤器的构造方法和初始化方法，在每次访问servlet时都会进入doFilter()方法，访问完servlet方法后又会返回到doFilter()方法，而destroy()方法只在停止服务器时才会执行一次。 下图通过时序图展示了有两个过滤器的Filter执行流程： 4.Filter映射 元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径 子元素用于设置filter的注册名称。该值必须是在元素中声明过的过滤器的名字&lt;filter-name&gt;hello_filter&lt;/filter-name&gt; 设置 filter 所拦截的请求路径(过滤器关联的URL样式)123456&lt;!-- 拦截指定的jsp --&gt; &lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;/list.jsp&lt;/url-pattern&gt; &lt;!-- 拦截所有的jsp --&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; 指定过滤器所拦截的Servlet名称。1234567&lt;!-- 3. 根据servlet的内部名称拦截 --&gt; &lt;servlet-name&gt;IndexServlet&lt;/servlet-name&gt; &lt;!-- 拦截指定的servlet --&gt; &lt;url-pattern&gt;/index&lt;/url-pattern&gt;``` **&lt;dispatcher&gt;**指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; ` 子元素可以设置的值及其意义：REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。","link":"/2017/06/09/JavaWeb基础之Filter详解/"},{"title":"JavaWeb基础之Internationalization","text":"即国际化，又简称为 i18n。国际化的目的是让程序能灵活应对世界不同地区和国家的访问。 1.Locale 本地化对象,封装语言、国家信息的对象，由java.util提供 123456789101112 // 模拟中国语言等环境// Locale locale = Locale.CHI&lt;!-- more --&gt;NA;Locale locale = Locale.getDefault(); // 当前系统默认的语言环境System.out.println(locale.getCountry()); // CN 国家的简称System.out.println(locale.getDisplayCountry()); //中国 国家名称System.out.println(locale.getLanguage()); // zh 语言简称// 模拟美国国家Locale l_us = Locale.US;System.out.println(l_us.getCountry()); //USSystem.out.println(l_us.getDisplayCountry());//美国System.out.println(l_us.getLanguage());//en 2.ResourceBundle 用于描述一个资源包，并且 ResourceBundle类提供了相应的方法getBundle，这个方法可以根据来访者的国家地区自动获取与之对应的资源文件予以显示 一个资源包中的每个资源文件都必须拥有共同的基名。除了基名，每个资源文件的名称中还必须有标识其本地信息的附加部分。例如：一个资源包的基名是“myproperties”，则与中文、英文环境相对应的资源文件名则为: “myproperites_zh.properties” “myproperites_en.properties” 每个资源包都应有一个默认资源文件，这个文件不带有标识本地信息的附加部分。若ResourceBundle对象在资源包中找不到与用户匹配的资源文件，它将选择该资源包中与用户最相近的资源文件，如果再找不到，则使用默认资源文件。例如：myproperites.properties 资源文件的内容通常采用“关键字＝值”的形式，软件根据关键字检索值显示在页面上。一个资源包中的所有资源文件的关键字必须相同，值则为相应国家的文字。并且资源文件中采用的是properties格式文件，所以文件中的所有字符都必须是ASCII字码，对于像中文这样的非ACSII字符，须先进行编码。(java提供了一个native2ascII命令用于编码)。例：属性文件是不能保存中文的 实例：1234567891011 // 设置语言环境Locale locale = Locale.US;// Locale locale = Locale.getDefault();// 创建工具类对象ResourceBundleResourceBundle bundle = ResourceBundle.getBundle( &quot;cn.itcast.f_i18n.msg&quot;, locale);// 根据key获取配置文件中的值System.out.println(bundle.getString(&quot;hello&quot;));System.out.println(bundle.getString(&quot;username&quot;));System.out.println(bundle.getString(&quot;pwd&quot;)); msg.properties12345hello=\\u4F60\\u597Dusername=\\u7528\\u6237\\u540Dpwd=\\u5BC6\\u7801title=\\u767B\\u9646\\u9875\\u9762submit=\\ \\u767B\\u9646 msg_en_US.properties12345hello=Hellousername=User Namepwd=Passwordtitle=Login Pagesubmit=Submit \\! 3.国际化动态文本3.1 国际化货币12345678910111213141516171819202122232425262728 public void testI18N3() throws Exception { // 模拟语言环境 Locale locale = Locale.CHINA; // 数据准备 double number = 100; // 工具类 NumberFormat nf = NumberFormat.getCurrencyInstance(locale); // 国际化货币 String m = nf.format(number); // 测试 System.out.println(m);// ￥100.00}// 面试题： 代码计算： $100 * 10@Testpublic void eg() throws Exception { String str = &quot;$100&quot;; int num = 10; // 1. 分析str值是哪一国家的货币 Locale us = Locale.US; // 2. 国际化工具类 NumberFormat nf = NumberFormat.getCurrencyInstance(us); // 3. 解析str国币 Number n = nf.parse(str); System.out.println(n.intValue() * num);//1000} 3.2.国际化数值1234567public void testI18N4() throws Exception { // 模拟语言环境 Locale locale = Locale.CHINA; NumberFormat nf = NumberFormat.getNumberInstance(Locale.US); String str = nf.format(1000000000); System.out.println(str);//1,000,000,000} 3.3.国际化日期123456789101112131415161718192021222324252627282930313233/* * 日期 FULL 2015年3月4日 星期三 LONG 2015年3月4日 FULL 2015年3月4日 星期三 MEDIUM 2015-3-4 * SHORT 15-3-4 * * 时间 FULL 下午04时31分59秒 CST LONG 下午04时32分37秒 MEDIUM 16:33:00 SHORT 下午4:33 */@Testpublic void testI18N5() throws Exception { // 日期格式 int dateStyle = DateFormat.SHORT; // 时间格式 int timeStyle = DateFormat.SHORT; // 工具类 DateFormat df = DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.CHINA); String date = df.format(new Date()); System.out.println(date);// 17-6-9 上午11:29}// 面试2： 请将时间值：09-11-28 上午10时25分39秒 CST，反向解析成一个date对象。@Testpublic void eg2() throws Exception { String str = &quot;09-11-28 上午10时25分39秒 CST&quot;; // 创建DateFormat工具类，国际化日期 DateFormat df = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, Locale.getDefault()); Date d = df.parse(str); System.out.println(d);//Sat Nov 28 10:25:39 CST 2009}","link":"/2017/06/09/JavaWeb基础之Internationalization/"},{"title":"JavaWeb基础之JSP进阶","text":"1.九大内置对象 在一篇中我们知道tomcat服务器翻译成了java源文件，每次说jsp文件时都会调用_jspService方法，当该方法中我们可以看到： 12345678final javax.servlet.jsp.PageContext pageContext;javax&lt;!-- more --&gt;.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application;final javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this;javax.servlet.jsp.JspWriter _jspx_out = null;javax.servlet.jsp.PageContext _jspx_page_context = null; 当用page指定指定当前页面是否为错误处理页面时还会多几行： 1234java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);if (exception != null) { response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR); } 以上即为我们所说的JSP九大内置对象，JSP技术的设计者为便于开发人员在编写JSP页面时获得这些web对象的引用，特意定义了9个相应的变量，开发人员在JSP页面中通过这些变量就可以快速获得这9大对象的引用。概括如下： 注意：out隐式对象： out隐式对象用于向客户端发送文本数据。out对象是通过调用pageContext对象的getOut方法返回的，其作用和用法ServletResponse.getWriter方法返回的PrintWriter对象非常相似。JSP页面中的out隐式对象的类型为JspWriter，JspWriter相当于一种带缓存功能的PrintWriter，设置JSP页面的page指令的buffer属性可以调整它的缓存大小，甚至关闭它的缓存。只有向out对象中写入了内容，且满足如下任何一个条件时，out对象才去调用ServletResponse.getWriter方法，并通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎提供的缓冲区中： 1.设置page指令的buffer属性关闭了out对象的缓存功能 2.out对象的缓冲区已满 3.刷新缓存区 4.整个JSP页面结束 pageContext对象: pageContext对象的类型是PageContext，叫jsp的上下文对象封装了其它8大隐式对象的引用,代表当前JSP页面的运行环境,可以通过pageContext获取其他八个内置对象 1.getException方法返回exception隐式对象 2.getPage方法返回page隐式对象 3.getRequest方法返回request隐式对象 4.getResponse方法返回response隐式对象 5.getServletConfig方法返回config隐式对象 6.getServletContext方法返回application隐式对象 7.getSession方法返回session隐式对象 8.getOut方法返回out隐式对象 2. 四大域对象 用于保存数据、获取数据和共享数据 2.1 域对象方法：2.1.1 保存数据setAttribute(“name”,Object); //pageContext对象还可以保存数据到指定域，默认为page域 2.1.1 获取数据getAttribute(“name”) ; //pageContext对象还可以获取指定域的数据，默认为page域 2.1.1 清除数据removeAttribute(“name”) 2.1.1 搜索数据pageContext.findAttribute(“name”); //pageContext特有,自动在四个域中搜索数据顺序： page域 -&gt; request域 -&gt; session域- &gt; context域（application域） ##3.EL表达式 全名为Expression Language，用于向浏览器输出域对象中的变量值或表达式计算的结果 语法： ${变量或表达式}1）输出基本数据类型变量 1.1 从四个域获取 ${name} 1.2 指定域获取 ${pageScope.name} 域范围： pageScope/ requestScope / sessionScope / applicationScope2）输出对象的属性值 Student 3）输出集合对象 List 和 Map 4）EL表达式计算 举例1：获取域中的变量1234567891011121314151617181920&lt;%--1)从四个域自动搜索 --%&gt; ${name }&lt;%--${name } 等价于 &lt;%=pageContext.findAttribute(&quot;name&quot;)%&gt;--%&gt;&lt;%-- 2） 从指定的域中获取数据 --%&gt; ${pageScope.name }&lt;%--pageScope为EL中的隐含对象，像这样的还有requestScope，sessionScope，applicationScope，pageContext等十一个${pageScope.name } 等价于&lt;%= pageContext.getAttribute(&quot;name&quot;,PageContext.PAGE_SCOPE)%&gt; --%&gt; 举例2：获取域中的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;% //保存数据 Student student = new Student(&quot;eric&quot;,20); //放入域中 pageContext.setAttribute(&quot;student&quot;,student); //List List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,28)); list.add(new Student(&quot;lucy&quot;,38)); //放入域中 pageContext.setAttribute(&quot;list&quot;,list); //Map Map&lt;String,Student&gt; map = new HashMap&lt;String,Student&gt;(); map.put(&quot;100&quot;,new Student(&quot;mark&quot;,20)); map.put(&quot;101&quot;,new Student(&quot;maxwell&quot;,30)); map.put(&quot;102&quot;,new Student(&quot;narci&quot;,40)); //放入域中 pageContext.setAttribute(&quot;map&quot;,map); %&gt; &lt;%--使用EL获取对象 --%&gt; ${student.name} - ${student.age } &lt;%-- ${student.name} 等价于 （点相对于调用getXX（）方法） &lt;%=((Student)pageContext.findAttribute(&quot;student&quot;)).getName()%&gt; --%&gt; &lt;hr/&gt; &lt;%--使用EL获取List对象 --%&gt; ${list[0].name } - ${list[0].age }&lt;br/&gt; ${list[1].name } - ${list[1].age }&lt;br/&gt; ${list[2].name } - ${list[2].age } &lt;%-- list[0]等价于 (中括号相对于调用get(参数)方法) ((List)pageContext.findAttribute(&quot;list&quot;)).get(0) --%&gt; &lt;hr/&gt; &lt;%--使用EL获取Map对象 --%&gt; ${map[&apos;100&apos;].name } - ${map[&apos;100&apos;].age }&lt;br/&gt; ${map[&apos;101&apos;].name } - ${map[&apos;101&apos;].age }&lt;br/&gt; ${map[&apos;102&apos;].name } - ${map[&apos;102&apos;].age }&lt;br/&gt; 举例3：表达式计算12345678910111213141516171819202122232425262728293031323334353637&lt;%-- 1)算术表达式 + - * / --%&gt; ${10+5 }&lt;br/&gt; ${10*5 } &lt;hr/&gt; &lt;%-- 2)比较运算 &gt; &lt; &gt;= &lt;= == != --%&gt; ${10&gt;5 }&lt;br/&gt; ${10&lt;5 }&lt;br/&gt; ${10!=10 } &lt;hr/&gt; &lt;%-- 3)逻辑运算 &amp;&amp; || ! --%&gt; ${true &amp;&amp; false }&lt;br/&gt; ${true || false }&lt;br/&gt; ${!false }&lt;br/&gt; &lt;hr/&gt; &lt;%-- 4)判空 null 或 空字符串: empty --%&gt; &lt;% //String name = &quot;eric&quot;; //String name = null; String name = &quot;&quot;; pageContext.setAttribute(&quot;name&quot;,name); %&gt; 判断null： ${name==null }&lt;br/&gt; 判断空字符： ${name==&quot;&quot; }&lt;br/&gt; 判空： ${name==null || name==&quot;&quot; } 另一种判空写法： ${empty name }","link":"/2017/06/07/JavaWeb基础之JSP进阶/"},{"title":"JavaWeb基础之Listener基本用法","text":"用来监听特定对象的创建或销毁、属性的变化 1.监听器接口的分类1.1、监听对象创建/销毁的监听器接口Interface ServletRequestListener 监听request对象的创建或销毁 Interface HttpSessionListener &lt;!-- more --&gt; 监听session对象的创建或销毁 Interface ServletContextListener 监听servletContext对象的创建或销毁 ###1.2、监听对象属性的变化 Interface ServletRequestAttributeListener 监听request对象属性变化: 添加、移除、修改 Interface HttpSessionAttributeListener 监听session对象属性变化: 添加、移除、修改Interface ServletContextAttributeListener 监听servletContext对象属性变化 ###1.3、session相关监听器 Interface HttpSessionBindingListener 监听对象绑定到session上的事件 Interface HttpSessionActivationListener(了解) 监听session序列化及反序列化的事件 2.监听器的开发2.1 步骤：2.1.1.写一个普通java类，实现相关接口；2.1.2.配置(web.xml) 2.2 实例A.监听request对象的创建或销毁12345678910111213141516171819import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;public class MyRequestListener implements ServletRequestListener{ // 对象销毁 @Override public void requestDestroyed(ServletRequestEvent sre) { // 获取request中存放的数据 Object obj = sre.getServletRequest().getAttribute(&quot;cn&quot;); System.out.println(obj); System.out.println(&quot;MyRequestListener.requestDestroyed()&quot;); } // 对象创建 @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;MyRequestListener.requestInitialized()&quot;); }} +1234&lt;!-- 监听request对象创建、销毁 --&gt; &lt;listener&gt; &lt;listener-class&gt;cn.acamy.a_life.MyRequestListener&lt;/listener-class&gt; &lt;/listener&gt; B. 监听ServletContext对象创建或销毁12345678910111213141516import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class MyServletContextListener implements ServletContextListener{ @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(&quot;MyServletContextListener.contextDestroyed()&quot;); } @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(&quot;1..........MyServletContextListener.contextInitialized()&quot;); }} +1234&lt;!-- 监听servletContext对象创建、销毁 --&gt; &lt;listener&gt; &lt;listener-class&gt;cn.acamy.a_life.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; C.监听Session对象创建、销毁123456789101112131415161718import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class MySessionListener implements HttpSessionListener{ // 创建 @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;MySessionListener.sessionCreated()&quot;); } // 销毁 @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;MySessionListener.sessionDestroyed()&quot;); }} +1234&lt;!-- 监听session对象创建、销毁 --&gt; &lt;listener&gt; &lt;listener-class&gt;cn.itcast.a_life.MySessionListener&lt;/listener-class&gt; &lt;/listener&gt; D.监听session对象属性的变化12345678910111213141516171819202122232425262728293031323334353637383940import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent;public class MySessionAttrListener implements HttpSessionAttributeListener { // 属性添加 @Override public void attributeAdded(HttpSessionBindingEvent se) { // 先获取session对象 HttpSession session = se.getSession(); // 获取添加的属性 Object obj = session.getAttribute(&quot;userName&quot;); // 测试 System.out.println(&quot;添加的属性：&quot; + obj); } // 属性移除 @Override public void attributeRemoved(HttpSessionBindingEvent se) { System.out.println(&quot;属性移除&quot;); } // 属性被替换 @Override public void attributeReplaced(HttpSessionBindingEvent se) { // 获取sesison对象 HttpSession session = se.getSession(); // 获取替换前的值 Object old = se.getValue(); System.out.println(&quot;原来的值：&quot; + old); // 获取新值 Object obj_new = session.getAttribute(&quot;userName&quot;); System.out.println(&quot;新值：&quot; + obj_new); }} E.监听此对象绑定到session上的过程1234567891011121314151617181920212223242526272829303132333435363738394041424344import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;public class Admin implements HttpSessionBindingListener { private int id; private String name; public Admin() { super(); } public Admin(int id, String name) { super(); this.id = id; this.name = name; } // 构造函数 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } // 对象放入session @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(&quot;Admin对象已经放入session&quot;); } // 对象从session中移除 @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(&quot;Admin对象从session中移除！&quot;); } } 注意：因为监听的对象是自己创建的对象，不是服务器对象,所以不用再进行web.xml配置","link":"/2017/06/09/JavaWeb基础之Listener基本用法/"},{"title":"Java之回调函数的简单实现","text":"在Windows中，程序员想让系统DLL调用自己编写的一个方法，于是利用DLL当中回调函数（CALLBACK）的接口来编写程序，使它调用，这个就称为回调。在调用接口时，需要严格的按照定义的参数和方法调用，并且需要处理函数的异步，否则会导致程序的崩溃。 举例：程序员A写了一段程序（类Caller），其中预留有回调函数接口(MyInterface)，并封装好了该程序。程序员B要让Caller调用自己的Client类中的一个方法，于是，他通过Caller中的接口回调自己Client中的方法。 类图： 代码如下：1234567891011121314public class Caller { private MyCallInterface callInterface; public Caller() { } public void setCallFunc(MyCallInterface callInterface) { this.callInterface = callInterface; } public void call() { callInterface.printName(); } } 123public interface MyCallInterface { public void printName(); } 1234567public class Client implements MyCallInterface { @Override public void printName() { System.out.println(&quot;This is the client printName method&quot;); } } 测试代码：1234567public class Test { public static void main(String[] args) { Caller caller = new Caller(); caller.setCallFunc(new Client()); caller.call(); } } 其中Client也可以通过匿名内部类来实现，如下：123456789101112public class Test { public static void main(String[] args) { Caller caller = new Caller(); // caller.setCallFunc(new Client()); caller.setCallFunc(new MyCallInterface() { public void printName() { System.out.println(&quot;This is the client printName method&quot;); } }); caller.call(); } }","link":"/2017/06/29/Java之回调函数的简单实现/"},{"title":"Juel基本使用","text":"Juel是Java Unified Expression Language的简称，即Java统一表达语言，在JSP2.1标准(JSR-245)中定义的一部分。尽管EL表达式是伴随着JSP而生，但现在已经可以在非JSP应用中使用，相关的API放在javax.el包里面。 Juel是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。具体可以去Juel官方网站进行详细阅读，本文基于官方文档写一下简单的使用说明。 1. 引入依赖使用Juel首先需要引入以下的三个依赖，版本可以自己选择 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt; &lt;artifactId&gt;juel-api&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt; &lt;artifactId&gt;juel-impl&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.odysseus.juel&lt;/groupId&gt; &lt;artifactId&gt;juel-spi&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt;&lt;/dependency&gt; 2. 最简单的例子在看官方给出的quick start中的例子之前，先看看一个更简单的，实际上在项目中大多也是这种模式的应用。如下代码所示，需要做的事情很简单，即将字符串{\\”argIn1\\”:\\”${var1}\\”,\\”argIn2\\”:\\”${var2}\\”}解析为{“argIn1”:”Hello”,”argIn2”:”World”}, 要实现该目的基本上分为三步走 step1. 创建基本的工厂类和上下方以供下面使用 step2. 设置变量值 step3. 解析字符串 123456789101112//step1ExpressionFactory factory = new ExpressionFactoryImpl();SimpleContext context = new SimpleContext();//step2context.setVariable(&quot;var1&quot;, factory.createValueExpression(&quot;Hello&quot;, String.class));context.setVariable(&quot;var2&quot;, factory.createValueExpression(&quot;World&quot;, String.class));//step3String s = &quot;{\\&quot;argIn1\\&quot;:\\&quot;${var1}\\&quot;,\\&quot;argIn2\\&quot;:\\&quot;${var2}\\&quot;}&quot;;ValueExpression e = factory.createValueExpression(context, s, String.class);System.out.println(e.getValue(context));// --&gt; {&quot;argIn1&quot;:&quot;Hello&quot;,&quot;argIn2&quot;:&quot;World&quot;} 3.官方示例看懂上面简单的示例后再来看官方quick start就更轻松一点。这里面内容更丰富一点，包括对方法的解析，分另用context和factory两种方式来给变量赋值，最后将${math:max(foo,bar)}成功解析为取foo和bar更大的一个。 1234567891011121314151617181920// the ExpressionFactory implementation is de.odysseus.el.ExpressionFactoryImplExpressionFactory factory = new ExpressionFactoryImpl();// package de.odysseus.el.util provides a ready-to-use subclass of ELContextSimpleContext context = new SimpleContext();// map function math:max(int, int) to java.lang.Math.max(int, int)context.setFunction(&quot;math&quot;, &quot;max&quot;, Math.class.getMethod(&quot;max&quot;, int.class, int.class));// map variable foo to 0context.setVariable(&quot;foo&quot;, factory.createValueExpression(0, int.class));// parse our expressionValueExpression e = factory.createValueExpression(context, &quot;${math:max(foo,bar)}&quot;, int.class);// set value for top-level property &quot;bar&quot; to 1factory.createValueExpression(context, &quot;${bar}&quot;, int.class).setValue(context, 1);// get value for our expressionSystem.out.println(e.getValue(context)); // --&gt; 1 4. 简单解析器Juel提供SimpleResolver类作为基本的解析器来解析表达式中的属性，如下所示，既可以解析top-level属性，也可以解析bean。1234567891011ExpressionFactory factory = new ExpressionFactoryImpl();SimpleContext context = new SimpleContext(new SimpleResolver());// resolve top-level propertyfactory.createValueExpression(context, &quot;#{pi}&quot;, double.class).setValue(context, Math.PI);ValueExpression expr1 = factory.createValueExpression(context, &quot;${pi/2}&quot;, double.class);System.out.println(&quot;pi/2 = &quot; + expr1.getValue(context)); // pi/2 = 1.5707963267948966// resolve bean propertyfactory.createValueExpression(context, &quot;#{current}&quot;, Date.class).setValue(context, new Date());ValueExpression expr2 = factory.createValueExpression(context, &quot;${current.time}&quot;, long.class);System.out.println(&quot;current.time = &quot; + expr2.getValue(context));// --&gt; current.time = 1538048848843","link":"/2018/09/27/Juel基本使用/"},{"title":"Oracle之DML触发器基本使用","text":"触发器是当某个事件发生时自动地隐式运行。DML触发器指的是在对表进行增删改操作引发的自动执行事件。 创建触发器的一般语法：123456789CREATE [OR REPLACE] TRIGGER trigger_name{BEFORE | AFTER }{INSERT | DELETE | UPD&lt;!-- more --&gt;ATE [OF column [, column …]]}[OR {INSERT | DELETE | UPDATE [OF column [, column …]]}...]ON [schema.]table_name | [schema.]view_name[REFERENCING {OLD [AS] old | NEW [AS] new| PARENT as parent}][FOR EACH ROW ][WHEN condition]PL/SQL_BLOCK | CALL procedure_name; 其中：BEFORE 和AFTER指出触发器的触发时序分别为前触发和后触发方式。FOR EACH ROW选项说明触发器为行触发器。REFERENCING 子句说明相关名称，在行触发器的PL/SQL块和WHEN 子句中可以使用相关名称参照当前的新、旧列值，默认的相关名称分别为OLD和NEW。触发器的PL/SQL块中应用相关名称时，必须在它们之前加冒号(:)，但在WHEN子句中则不能加冒号。 WHEN 子句说明触发约束条件。 Demo1: 记录每条记录的插入时间(10g后可以在建表时用rowdependencies实现等级追踪实现效果同样)12345678910111213--先创建日志记录表CREATE TABLE SZ_RECORD_TEST (&quot;SZID&quot; VARCHAR2(1024) NOT NULL, &quot;SZVERSION&quot; VARCHAR2(1024), &quot;EVENT_TIME&quot; DATE DEFAULT sysdate NOT NULL); CREATE OR REPLACE TRIGGER TRG_SZD AFTER INSERT ON TT_SZD FOR EACH ROWBEGIN INSERT INTO SZ_RECORD_TEST(SZID,SZVERSION) VALUES (:NEW.SZD_ID, :NEW.VERSION);END; Demo2: 限制对Departments表修改（包括INSERT,DELETE,UPDATE）的时间范围，即不允许在非工作时间修改departments表。12345678CREATE OR REPLACE TRIGGER tr_dept_timeBEFORE INSERT OR DELETE OR UPDATEON departmentsBEGIN IF (TO_CHAR(sysdate,&apos;DAY&apos;) IN (&apos;星期六&apos;, &apos;星期日&apos;)) OR (TO_CHAR(sysdate, &apos;HH24:MI&apos;) NOT BETWEEN &apos;08:30&apos; AND &apos;18:00&apos;) THEN RAISE_APPLICATION_ERROR(-20001, &apos;不是上班时间，不能修改departments表&apos;); END IF;END; Demo3: 限定只对部门号为80的记录进行行触发器操作。12345678910111213141516171819202122CREATE OR REPLACE TRIGGER tr_emp_sal_commBEFORE UPDATE OF salary, commission_pct OR DELETEON HR.employeesFOR EACH ROWWHEN (old.department_id = 80)BEGIN CASE WHEN UPDATING (&apos;salary&apos;) THEN IF :NEW.salary &lt; :old.salary THEN RAISE_APPLICATION_ERROR(-20001, &apos;部门80的人员的工资不能降&apos;); END IF; WHEN UPDATING (&apos;commission_pct&apos;) THEN IF :NEW.commission_pct &lt; :old.commission_pct THEN RAISE_APPLICATION_ERROR(-20002, &apos;部门80的人员的奖金不能降&apos;); END IF; WHEN DELETING THEN RAISE_APPLICATION_ERROR(-20003, &apos;不能删除部门80的人员记录&apos;); END CASE;END;","link":"/2017/06/07/Oracle之DML触发器基本使用/"},{"title":"Oracle创建表空间和用户脚本","text":"1234567891011121314151617181920212223242526272829303132-- 删除用户和表空间drop user INTEPDM cascade;DROP TABLESPACE INTEPDM INCLUDING CONTENTS AND DATAFILES;--创建表空间create tablespace INTEPDM logging data&lt;!-- more --&gt;file &apos;D:\\oracle\\oradata\\orcl\\INTEPDM.dbf&apos; size 50m autoextend on next 50m maxsize 20480m extent management local; --创建用户 create user INTEPDM profile default identified by &quot;Ghost&quot; default tablespace INTEPDM temporary tablespace TEMP account unlock; --给用户授权GRANT &quot;CONNECT&quot; TO INTEPDM;GRANT &quot;RESOURCE&quot; TO INTEPDM;grant connect,resource,dba to INTEPDM; grant create cluster to INTEPDM;grant create database link to INTEPDM;grant create procedure to INTEPDM;grant create sequence to INTEPDM;grant create table to INTEPDM;grant create trigger to INTEPDM;grant create type to INTEPDM;grant create view to INTEPDM;grant debug any procedure to INTEPDM;grant debug connect session to INTEPDM;grant select any dictionary to INTEPDM;","link":"/2018/03/06/Oracle创建表空间和用户脚本/"},{"title":"Python正则表达式","text":"正则表达式是用来简洁表达一组字符串的表达式 1. 正则表达式的常用操作符 2. 经典正则表达式实例 3. Re库使用3.1 两种用法12345678910111213141516import re#函数式用法：一次性操作match = re.search(r&apos;[1‐9]\\d{5}&apos;,&apos;BIT 100081&apos;)if match: print(match.group(0))#面向对象用法：编译后的多次操作pat = re.compile(r&apos;[1‐9]\\d{5}&apos;)match = pat.search(&apos;BIT 100081&apos;)if match: print(match.group(0))match = pat.search(&apos;100082 BIT 100081&apos;)if match: print(match.group(0)) 输出结果： 3.2 Re库主要功能函数123456789101112131415161718192021222324252627import re#1. 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象match = re.search(r&apos;[1-9]\\d{5}&apos;,&apos;430074 BIT 100081 430074&apos;)if match: print(&quot;search:&quot; + match.group(0))#2. 从一个字符串的开始位置起匹配正则表达式，返回match对象match = re.match(r&apos;[1-9]\\d{5}&apos;,&apos;430074 BIT 100081&apos;)if match: print(&quot;match:&quot; + match.group(0))#3. 搜索字符串，以列表类型返回全部能匹配的子串list= re.findall(r&apos;[1-9]\\d{5}&apos;,&apos;430074 BIT 100081&apos;)print(&quot;findall:&quot; + str(list))#4. 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型list= re.split(r&apos;[1-9]\\d{5}&apos;,&apos;TSU 430074 BIT 100081END 430008 kk&apos;,maxsplit=2)print(&quot;split:&quot; + str(list))#5. 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象for m in re.finditer(r&apos;[1-9]\\d{5}&apos;,&apos;430074 BIT 100081&apos;): if m: print(&quot;finditer:&quot; + m.group(0))#6. 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串str = re.sub(r&apos;[1-9]\\d{5}&apos;,&apos;INSTEADED&apos;,&apos;430074 BIT 100081&apos;)print(&quot;sub:&quot; + str) 输出结果： 4. 贪婪匹配和最小匹配1234567891011import re#python 默认是贪婪匹配match = re.search(r&apos;PY.*N&apos;,&apos;PYANBNCNDN&apos;)if match: print(match.group(0)) #加?最小匹配match = re.search(r&apos;PY.*?N&apos;,&apos;PYANBNCNDN&apos;)if match: print(match.group(0)) 输出结果：","link":"/2017/12/07/Python正则表达式/"},{"title":"Scrapy爬取所有股票的最新信息","text":"##1. Scrapy框架如下图所示，Scrapy构架由五大组件（SPIDERS,ENGINE,SCHEDULER,DOWNLOADER,ITEM PIPELINES），两个中间件（SPIDERS到ENGINE,ENGINE到DOWNLOADER）,三条数据流组成（①②，③④⑤⑥，⑦⑧），我们在使用时一般只需要通过genspider命令创建spider并编写处理逻辑，然后在pipelines里面对数据进行处理存储即可。 2. 爬取股票信息GitHub地址：https://github.com/Acamy/BaiduStocks 创建工程和spider文件 123scrapy startproject BaiduStockscd BaiduStocksscrapy genspider stocks baidu.com 编写spider 编写Pipelines 4.配置settings.py 运行spider1scrapy crawl stocks","link":"/2017/12/12/Scrapy爬取所有股票的最新信息/"},{"title":"Scrapy爬取西刺网站代理IP并写入MySQL","text":"Scrapy : 1.4.0Python : 3.6.2MySQL : 5.6Platform : Windows-7-6.1.7601-SP1 1. 目标网站分析 如下图所示，本文准备爬取国内高匿代理部分的IP信息，通过火狐浏览器可以看到有效信息都在id为ip_list的table里面，所以通过xpath和正则表达式即可拿到想要的信息。通过观察不同分页的url后发现从每二页开始每个url后面的数字即为当前页次，因而可以列举所有页面(本文示例代码爬取前三页)。 2. 数据库准备 Python需要安装MySQLdb模块，根据我们所需要的信息建表 12345678CREATE TABLE proxy( IP char(20), PORT char(20), TYPE char(20), POSITION char(20), SPEED char(20), LAST_CHECK_TIME char(20)); 3. 项目开发3.1 在cmd下通过以下命令即可创建典型Scrapy项目结构。1scrapy startproject collectips 3.2 定义Item Item中的信息与网站和数据库对应，我们需要IP地址，端口，服务器地址，类型，速度，验证时间这六个字段。 items.py123456789import scrapyclass CollectipsItem(scrapy.Item): IP = scrapy.Field() PORT = scrapy.Field() POSITION = scrapy.Field() TYPE = scrapy.Field() SPEED = scrapy.Field() LAST_CHECK_TIME = scrapy.Field() 3.3 创建spider 通过以下命令创建名为xici的spider模板1scrapy genspider xici xicidaili.com 然后编写具体处理逻辑：xici.py:12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-import scrapyfrom collectips.items import CollectipsItemclass XiciSpider(scrapy.Spider): name = &apos;xici&apos; allowed_domains = [&apos;xicidaili.com&apos;] start_urls = [&apos;http://www.xicidaili.com&apos;] def start_requests(self): reqs = [] for i in range(1,3): req = scrapy.Request(&quot;http://www.xicidaili.com/nn/%s&quot;%i) reqs.append(req) return reqs def parse(self, response): ip_list = response.xpath(&apos;//table[@id=&quot;ip_list&quot;]&apos;) trs = ip_list[0].xpath(&apos;tr&apos;) items = [] for ip in trs[1:]: pre_item = CollectipsItem() pre_item[&apos;IP&apos;] = ip.xpath(&apos;td[2]/text()&apos;)[0].extract() pre_item[&apos;PORT&apos;] = ip.xpath(&apos;td[3]/text()&apos;)[0].extract() pre_item[&apos;POSITION&apos;] = ip.xpath(&apos;string(td[4])&apos;)[0].extract().strip() pre_item[&apos;TYPE&apos;] = ip.xpath(&apos;td[6]/text()&apos;)[0].extract() pre_item[&apos;SPEED&apos;] = ip.xpath(&apos;td[8]/div[@class=&quot;bar&quot;]/@title&apos;).re(&apos;\\d{0,2}\\.\\d{0,}&apos;)[0] pre_item[&apos;LAST_CHECK_TIME&apos;] = ip.xpath(&apos;td[10]/text()&apos;)[0].extract() items.append(pre_item) return items 3.3 相关参数设置 数据库连接，日志文件，代理浏览器相关设置 settings.py 123456789101112131415161718192021# -*- coding: utf-8 -*-BOT_NAME = &apos;collectips&apos;SPIDER_MODULES = [&apos;collectips.spiders&apos;]NEWSPIDER_MODULE = &apos;collectips.spiders&apos;#database connection parametersDBKWARGS = {&apos;db&apos;:&apos;mysql&apos;,&apos;user&apos;:&apos;root&apos;,&apos;passwd&apos;:&apos;root&apos;, &apos;host&apos;:&apos;localhost&apos;,&apos;use_unicode&apos;:True,&apos;charset&apos;:&apos;utf8&apos;}ITEM_PIPELINES = { &apos;collectips.pipelines.CollectipsPipeline&apos;:300,}LOG_FILE = &quot;scrapy.log&quot;# Obey robots.txt rulesROBOTSTXT_OBEY = TrueUSER_AGENT = &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&apos; 3.3 数据存储 将提取的数据写入MySQL数据库，注意数据库的连接关闭和异常的获取。 pipelines.py：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import MySQLdbclass CollectipsPipeline(object): def process_item(self, item, spider): DBKWARGS = spider.settings.get(&apos;DBKWARGS&apos;) con = MySQLdb.connect(**DBKWARGS) cur = con.cursor() sql = (&quot;insert into proxy(IP,PORT,TYPE,POSITION,SPEED,LAST_CHECK_TIME) &quot; &quot;values(%s,%s,%s,%s,%s,%s)&quot;) lis = (item[&apos;IP&apos;],item[&apos;PORT&apos;],item[&apos;TYPE&apos;],item[&apos;POSITION&apos;],item[&apos;SPEED&apos;], item[&apos;LAST_CHECK_TIME&apos;]) try: cur.execute(sql,lis) except Exception as e: print(&quot;Insert Error:&quot;,e) con.rollback() else: con.commit() cur.close() con.close() return item 效果如下：","link":"/2017/11/11/Scrapy爬取西刺网站代理IP并写入MySQL/"},{"title":"SpringBoot2.0学习(一)-初体验","text":"Spring Boot通过内嵌Tomcat等容器使开发人员可以直接调试，起步依赖和自动配置两大特性大大简化了配置文件，从而使得开发一款基于Spring的可以直接运行的独立生产级应用变得更加简单。现在企业中对Spring Boot的应用也越来越流行，当前最新版本已更新到2.0。SpringBoot2.0学习系列主要参考资料如下： spring-boot-referenceSpring Boot实战 Java 微服务实践 - Spring Boot 系列 1.创建SpringBoot应用的三种方式#####1.1 手动配置 ######1.1.1 创建项目结构如下所示，不包含test和resources结构的最简可运行SpringBoot项目结构。1234567demo+-- src| +-- main| +-- java| +-- com.example.demo| +-- DemoApplication.java+-- pom.xml ######1.1.2 编辑pom.xml文件pom文件需要添加如下的父项目和依赖，其它格式按照通用就行。1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ######1.1.3 编辑SpringBoot启动类1234567891011package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); }} ######1.1.4 运行项目直接在启动类中右键选择运行即可运行项目，控制台首先打印出Spring字样的Banner以及SpringBoot版本信息，接下来第一行打印该项目对应的进程ID(通过该ID可以用jconsole观察项目运行情况)，后面还有内嵌tomcat端口，过滤器，匹配url等信息。 #####1.2 Spring Initializr Spring Initializr页面提供了快速创建Spring的方式，如图我们首先选择好构建工具(Maven)，开发语言(Java)，Spring Boot(2.0.2)版本，然后输入Group ID, Artifact ID后并通过关键词添加相关依赖，最后点击创建项目即可下载Spring Boot项目结构的压缩包，解压后就可以导入到IDE中进行功能开发。 #####1.3 Idea中创建在idea界面依次选择File-&gt;New-&gt;Project打开的面板中选择Spring Initializr，保持默认配置点击Next按钮即可进行1.2中类似的相关配置。 2. Hello World在启动类上添加@Controller注解并增加以下内容后启动项目即可通过对应url访问。1234567891011121314@RequestMapping(&quot;/&quot;)@ResponseBodypublic String hello(){ return &quot;Hello World&quot;;}@RequestMapping(&quot;/rest&quot;)@ResponseBodypublic Map&lt;String, Object&gt; rest(){ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;1&quot;, &quot;Hello, Spring Boot!&quot;); map.put(&quot;2&quot;, 111111111); return map;} 3. ActuatorActuator为Spring Boot应用程序提供了许多web端点，它们以json格式数据的形式反映应用程序运行时的内部状况，在没有jconsole等GUI工具的情况下也能了解程序运行信息。这里对Actuator的使用只作简单介绍，后续会有具体讨论。 3.1 编辑pom.xml在pom文件中增加actuator依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 编辑application.properties因为actuator的端点可能包含有敏感信息，因此对web程序的默认设置并没有暴露它们，这里为了演示效果，直接在application.properties文件中增加management.endpoints.web.exposure.include=*来暴露所有端点。 3.3 运行访问右键运行项目后可以看到相对于控制台打印了很以/actuator作为前缀的url匹配信息，我们在浏览器中可以进行对应的访问，后续再对具体端点进行详细介绍。","link":"/2018/05/22/SpringBoot2.0学习(一)-初体验/"},{"title":"SpringBoot2.0学习(三)-JDBC","text":"连接数据库是一个永恒的话题，本文先给出传统方式连接数据库的步骤，然后演示Springboot使用JdbcTemplate的方法，最后介绍当前比较流行的数据库连接池。 GitHub源码地址 1. 传统JavaWeb项目连接数据库的方式如下图所示，当我们通过idea新建一个javaweb项目后，基本上还需要以下的五步才能使用数据库。 #####1.1 引入驱动因为数据库配置信息是准备放在tomcat的配置文件中的，所以需要先把mysql-connector-java-5.1.34.jar拷贝到tomcat/lib目录中。 #####1.2 添加Resource标签在tomcat/conf/context.xml中添加如下内容:1234&lt;Resource name=&quot;jdbc/TestDB&quot; auth=&quot;Container&quot; type=&quot;javax.sql.DataSource&quot; maxTotal=&quot;100&quot; maxIdle=&quot;30&quot; maxWaitMillis=&quot;10000&quot; username=&quot;root&quot; password=&quot;123456&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://localhost:3306/&quot; /&gt; 注意: 如果涉及到具体数据库就需要将url具体到某一个数据库 #####1.3 添加resource-ref标签在javaweb项目的web.xml中添加以下内容:12345&lt;resource-ref&gt; &lt;res-ref-name&gt;jdbc/TestDB&lt;/res-ref-name&gt; &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt; &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; #####1.4 编写 Servlet类 如上图所示，在tomcat的官方文档中可以了解到，要使用resource标签，必须先实例化初始上下文，然后找到以java:comp/env为名称的上下文，再在将上下文中获取相应的资源。123456789101112131415161718192021222324252627282930public class JDBCTestServlet extends HttpServlet { private DataSource ds; public void init(ServletConfig servletConfig) throws ServletException { try { Context initContext = new InitialContext(); Context envContext = (Context)initContext.lookup(&quot;java:comp/env&quot;); ds = (DataSource)envContext.lookup(&quot;jdbc/TestDB&quot;); } catch (NamingException e) { e.printStackTrace(); } } public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{ Writer writer = response.getWriter(); response.setContentType(&quot;text/html;charset=UTF-8&quot;); try { Connection conn = ds.getConnection(); Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery(&quot;SHOW DATABASES&quot;); while (rs.next()){ String dbName = rs.getString(1); writer.write(dbName + &quot;&lt;br /&gt;&quot;); writer.flush(); } } catch (SQLException e) { e.printStackTrace(); } }} #####1.5 配置Servlet映射在web.xml中添加以下内容：12345678&lt;servlet&gt; &lt;servlet-name&gt;jdbcServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;JDBCTestServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jdbcServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/jdbc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 运行效果： 2. SpringBoot中使用JdbcTemplate在SpringBoot中使用JdbcTemplatel连接数据库就非常简单了，添加后依赖后配置连接信息，编写Controller类就可以了。 2.1 添加依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2.2 添加配置1234spring.datasource.url=jdbc:mysql://localhost:3306/testspring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver 2.3 编写Controller类通过上面的配置在SpringBoot项目启动时就会自动装配JdbcTemplate类，所以可以直接用@Autowired进行注入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RestControllerpublic class JDBCController { @Autowired private DataSource ds; @GetMapping(&quot;/jdbc&quot;) public Map&lt;String, Object&gt; getUsers(@RequestParam(value = &quot;id&quot;, defaultValue = &quot;1&quot;) String id){ Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); Connection conn = null; try { conn = ds.getConnection(); PreparedStatement preparedStatement = conn.prepareStatement(&quot;SELECT id,name,age FROM user WHERE id=?&quot;); preparedStatement.setString(1,id); ResultSet rs = preparedStatement.executeQuery(); while(rs.next()){ data.put(&quot;id&quot;, rs.getInt(&quot;id&quot;)); data.put(&quot;name&quot;, rs.getString(&quot;name&quot;)); data.put(&quot;age&quot;, rs.getInt(&quot;age&quot;)); } } catch (SQLException e) { e.printStackTrace(); } finally { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } return data; } @Autowired private JdbcTemplate jdbcTemplate; @PostMapping(&quot;/addUser&quot;) public Map&lt;String, Object&gt; addUser(@RequestBody User user){ Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;(); Boolean result = jdbcTemplate.execute(&quot;INSERT INTO user(name,age) VALUES (?, ?)&quot;,new PreparedStatementCallback&lt;Boolean&gt;(){ @Override public Boolean doInPreparedStatement(PreparedStatement ps) throws SQLException, DataAccessException { ps.setString(1, user.getName()); ps.setInt(2, user.getAge()); return ps.executeUpdate() &gt; 0; } }); data.put(&quot;success&quot;, result); return data; }} 运行效果: 3. 连接池当前连接池有非常多，如比较传统的dbcp, c3p0，现在比较流行的阿里druid。各种数据库连接池对比 TODO： 关于事务，以及连接池的详细使用还有待深入研究","link":"/2018/05/31/SpringBoot2.0学习(三)-JDBC/"},{"title":"SpringBoot2.0学习(二)-Servlet&Jsp","text":"本文主要介绍在SpringBoot2.0中如何使用Servlet和Jsp，如图所示，对于Servlet的创建主要使用了注解方式和API注册方式，分别讲解了Servlet, Filter和Listener的创建。对于Jsp的使用，由于SpringBoot更提倡使用模板引擎，所以对于Jsp的自动配置 并不多，主要还是手动配置，本文对其步骤进行梳理。 项目结构: Github源码地址 1. SprinbBoot中使用Servlet#####1.1 注解方式a. 首先添加组件扫描注解1@ServletComponentScan(basePackages=&quot;com.hebaohua.springbootservletjsp.anotationServlet&quot;) b.配置Servlet1234567891011121314151617181920212223242526272829303132333435@WebServlet( name = &quot;myServlet&quot;, urlPatterns = &quot;/myservlet&quot;, initParams = @WebInitParam(name = &quot;paramName&quot;, value = &quot;paramValue&quot;))public class MyServlet extends HttpServlet { String value; @Override public void init(ServletConfig config) throws ServletException { super.init(config); ServletContext context = getServletContext(); context.log(&quot;init has been executed...&quot;); value = config.getInitParameter(&quot;paramName&quot;); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Writer writer = resp.getWriter(); ServletContext context = getServletContext(); context.log(&quot;doGet has been executed...&quot;); writer.write(&quot;&lt;html&gt;&lt;body&gt;Hello, &quot; + value + &quot;&lt;/body&gt;&lt;/html&gt;&quot;); } @Override public void destroy() { ServletContext context = getServletContext(); context.log(&quot;destroy has been executed...&quot;); }} c.配置Filter123456789@WebFilter(urlPatterns = &quot;/myservlet&quot;)public class MyFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { ServletContext context = request.getServletContext(); context.log(&quot;myservlet is filterd...&quot;); filterChain.doFilter(request, response); }} d. 配置Listener1234567891011121314151617@WebListenerpublic class MyServletRequestListener implements ServletRequestListener { @Override public void requestInitialized(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); ServletContext context = request.getServletContext(); context.log(&quot;requestInitialized in Listener...&quot;); } @Override public void requestDestroyed(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); ServletContext context = request.getServletContext(); context.log(&quot;requestDestroyed in Listener...&quot;); }} #####1.2 API注册 a.配置Servlet1234567891011121314151617181920212223242526272829public class MyServlet2 extends HttpServlet { String value; @Override public void init(ServletConfig config) throws ServletException { super.init(config); ServletContext context = getServletContext(); context.log(&quot;init2 has been executed...&quot;); value = config.getInitParameter(&quot;paramName2&quot;); } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Writer writer = resp.getWriter(); ServletContext context = getServletContext(); context.log(&quot;doGet2 has been executed...&quot;); writer.write(&quot;&lt;html&gt;&lt;body&gt;Hello, &quot; + value + &quot;&lt;/body&gt;&lt;/html&gt;&quot;); } @Override public void destroy() { ServletContext context = getServletContext(); context.log(&quot;destroy2 has been executed...&quot;); }} b.配置Filter12345678public class MyFilter2 extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { ServletContext context = request.getServletContext(); context.log(&quot;myservlet2 is filterd...&quot;); filterChain.doFilter(request, response); }} c. 配置Listener123456789101112131415public class MyServletRequestListener2 implements ServletRequestListener { @Override public void requestInitialized(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); ServletContext context = request.getServletContext(); context.log(&quot;requestInitialized2 in Listener...&quot;); } @Override public void requestDestroyed(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); ServletContext context = request.getServletContext(); context.log(&quot;requestDestroyed2 in Listener...&quot;); }} d.注册在主类中增加以下代码：123456789101112131415161718192021222324@Bean public static ServletRegistrationBean servletRegistrationBean(){ ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(); servletRegistrationBean.setServlet(new MyServlet2()); servletRegistrationBean.addUrlMappings(&quot;/myservlet2&quot;); servletRegistrationBean.addInitParameter(&quot;paramName2&quot;, &quot;myvalue2&quot;); return servletRegistrationBean; } @Bean public static FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilter2()); filterRegistrationBean.addUrlPatterns(&quot;/myservlet2&quot;); return filterRegistrationBean; } @Bean public static ServletListenerRegistrationBean servletListenerRegistrationBean(){ ServletListenerRegistrationBean servletListenerRegistrationBean = new ServletListenerRegistrationBean(); servletListenerRegistrationBean.setListener(new MyServletRequestListener2()); return servletListenerRegistrationBean; } 运行日志: 2. SprinbBoot中使用Jsp2.1 添加依赖12345678910&lt;!-- JSP 渲染引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 激活传统Servle部署让主类继承SpringBootServletInitializerpublic class SpringbootServletJspApplication extends SpringBootServletInitializer 2.3 组装在主类中增加以下代码：1234protected SpringApplicationBuilder configure(SpringApplicationBuilder builder){ builder.sources(SpringbootServletJspApplication.class); return builder; } 2.4 编写.jsp文件创建src\\main\\webapp\\WEB-INF\\jsp文件夹并添加index.jsp文件:12345&lt;html&gt;&lt;body&gt;Hello, ${name}&lt;/body&gt;&lt;/html&gt; 2.5 配置JSP视图在application.properties文件中增加以下内容:12spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp 2.6 编写Controller12345678@Controllerpublic class JspControllerDemo { @GetMapping(&quot;/jsp&quot;) String jspTest(Model model) { model.addAttribute(&quot;name&quot;, &quot;Acamy&quot;); return &quot;index&quot;; }} 运行测试:","link":"/2018/05/31/SpringBoot2.0学习(二)-Servlet&Jsp/"},{"title":"SpringBoot2.0学习(五)-JPA","text":"JPA的全称是Java Persistence API，即Java持久化API，JSR编号338，具体使用可以参考官方文档。本文首先介绍在SpringBoot的简单使用，然后对实体间的关系进行讲述。 GitHub源码地址 1. 简单使用1.1 引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1.2 配置数据库的连接1234spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/jpatest #####1.3 编写实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Entity@Table(name = &quot;user&quot;)@JsonIgnoreProperties({&quot;hibernateLazyInitializer&quot;, &quot;handler&quot;}) //avoid Exceptionpublic class User{ @Id @GeneratedValue private Long id; private String name; private int age; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, age=&quot; + age + &apos;}&apos;; }} 1.3 编写Repository这里只需要继承JpaRepository这个接口就能注入带有增删改查基本操作的实现类。12public interface UserRepository extends JpaRepository&lt;User, Long&gt; {} 1.4 在Controller中使用1234567891011121314151617@RestControllerpublic class UserController { @Autowired private UserRepository userRepository; @GetMapping(&quot;user/{id}&quot;) public User getUser(@PathVariable long id){ User user = userRepository.getOne(id); return user; } @GetMapping(&quot;all&quot;) public List&lt;User&gt; findAllUsers(){ return userRepository.findAll(); }} 2.实体间的关系2.1 编写实体实体间的关系分为单向和双向。此处只列举双向关系，现在有四个实体Employee, Cubicle, Department，Project。Employee与Cubicle为一对一(OneToOne)的关系，即员工与工位之间一一对应，且Employee为主控方;Employee与Department为多对一(ManyToOne)的关系，即一个部门里有多个员工，Department为主控方;Employee与Project为多对多(ManyToMany)的关系，即一个员工可以参与多个项目，一个项目里有多个员工，且Project为主控方。满足以上条件的各实体代码(省略getset方法)如下:12345678910111213141516171819@Entitypublic class Employee { @Id @GeneratedValue private long id; private String name; private int age; @OneToOne(cascade = CascadeType.ALL) private Cubicle cubicle; @ManyToOne(cascade = CascadeType.ALL) private Department department; @ManyToMany(mappedBy = &quot;employees&quot;) private Collection&lt;Project&gt; projects;} 1234567891011@Entitypublic class Cubicle { @Id @GeneratedValue private long id; @OneToOne(mappedBy = &quot;cubicle&quot;) private Employee employee; private String location;} 1234567891011@Entitypublic class Department { @Id @GeneratedValue private long id; @OneToMany(mappedBy = &quot;department&quot;) private Collection&lt;Employee&gt; employees; private String departName;} 12345678910@Entitypublic class Project { @Id @GeneratedValue private long id; @ManyToMany(cascade = CascadeType.ALL) private Collection&lt;Employee&gt; employees; private String projName; 注意:cascade写要主控方的字段注解上，表示级联操作。 2.2 编写Repository12public interface EmpoyeeRepository extends JpaRepository&lt;Employee, Long&gt; {} 2.3 编写Controller1234567891011@RestControllerpublic class EmployeeController { @Autowired private EmpoyeeRepository empoyeeRepository; @PostMapping(&quot;/addEmployee&quot;) public Employee addEmpoyee(@RequestBody Employee employee){ empoyeeRepository.save(employee); return empoyeeRepository.getOne(employee.getId()); }} 2.4 配置自动ddl操作如果需要自动创建表则在SpringBoot主配置文件中增加下面的代码，表示每次启动时都会进行create-drop操作。1spring.jpa.hibernate.ddl-auto=create-drop 2.5 查看表结构启动项目后可以在数据库中看到生成了employee,cubicle,department，project,project_employee,hibernate_sequence,hibernate_sequence六张表。 对于OneToOne和ManyToOne，会在主控方中以“被控方表名_id”形式添加字段，如employee表结构： 对于ManyToMany会创建一张中间表,如project_employess: 2.6 测试在PostMan中Headers设置Content-Type为Application/json;charset=UTF-8,Body中写入以下内容1{&quot;name&quot;:&quot;Jay&quot;,&quot;age&quot;:16,&quot;cubicle&quot;:{&quot;location&quot;:&quot;Wuhan&quot;},&quot;department&quot;:{&quot;departName&quot;:&quot;Java&quot;},&quot;projects&quot;:[{&quot;projName&quot;:&quot;Project1&quot;},{&quot;projName&quot;:&quot;Project2&quot;}]} 然后以http://localhost:8080/addEmployee作为url发送post请求，则可以查看相应的数据库表中增加记录。","link":"/2018/06/01/SpringBoot2.0学习(五)-JPA/"},{"title":"Windows下Navicat远程连接阿里云Ubutun的mysql数据库","text":"1. 添加访问用户命令中的user和password分别为远程连接时的用户名和密码1GRANT ALL PRIVILEGES ON *.* TO &apos;user&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; WITH GRANT OPTION; 2. 刷新权限1flush privileges; 3. 查看是否添加成功1SELECT DISTINCT CONCAT(&apos;User: &apos;&apos;&apos;,user,&apos;&apos;&apos;@&apos;&apos;&apos;,host,&apos;&apos;&apos;;&apos;) AS query FROM mysql.user; 4. 查看mysql占用的端口 5. 修改配置文件注意该配置文件的路径，网上其它教程很多都是在/etc/mysql/my.cnf注释掉 bind-address = 127.0.0.1 6. 重启mysql服务1service mysql restart 7. 阿里云管理控制台中添加安全组规则该端口与第4步中的端口一致，如果是一般服务器只需要关闭防火墙或在防火墙中开户该端口即可 8. 通过Navicat进行连接通过以上的操作就可以在Navicat中连接远程的mysql数据库了，需要配置ip,端口，用户名，密码，然后点击左下角的连接测试就可以检测了。","link":"/2018/01/03/Windows下Navicat远程连接阿里云Ubutun的mysql数据库/"},{"title":"git常用命令","text":"####1. 取消本地所有修改用暂存区的文件覆盖本地，使用该命令相当危险，不给提示确认git checkout . 2. 删除远程分支git push &lt;remote&gt; --delete &lt;branch&gt; 3. 设置upstream创建分支后第一次推送时用该命令可设置upstreamgit push -u &lt;remote&gt; &lt;branch&gt; 4. 创建并切换到新的分支git checkout -b &lt;branch&gt; 5.基于远程仓库创建新分支并且切换到新分支git checkout -b &lt;BRANCH-NAME&gt; &lt;REMOTE-NAME&gt;/&lt;BRANCH-NAME&gt;","link":"/2018/10/10/git常用命令/"},{"title":"mac下编译OpenJDK10","text":"OpenJDK是与Oracle JDK最接近的开源jdk，周志明老师在《深入理解JAVA虚拟机》第一章就建议大家自己编译下OpenJDK的源码，最近遇到JVM相关的一些问题，又心血来潮的想试试。如果是第一次编译的话真的是很难一次成功的，由于操作系统、软件环境、OpenJDK版本不同各种千奇百怪的问题都有。虽然项目中用的是java8，但因为自己使用macOS 10.13.6操作系统，看了下网上的一些文章对jdk8编译支持不是很好，因此选择了不少人编译成功的jdk9进行下手。但是jdk9到我这里也行不通，遇到的问题在openjdk官网和stackoverflow上都有人反映，但没人回答, 因此不得不放弃。接下来试jdk9u遇到相同错误，换到jdk10却异常顺利，无需像jdk9一样改源码啥的，一次成功。因此如果你打算在mac上尝试编译的话，建议直接编译jdk10吧。 ####1. 工具准备 homebrew，mac下的包管理工具/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; mercurial, openjdk源码版本管理工具sudo easy_install mercurial ccache, freetype, 编译以及加速编译时所要用到的brew install ccachebrew install freetype 2. 下载源码 hg clone hg clone http://hg.openjdk.java.net/jdk10/jdk10/ 修改get_source.sh最后几行如下以防止中断 123456789101112131415# Get clones of all absent nested repositories (harmless if already exist)sh ./common/bin/hgforest.sh clone &quot;$@&quot;while [ $? -ne 0 ]do sh ./common/bin/hgforest.sh clone &quot;$@&quot;done# Update all existing repositories to the latest sourcessh ./common/bin/hgforest.sh pull -uwhile [ $? -ne 0 ]do sh ./common/bin/hgforest.sh pull -udone 执行以下命令以获取全部资源： sh ./get_source.sh 3. 执行configure`sh ./configure --with-target-bits=64 --with-freetype=/usr/local/Cellar/freetype/2.9.1 --enable-ccache --with-jvm-variants=server,client --with-boot-jdk-jvmargs=&quot;-Xlint:deprecation -Xlint:unchecked&quot; --disable-zip-debug-info --disable-warnings-as-errors --with-debug-level=slowdebug 2&gt;&amp;1 | tee configure_mac_x64.log` 注意：freetype版本要和自己使用的对应 4. 执行makeexport LANG=Cmake all LOG=debug 2&gt;&amp;1 | tee make_mac_x64.log 5. 验证执行./java -version打印如下表示编译成功。123openjdk version &quot;10-internal&quot;OpenJDK Runtime Environment (slowdebug build 10-internal+0-adhoc.baohuahe.jdk10)OpenJDK 64-Bit Server VM (slowdebug build 10-internal+0-adhoc.baohuahe.jdk10, mixed mode) 接下来就可以愉快的看jvm源码和进行本地调试了。","link":"/2018/10/19/mac下编译OpenJDK10/"},{"title":"struts2框架(二)通配符，动态方法调用，全局结果，resultType","text":"1.Struts2通配符映射机制 一个 Web 应用可能有成百上千个 action 声明. 可以利用 struts 提供的通配符映射机制把多个彼此相似的映射关系简化为一个映射关系 1.1 通配符映射规则 若找到多个匹配, 没有通配符的那个将胜出 若指定的动作不存在, Struts 将会尝试把这个 URI 与任何一个包含着通配符 的动作名及进行匹配 若 Struts 找到的带有通配符的匹配不止一个, 最后一个匹配将胜出 被通配符匹配到的 URI 字符串的子串可以用 {1}, {2} 来引用. {1} 匹配第一个子串, {2} 匹配第二个子串… {0} 匹配整个 URI 通配符可以匹配零个或多个字符, 但不包括 / 字符. 如果想把 / 字符包括在内, 需要使用 **. 如果需要对某个字符进行转义, 需要使用 . 1.2 通配符案例案例一: 多个路径访问同一个Action的同一个方法pattern.jsp映射路径所有的路径都是以xxxx_save.action模式出现的! 这三个路径需要访问同一个Action的 save()方法,如果没有通配符配置,那么就需要重复配置三个Action。通配符映射规则： 案例二: 不同的路径执行不同Action的相同方法pattern.jsp映射路径 所有的路径都是以Action类名XxxAction_save开头的。普通映射规则 使用通配符简化配置 使用*先将请求的路径匹配上,然后根据匹配的结果值传递给{1}中的参数。 案例三: 不同的路径执行同一个Action中不同的方法CRUDpattern.jsp映射路径 通配符映射规则： 2.Struts2动态方法调用 动态方法调用: 通过 url 动态调用 Action 中的方法 如果Action中存在多个方法时，我们可以使用!+方法名调用指定方法 默认情况下, Struts 的动态方法调用处于激活状态, 若想禁用该功能, 则可以在 struts.xml 文件中添加如下 constant 元素: 实现 注意:如果开发者手工的将动态方法调用设置为不可用,那么使用!直接报错。 3.Struts2全局结果 当多个action中都使用到了相同result，为了避免result的重复，这时我们 应该把result定义为全局结果。 实现 注意： 如果全局和局部有同名的result，那么局部会覆盖全局的result。 同一个应用中每次请求Struts2框架都会创建一个新的Action实例。 ( 开发者可以定义构造函数输出来测试 ) 4. Struts2的resultType resultType可以在配置文件struts-default.xml里看到，如下 123456789101112&lt;result-types&gt; &lt;result-type name=&quot;chain&quot; class=&quot;com.opensymphony.xwork2.ActionChainResult&quot;/&gt; &lt;result-type name=&quot;dispatcher&quot; class=&quot;org.apache.struts2.dispatcher.ServletDispatcherResult&quot; default=&quot;true&quot;/&gt; &lt;result-type name=&quot;freemarker&quot; class=&quot;org.apache.struts2.views.freemarker.FreemarkerResult&quot;/&gt; &lt;result-type name=&quot;httpheader&quot; class=&quot;org.apache.struts2.dispatcher.HttpHeaderResult&quot;/&gt; &lt;result-type name=&quot;redirect&quot; class=&quot;org.apache.struts2.dispatcher.ServletRedirectResult&quot;/&gt; &lt;result-type name=&quot;redirectAction&quot; class=&quot;org.apache.struts2.dispatcher.ServletActionRedirectResult&quot;/&gt; &lt;result-type name=&quot;stream&quot; class=&quot;org.apache.struts2.dispatcher.StreamResult&quot;/&gt; &lt;result-type name=&quot;velocity&quot; class=&quot;org.apache.struts2.dispatcher.VelocityResult&quot;/&gt; &lt;result-type name=&quot;xslt&quot; class=&quot;org.apache.struts2.views.xslt.XSLTResult&quot;/&gt; &lt;result-type name=&quot;plainText&quot; class=&quot;org.apache.struts2.dispatcher.PlainTextResult&quot; /&gt; &lt;/result-types&gt; 4.1 resultType之dispatcher默认的结果类型，以下两种情况等价： 参见dispatcher对应的class: ServletDispatcherResult API 推荐写法如下: 注意: dispatcher只是请求转发，不能转发到外部的资源，只能在本应用中转发， 如果要跨应用访问资源，需要使用重定向。 4.2 resultType之redirect参见redirect对应的class: ServletRedirectResult API 推荐写法如下: location: 指定跳转的路径，/开头默认添加应用名。parse : 指定是否把 location 参数的值视为一个 OGNL 表达式来解释. 默认值为 true 4.3 resultType之redirectAction参见redirectAction对应的class: ServletActionRedirectResult API 推荐写法如下: actionName: 指定跳转的Action的名字, 该Action已经定义。namespace: 指定该Action所在的命名空间。","link":"/2017/06/10/struts2框架(二)通配符，动态方法调用，全局结果，resultType/"},{"title":"从源码看ArrayList的实现","text":"在JAVA基础系列（五） 集合这篇文章中已经系统性的总结了JAVA中的集合体系，ArrayList是基于数组的List实现，查询快，增删慢，效率高，非线程安全。本文从源码的层面上来看一下ArrayList的构造，扩容与廋身，最后通过一个示例来加深理解。 1.构造方法从下面的源码知道ArrayList内部是用Object数组来实现，Object的length()即ArrayList的容量，而ArrayList里面真实元素的个数反映在size里面。当调用无参构造方法时会得到一个空的Object数组，同时也可以指定容量调用有参的构造函数。12345678910111213141516transient Object[] elementData;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};private int size;public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); }} 2.扩容根据下面的源码和grow方法的调用层次图可以看到每当在ArrayList里面增加一个元素时，最后都会调用grow方法来保证容量。如果我们用的无参构造函数来创建ArrayList对象，这时ArrayList的capacity和size都会0，当每一次往里面写入元素时，会调用ensureCapacityInternal(1),当进入这个方法时因elementData还是为空，所以minCapacity会赋值默认容量DEFAULT_CAPACITY即10，然后经过ensureExplicitCapacity(10)调用方法grow(10),经过一系列判断会执行grow方法里面的elementData = Arrays.copyOf(elementData, 10)，综上所述可知调用ArrayList无参构造函数时会创建一个空的Object数组，第一次往里面添加元素时才会得到默认容量为10的Object数组。同时以后每次往ArrayList里面添加元素时发现容量不够了都会调用grow方法，通过int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);实现了新的容量是旧的容量的1.5倍。 1234567891011121314151617181920212223242526272829303132333435 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; }private static final int DEFAULT_CAPACITY = 10; private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); }private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 3.廋身ArrayList里面有一个 trimToSize方法可以缩小它的容量，以节约空间。考虑到以下情形：当刚开始根据需要把ArrayList的容量扩充到10000左右，但后来通过remove操作使得size的大小只有100左右并且会保持这个状态很长一段时间，这时capacity还是维持在10000左右，这样势必造成很大的空间浪费，这样我们就可以显式的调用一下 trimToSize方法。通过下面的源码可以知道该方法会把ArrayList的capacity缩小致size大小。 12345678public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } 4.示例123456789101112131415161718192021222324252627282930313233343536373839import java.lang.reflect.Field;import java.util.ArrayList;import java.util.List;import javax.xml.transform.Templates;public class Main { public static void main(String[] args) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException{ ArrayList arrList = new ArrayList(); //无参初始化，创建一个空的Object数组 System.out.println(getObjArrLength(arrList,&quot;elementData&quot;));//0 //循环添加10000个元素，当ArrayList的容量发生改变时输出 for (int i = 0; i &lt; 10000; i++) { int oldCapacity = getObjArrLength(arrList,&quot;elementData&quot;); arrList.add(1); int newCapacity = getObjArrLength(arrList,&quot;elementData&quot;); if(newCapacity != oldCapacity) System.out.println(newCapacity); } //依次移除ArrayList末尾的9900个元素，剩下100个元素 for(int i = 0; i &lt; 9900; i++){ arrList.remove(arrList.size() - 1); } System.out.println(&quot;Before trimToSize the capacity is &quot; + getObjArrLength(arrList,&quot;elementData&quot;)); arrList.trimToSize();//瘦身 System.out.println(&quot;Ater trimToSize the capacity is &quot; + getObjArrLength(arrList,&quot;elementData&quot;)); } // 通过反射来得到ArrayList的容量，即Object数组的长度 public static int getObjArrLength(Object arrList,String fieldName) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException{ Class c = ((Object)arrList).getClass(); Field f = c.getDeclaredField(fieldName); f.setAccessible(true); Object[] o=(Object[]) f.get(arrList); return o.length; }} 效果如下：","link":"/2017/06/19/从源码看ArrayList的实现/"},{"title":"【Oracle踩坑】远程连接和中文乱码问题","text":"由于很长时间没有用Oracle，在配置时由于疏忽大意遇到了两个典型问题，但是网上给出千篇一律的解决方案似乎都解决不了我的问题。Oracle服务端装在主机中，Oracle客户端在虚拟机中。因此我想的是直接将数据导入主机，然后通过虚拟机连接主机获取数据。 1. 远程连接网上给出的解决方案几乎都只谈到了如何去修改客户端的tnsnames.ora文件以正确连接到服务端，或者是配置PL/SQL的oci.dll文件位置，但我的这此都配置好后还是一直报无法找到监听程序的错误。最后还是通过在服务端的listener.ora添加一行记录来解决，HOST为虚拟网上的IP地址，在虚拟机中能ping通此IP，如下：1234567891011121314151617181920212223242526# listener.ora Network Configuration File: D:\\oracle\\product\\11.2.0\\dbhome_1\\network\\admin\\listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = D:\\oracle\\product\\11.2.0\\dbhome_1) (PROGRAM = extproc) (ENVS = &quot;EXTPROC_DLLS=ONLY:D:\\oracle\\product\\11.2.0\\dbhome_1\\bin\\oraclr11.dll&quot;) ) )LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) ) (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.44.1)(PORT = 1521)) ) )ADR_BASE_LISTENER = D:\\oracle 2.中文乱码由于Oracle对中文的不太友好导致中国用户稍不注意就会遇到乱码的问题，我碰到的是导入的数据中文都以???显示，同样网上查找一番后无非就是配置注册表，添加环境变量，修改Oracle数据库字符集，但是这此都开好后还是没效果。当我新建一张表插入中文竟然可以正常显示，于是删除以前的数据，再进行重新导入就可以解决中文乱码的问题了。原因原来是在最初导入时没有设置好字符集，虽然后面配置好了但还是无法正确显示，因此正确做法是先设置好字符集再导入数据。","link":"/2018/03/06/【Oracle踩坑】远程连接和中文乱码问题/"},{"title":"利用堆实现排序和解决topk问题之Java实现","text":"如下图，将一个数组转化堆，有如下性质 #####所有父节点的值小于或等于两个子节点的值(最小堆) #####如果有左子树，那么左子树的位置是2i+1，如果有右子树，右子树的位置是2i+2 #####只有数组下标小于或等于 【数组长度 / 2 - 1】 的元素有孩子结点 堆排序实现思想： 不断构造堆，交换堆顶与末尾未排序的每一个元素，直到全部都排完。 topK问题实现思想： 创建一个大小为k的数组，对该数组构造堆。遍历数组中剩余的元素，依次与构建好的堆项元素比较，如果满足条件(大于或小于)则替换堆顶元素并重新构造堆。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class HeapDemo { public static void main(String[] args){ //最小堆实现从大到小排序 int[] arrSort = {90,3,60,6,7,2,89,100,33,5}; MinHeap heap1 = new MinHeap(arrSort); for(int i = arrSort.length - 1;i &gt;= 0; i --){ //把最小的元素移到末尾 heap1.swap(0, i); //重新构造最小堆 heap1.buildHeap(i); } //打印排序后的数组 for(int i = 0; i &lt; arrSort.length;i ++){ System.out.println(arrSort[i]); } //最小堆实现topK int[] arrTopK = {90,44,60,6,71,2,38,13,33,5}; int k = 3; //创建一个大小为k的数组 int[] data = new int[k]; for(int i = 0; i &lt; k; i ++){ data[i] = arrTopK[i]; } MinHeap heap = new MinHeap(data); for(int i = k; i &lt; arrTopK.length; i ++){ //如果大于堆顶的元素则替换顶并重新构造 if(arrTopK[i] &gt; heap.getRoot()) heap.setRoot(arrTopK[i]); } //打印最大的k个数 for(int i = 0; i &lt; k; i ++){ System.out.println(data[i]); } }}//最小堆类class MinHeap{ private int[] data; public MinHeap(int[] data){ this.data = data; buildHeap(); } private void buildHeap(){ buildHeap(data.length); } public void buildHeap(int heapSize){ for(int i = heapSize / 2 - 1; i &gt;= 0;i --){ heapify(i,heapSize); } } private void heapify(int index){ heapify(index,data.length); } public void heapify(int index,int heapSize){ int right = right(index); int left = left(index); int min = index; if(right &lt; heapSize &amp;&amp; data[right] &lt; data[min]) min = right; if(left &lt; heapSize &amp;&amp; data[left] &lt; data[min]) min = left; if(min == index) return; swap(index,min); heapify(min,heapSize); } private int right(int index){ //右儿子的下标 return (index + 1) &lt;&lt; 1; } private int left(int index){ //左儿子的下标 return ((index + 1) &lt;&lt; 1) - 1; } public void swap(int index1,int index2){ int tmp = data[index1]; data[index1] = data[index2]; data[index2] = tmp; } public int getRoot(){ return data[0]; } public void setRoot(int root){ data[0] = root; heapify(0); } } 参考文章：http://blog.csdn.net/xiao__gui/article/details/8687982http://blog.csdn.net/kimylrong/article/details/17150475","link":"/2017/08/13/利用堆实现排序和解决topk问题之Java实现/"},{"title":"图解二叉树的三种遍历方式及java实现","text":"二叉树(binary tree)是一颗树，其中每个节点都不能有多于两个的儿子。 1.二叉树节点 作为图的特殊形式，二叉树的基本组成单元是节点与边；作为数据结构，其基本的组成实体是二叉树节点（binary tree node），而边则对应于节点之间的相互引用。 如下，给出了二叉树节点的数据结构图示和相关代码： 123456789101112 // 定义节点类：private static class BinNode { private Object element; private BinNode lChild;// 定义指向左子树的指针 private BinNode rChild;// 定义指向右子树的指针 public BinNode(Object element, BinNode lChild, BinNode rChild) { this.element = element; this.lChild = lChild; this.rChild = rChild; }} 2.递归遍历 二叉树本身并不具有天然的全局次序，故为实现遍历，需通过在各节点与其孩子之间约定某种局部次序，间接地定义某种全局次序。按惯例左兄弟优先于右兄弟，故若将节点及其孩子分别记作V、L和R，则下图所示，局部访问的次序可有VLR、LVR和LRV三种选择。根据节点V在其中的访问次序，三种策略也相应地分别称作先序遍历、中序遍历和后序遍历，下面将分别介绍。 2.1 先序遍历图示：代码实现：1234567891011121314 /** * 对该二叉树进行前序遍历 结果存储到list中 前序遍历 */public static void preOrder(BinNode node) { list.add(node); // 先将根节点存入list // 如果左子树不为空继续往左找，在递归调用方法的时候一直会将子树的根存入list，这就做到了先遍历根节点 if (node.lChild != null) { preOrder(node.lChild); } // 无论走到哪一层，只要当前节点左子树为空，那么就可以在右子树上遍历，保证了根左右的遍历顺序 if (node.rChild != null) { preOrder(node.rChild); }} 2.2 中序遍历图示： 代码实现：123456789101112 /** * 对该二叉树进行中序遍历 结果存储到list中 */public static void inOrder(BinNode node) { if (node.lChild != null) { inOrder(node.lChild); } list.add(node); if (node.rChild != null) { inOrder(node.rChild); }} 2.3 后序遍历实例图示： 代码实现：123456789101112 /** * 对该二叉树进行后序遍历 结果存储到list中 */public static void postOrder(BinNode node) { if (node.lChild != null) { postOrder(node.lChild); } if (node.rChild != null) { postOrder(node.rChild); } list.add(node);} ##附：测试相关代码12345678910111213141516171819202122232425262728293031323334353637 private static BinNode root;private static List&lt;BinNode&gt; list = new ArrayList&lt;BinNode&gt;();public static void main(String[] args) { init(); // TODO Auto-generated method stub //preOrder(root); //inOrder(root); postOrder(root); for (int i = 0; i &lt; list.size(); i++) { System.out.print(list.get(i).element + &quot; &quot;); }}// 树的初始化:先从叶节点开始,由叶到根public static void init() { BinNode b = new BinNode(&quot;b&quot;, null, null); BinNode a = new BinNode(&quot;a&quot;, null, b); BinNode c = new BinNode(&quot;c&quot;, a, null); BinNode e = new BinNode(&quot;e&quot;, null, null); BinNode g = new BinNode(&quot;g&quot;, null, null); BinNode f = new BinNode(&quot;f&quot;, e, g); BinNode h = new BinNode(&quot;h&quot;, f, null); BinNode d = new BinNode(&quot;d&quot;, c, h); BinNode j = new BinNode(&quot;j&quot;, null, null); BinNode k = new BinNode(&quot;k&quot;, j, null); BinNode m = new BinNode(&quot;m&quot;, null, null); BinNode o = new BinNode(&quot;o&quot;, null, null); BinNode p = new BinNode(&quot;p&quot;, o, null); BinNode n = new BinNode(&quot;n&quot;, m, p); BinNode l = new BinNode(&quot;l&quot;, k, n); root = new BinNode(&quot;i&quot;, d, l);}","link":"/2017/07/02/图解二叉树的三种遍历方式及java实现/"},{"title":"在Spring中使用flowable","text":"在上一篇文章(flowable流程引擎初体验，完成一个请假流程)我们使用了命令窗口的方式体验了一把flowable的基本使用，了解了流程定义、部署、启动以及流程之间的流转情况，可以看出来其非常简单方便。在实际项目中我们肯定要将其进行整合，而flowable对Spring也是绝对支持的，本文就是讲解如何在Spring中使用flowable。 1. flowable流程引擎API在上一篇文章中可以看到很多操作都是通过xxService来调用，而这些Services又都是由ProcessEngine产生， ProcessEngine对象通过ProcessEngineConfiguration来配置。所以在使用Spring整合flowable之前，我们必须理清这些关系，如下图所示：主要有一个配置文件，一个配置对象， 一个引擎对象，七大服务。 ####2. Spring中配置flowable首先创建一个典型的Spring项目，引入Spring和flowable相关依赖。然后在spring配置文件中添加扫描包，属性文件以及引入flowable.cfg.xml.如下：12345&lt;context:component-scan base-package=&quot;com.hebaohua.workflow&quot; /&gt;&lt;context:property-placeholder location=&quot;classpath*:properties/*.properties&quot;/&gt;&lt;import resource=&quot;flowable.cfg.xml&quot;/&gt; 在src/main/resources/properties文件夹下创建数据库配置文件db.properties:1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/flowable?useUnicode=true&amp;zeroDateTimeBehavior=convertToNulljdbc.user=rootjdbc.password=123456 在src/main/resources下创建日志配置文件log4j.properties:12345log4j.rootLogger=DEBUG, CAlog4j.appender.CA=org.apache.log4j.ConsoleAppenderlog4j.appender.CA.layout=org.apache.log4j.PatternLayoutlog4j.appender.CA.layout.ConversionPattern= %d{hh:mm:ss,SSS} [%t] %-5p %c %x - %m%n 接下来就是最关键的flowable.cfg.xml了，如下所示:1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;asyncExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.jdbcUrl}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;processEngine&quot; class=&quot;org.flowable.spring.ProcessEngineFactoryBean&quot;&gt; &lt;property name=&quot;processEngineConfiguration&quot; ref=&quot;processEngineConfiguration&quot;/&gt; &lt;/bean&gt; &lt;!-- 7大接口 --&gt; &lt;bean id=&quot;repositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRepositoryService&quot;/&gt; &lt;bean id=&quot;runtimeService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRuntimeService&quot;/&gt; &lt;bean id=&quot;identityService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getIdentityService&quot;/&gt; &lt;bean id=&quot;taskService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getTaskService&quot;/&gt; &lt;bean id=&quot;historyService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getHistoryService&quot;/&gt; &lt;bean id=&quot;managementService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getManagementService&quot;/&gt; &lt;bean id=&quot;identityService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getIdentityService&quot;/&gt; &lt;bean id=&quot;formService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getFormService&quot; /&gt;&lt;/beans&gt; 启动应用就能通过@Autowired注解来进行使用这七大接口了，真是方便。如下用一个测试类来进行一个基本操作的演示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class FlowableTest { @Autowired private RepositoryService repositoryService; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Autowired private HistoryService historyService; @Autowired private ManagementService managementService; /** * 部署流程模型 */ @Test public void testDeploy(){ Deployment deployment = repositoryService.createDeployment() .name(&quot;testDeploy&quot;) .addClasspathResource(&quot;flowable/servicetask-form.bpmn20.xml&quot;) .deploy(); System.out.println(&quot;Deploy successfullly, deployId:&quot; + deployment.getId() + &quot;; deployName:&quot; + deployment.getName()); } /** * 查询流程定义 */ @Test public void queryProcessDefinitionTest(){ ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() .deploymentId(&quot;1&quot;) // 用上一步中的结果 .singleResult(); System.out.println(&quot;Found process definition : &quot; + processDefinition.getName() + &quot;; key:&quot; + processDefinition.getKey() + &quot;;id:&quot; + processDefinition.getId()); } /** * 启动流程 */ @Test public void startProcessInstanceTest(){ Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;employee&quot;, &quot;jack&quot;); variables.put(&quot;nrOfHolidays&quot;, 3); variables.put(&quot;description&quot;, &quot;回家看看&quot;); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;serviceTaskTest&quot;, variables); } /** * 查询并完成任务 */ @Test public void queryAndCompleteTask(){ // 查询 List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&quot;managers&quot;).list(); System.out.println(&quot;You have &quot; + tasks.size() + &quot; tasks:&quot;); for (int i=0; i&lt;tasks.size(); i++) { System.out.println((i+1) + &quot;) &quot; + tasks.get(i).getName()); } // 选择 Task task = tasks.get(1); Map&lt;String, Object&gt; processVariables = taskService.getVariables(task.getId()); System.out.println(processVariables.get(&quot;employee&quot;) + &quot; wants &quot; + processVariables.get(&quot;nrOfHolidays&quot;) + &quot; of holidays. Do you approve this?&quot;); //完成 Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;approved&quot;, true); taskService.complete(task.getId(), variables); } /** * 查询历史数据 */ @Test public void queryHistoryData(){ List&lt;HistoricActivityInstance&gt; activities = historyService.createHistoricActivityInstanceQuery().processInstanceId(&quot;4&quot;) .orderByHistoricActivityInstanceEndTime().asc() .list(); for (HistoricActivityInstance activity : activities) { System.out.println(activity.getActivityId() + &quot; took &quot; + activity.getDurationInMillis() + &quot; milliseconds&quot;); System.out.println(&quot;======================================&quot;); } }}","link":"/2018/08/25/在Spring中使用flowable/"},{"title":"基于K-means聚类算法对相关数据进行分析","text":"k-means算法以k为参数，把n个对象分成k个簇，使簇内具有较高的相似度，而簇间的相似度较低。本文主要基于此算法对下图2006年各地区城镇居民家庭平均每人全年消费性支出进行分析，以了解各地消费层级的划分 实现代码如下：1234567891011121314151617181920212223242526import numpy as npfrom sklearn.cluster import KMeansimport openpyxl def loadData(filePath): wb = openpyxl.load_workbook(filePath) sh = wb.get_sheet_by_name(&apos;Sheet1&apos;) retData = [] retCityName = [] for i in range(5, sh.max_row + 1): retCityName.append(sh.cell(row=i, column=1).value) retData.append([float(sh.cell(row=i, column=j).value) for j in range(2,sh.max_column + 1)]) return retData,retCityName if __name__ == &apos;__main__&apos;: data,cityName = loadData(&apos;city.xlsx&apos;) km = KMeans(n_clusters=4) label = km.fit_predict(data) expenses = np.sum(km.cluster_centers_,axis=1) #print(expenses) CityCluster = [[],[],[],[]] for i in range(len(cityName)): CityCluster[label[i]].append(cityName[i]) for i in range(len(CityCluster)): print(&quot;Expenses:%.2f&quot; % expenses[i]) print(CityCluster[i]) 首先通过openpyxl类库来读取Excel中的文件，将城市名称和其它数据分别存入一个一维数据和二维数组中，然后调用KMeans方法，设置n_clusters参数，即分类个数，对数据时行训练，获得标签，最后对标签进行输出。输出结果即将城市按照消费水平n_clusters类，消费水平相近的城市聚集在一类中。其中expense为聚类中心点的数值加和，也就是平均消费水平。当n_clusters=2时：1234Expenses:7595.47[&apos; 天 津&apos;, &apos; 河 北&apos;, &apos; 山 西&apos;, &apos; 内蒙古&apos;, &apos; 辽 宁&apos;, &apos; 吉 林&apos;, &apos; 黑龙江&apos;, &apos; 江 苏&apos;, &apos; 安 徽&apos;, &apos; 福 建&apos;, &apos; 江 西&apos;, &apos; 山 东&apos;, &apos; 河 南&apos;, &apos; 湖 北&apos;, &apos; 湖 南&apos;, &apos; 广 西&apos;, &apos; 海 南&apos;, &apos; 重 庆&apos;, &apos; 四 川&apos;, &apos; 贵 州&apos;, &apos; 云 南&apos;, &apos; 西 藏&apos;, &apos; 陕 西&apos;, &apos; 甘 肃&apos;, &apos; 青 海&apos;, &apos; 宁 夏&apos;, &apos; 新 疆&apos;]Expenses:13841.98[&apos; 北 京&apos;, &apos; 上 海&apos;, &apos; 浙 江&apos;, &apos; 广 东&apos;] 当n_clusters=3时：123456Expenses:7204.11[&apos; 河 北&apos;, &apos; 山 西&apos;, &apos; 内蒙古&apos;, &apos; 辽 宁&apos;, &apos; 吉 林&apos;, &apos; 黑龙江&apos;, &apos; 安 徽&apos;, &apos; 江 西&apos;, &apos; 山 东&apos;, &apos; 河 南&apos;, &apos; 湖 北&apos;, &apos; 湖 南&apos;, &apos; 广 西&apos;, &apos; 海 南&apos;, &apos; 四 川&apos;, &apos; 贵 州&apos;, &apos; 云 南&apos;, &apos; 西 藏&apos;, &apos; 陕 西&apos;, &apos; 甘 肃&apos;, &apos; 青 海&apos;, &apos; 宁 夏&apos;, &apos; 新 疆&apos;]Expenses:13841.98[&apos; 北 京&apos;, &apos; 上 海&apos;, &apos; 浙 江&apos;, &apos; 广 东&apos;]Expenses:9845.76[&apos; 天 津&apos;, &apos; 江 苏&apos;, &apos; 福 建&apos;, &apos; 重 庆&apos;] 当n_clusters=4时：12345678Expenses:7214.42[&apos; 辽 宁&apos;, &apos; 安 徽&apos;, &apos; 江 西&apos;, &apos; 湖 北&apos;, &apos; 湖 南&apos;, &apos; 广 西&apos;, &apos; 海 南&apos;, &apos; 四 川&apos;, &apos; 贵 州&apos;, &apos; 云 南&apos;, &apos; 西 藏&apos;]Expenses:13841.98[&apos; 北 京&apos;, &apos; 上 海&apos;, &apos; 浙 江&apos;, &apos; 广 东&apos;]Expenses:9845.76[&apos; 天 津&apos;, &apos; 江 苏&apos;, &apos; 福 建&apos;, &apos; 重 庆&apos;]Expenses:7194.66[&apos; 河 北&apos;, &apos; 山 西&apos;, &apos; 内蒙古&apos;, &apos; 吉 林&apos;, &apos; 黑龙江&apos;, &apos; 山 东&apos;, &apos; 河 南&apos;, &apos; 陕 西&apos;, &apos; 甘 肃&apos;, &apos; 青 海&apos;, &apos; 宁 夏&apos;, &apos; 新 疆&apos;] 当n_clusters=5时：12345678910Expenses:9845.76[&apos; 天 津&apos;, &apos; 江 苏&apos;, &apos; 福 建&apos;, &apos; 重 庆&apos;]Expenses:7130.70[&apos; 河 北&apos;, &apos; 山 西&apos;, &apos; 内蒙古&apos;, &apos; 吉 林&apos;, &apos; 黑龙江&apos;, &apos; 江 西&apos;, &apos; 山 东&apos;, &apos; 河 南&apos;, &apos; 贵 州&apos;, &apos; 陕 西&apos;, &apos; 甘 肃&apos;, &apos; 青 海&apos;, &apos; 宁 夏&apos;, &apos; 新 疆&apos;]Expenses:12890.38[&apos; 浙 江&apos;, &apos; 广 东&apos;]Expenses:7318.30[&apos; 辽 宁&apos;, &apos; 安 徽&apos;, &apos; 湖 北&apos;, &apos; 湖 南&apos;, &apos; 广 西&apos;, &apos; 海 南&apos;, &apos; 四 川&apos;, &apos; 云 南&apos;, &apos; 西 藏&apos;]Expenses:14793.59[&apos; 北 京&apos;, &apos; 上 海&apos;] 从结果可以看出消费水平相近的省市聚集在了一类，例如聚4类时,消费最高的’ 北 京’, ‘ 上 海’, ‘ 浙 江’, ‘ 广 东’聚集在了消费最高的类别，结果可以比较明显的看出消费层级。","link":"/2017/12/06/基于K-means聚类算法对相关数据进行分析/"},{"title":"将本地工程上传到Github进行版本控制","text":"在Github上创建Repository并复制HTTPS链接 初始化本地文件夹，即将文件夹添加给git管理 将文件添加到仓库，注意不要漏了add与.之间的空格 提交添加的文件 连接远程Github，后面链接即为和1步复制的HTTPS链接 上传项目，此命令需输入Github的帐号密码 经过这简单的几步就成功将一个本地项目交给git管理并上传到github进行版本控制。","link":"/2017/12/16/将本地工程上传到Github进行版本控制/"},{"title":"手把手教你用frp实现内网穿透，进行远程桌面和http访问","text":"使用frp内网穿透工具使处于内网中的电脑能够像访问公网电脑一样方便，比如将公司或个人电脑里面的web项目让别人能够访问以便于自己及时修改，或者是进行远程或ssh连接。能够实现内网穿透的还有花生壳，ngrok等，但frp使用起来更加简便灵活，以及项目一直开源，所以本文选择frp作为示例。官方(项目地址)介绍为： frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 数据准备： 公网IP: X.X.X.X 内网IP: 192.168.1.101 映射到公网的域名：xxx.com 本文中内网电脑使用的是win7系统，公网电脑为linux系统。 1. 服务端配置1.1 文件下载具有公网IP的电脑将作为frp服务端(frps)，首先去项目地址的releases页面下载与服务端系统匹配的文件并解压，并且可以删除客户端相关的文件(frpc文件夹，frpc.ini,frpc_full.ini). 1.2 编辑配置文件编辑frps.ini为以下内容：123[common]bind_port = 7000vhost_http_port = 8080 bind_port为客户端与服务端进行通信的端口，vhost_http_port为服务端http服务的端口。其它更丰富的配置可参考frps_full.ini和项目帮助文档。 1.3 启动服务端进行到解压后的frp目录，然后通过./frps -c frps.ini命令即可启动服务端，如下图所示： 1.4 设置开机启动和后台运行上一步中的frps占据了整个命令窗口，所以接下来要考虑如何让它在后台运行并且开机自启：首先通过vi /etc/systemd/system/frps.service命令新建文件并写入以下内容:12345678910111213[Unit]Description=frps daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/usr/frp/frp_0.16.0_linux_386/frps -c /usr/frp/frp_0.16.0_linux_386/frps.iniRestart= alwaysRestartSec=1min[Install]WantedBy=multi-user.target 注意ExecStart中要配置成自己的路径.然后使用systemctl start frps即可启动frps, 用systemctl enable frps即可将frps设置为开机启动。 2. 客户端配置2.1 文件下载具有内网IP的电脑将作为客户端(frpc)， 本文中客户端使用的是win7 64位系统，所以在releases页面下载frp_0.16.0_windows_amd64.zip解压，删除与服务端相关的文件（frps文件夹，frps.ini,frps_full.ini) 2.2 编辑配置文件编辑frpc.ini为以下内容：1234567891011121314[common]server_addr = X.X.X.Xserver_port = 7000[RDP]type = tcplocal_ip = 0.0.0.0local_port = 3389remote_port = 6000[web]type = httplocal_port = 8080custom_domains = xxx.com 注意sever_addr配置为公网电脑的IP，server_port与frps.ini中的bind_port一致。RDP为远程桌面的配置，web为http通信的配置。web中的custom_domains为绑定到公网IP的域名。 2.3 启动服务端双击frpc.exe或者用命令 frpc -c frpc.ini即可启动客户端，如下图所示：随后我们就可以在服务端的命令窗口看到客户端的连接信息，如下所示： 2.4 设置开机启动和后台运行同样的道理，我们也需要对客户端设置后台运行和开机自启。借助 winsw 工具可以将frpc注册为windows系统中的服务。下载winsw最新版，为了方便将其重命名为winsw.exe, 将该文件和frpc.exe放在一起，然后新建winsw.xml写入以下内容：12345678&lt;service&gt; &lt;id&gt;frp&lt;/id&gt; &lt;name&gt;frp&lt;/name&gt; &lt;description&gt;用frp发布本地电脑网站到外网&lt;/description&gt; &lt;executable&gt;frpc&lt;/executable&gt; &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt; &lt;logmode&gt;reset&lt;/logmode&gt;&lt;/service&gt; 然后使用winsw install和frpc start命令即可将frpc安装为系统服务。win+r后通过services.msc进入到服务列表页面找到frp服务。 为了确保frpc在连接失败后自动尝试重新连接，在恢复tap页进行如下设置： 3. 效果演示3.1 远程桌面首先要开启桌面远程连接，配置如下 在随意一台其它电脑上使用win+r然后 mstsc进入远程桌面连接使用通过域名或外网IP加端口即可成功进行远程桌面连接到内网中的机器。 3.2 http远程访问在客户端本地启动一个web项目后，然后随意一台电脑上使用域名加端口即可访问内网中的web项目。 问题记录 检查是否关闭服务端防火墙或者是开启要用到的端口 域名映射是否正确，检查能不能ping得通域名(域名前面不要忘了www)","link":"/2018/02/07/手把手教你用frp实现内网穿透，进行远程桌面和http访问/"},{"title":"爬取简书文章到个人mysql数据库","text":"为了将自己在简书上发表的历史文章放到个人网站以及以后两者更新的同步，初略写了下爬虫过程。主要利用bs4库，requests库和mysql驱动，实现根据个人ID爬取文章列表，爬取单个文章的标题内容，处理img标签的兼容性，将爬取的结果写入或更新到mysql数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import requ&lt;!-- more --&gt;estsfrom bs4 import BeautifulSoupimport MySQLdbimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def crawlArticleByUrl(url): html = getHTMLText(url) soup = BeautifulSoup(html, &quot;html.parser&quot;) article = soup.find_all(&apos;div&apos;, class_=&quot;article&quot;)[0] title = article(&apos;h1&apos;, class_=&quot;title&quot;)[0].string print(title) content = article(&apos;div&apos;, class_=&quot;show-content&quot;)[0] # 解决img标签的问题 imgs = content(&apos;div&apos;,class_=&quot;image-package&quot;) strContent = str(content) for img in imgs: imgUrl = &apos;http:&apos; + img(&apos;img&apos;)[0].attrs[&apos;data-original-src&apos;] caption = str(img(&apos;div&apos;,class_=&apos;image-caption&apos;)[0].string) new =&apos;&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&apos; + imgUrl + &apos;&gt;&apos; if caption != &apos;None&apos;: new = new + &apos;&lt;div class=&quot;image-caption&quot;&gt;&apos; + str(caption) + &apos;&lt;/div&gt;&apos; new = new + &apos;&lt;/div&gt;&apos; strContent = strContent.replace(str(img),new) return title, strContent[48:-7]def writeIntoDB(title, content): DBKWARGS = {&apos;db&apos;:&apos;myblog&apos;,&apos;user&apos;:&apos;root&apos;,&apos;passwd&apos;:&apos;root&apos;, &apos;host&apos;:&apos;localhost&apos;,&apos;use_unicode&apos;:True,&apos;charset&apos;:&apos;utf8&apos;} con = MySQLdb.connect(**DBKWARGS) cur = con.cursor() sql = &quot;insert into article(article_title,article_content) values(%s,%s)&quot; lis = (title, content) try: cur.execute(sql, lis) except Exception as e: print(&quot;Insert Error:&quot;, e) con.rollback() else: con.commit() cur.close() con.close()def updateArticleById(title, content,id): DBKWARGS = {&apos;db&apos;:&apos;myblog&apos;,&apos;user&apos;:&apos;root&apos;,&apos;passwd&apos;:&apos;root&apos;, &apos;host&apos;:&apos;localhost&apos;,&apos;use_unicode&apos;:True,&apos;charset&apos;:&apos;utf8&apos;} con = MySQLdb.connect(**DBKWARGS) cur = con.cursor() sql = &quot;update article set article_title = %s, article_content = %s where article_id = %s;&quot; lis = (title, content, id) try: cur.execute(sql, lis) except Exception as e: print(&quot;Insert Error:&quot;, e) con.rollback() else: con.commit() cur.close() con.close()def GetArticleList(userId): url = &quot;http://www.jianshu.com/u/&quot; + userId html = getHTMLText(url) soup = BeautifulSoup(html, &quot;html.parser&quot;) num = int(soup.find_all(&apos;div&apos;, class_=&quot;meta-block&quot;)[2](&apos;p&apos;)[0].string) #获取文章总数 page = int(num / 9) + 1 #获取页数 for i in range(page): newUrl = url + &quot;?order_by=shared_at&amp;page=&quot; + str(page - i) newHtml = getHTMLText(newUrl) newSoup = BeautifulSoup(newHtml,&quot;html.parser&quot;) ul = newSoup.find_all(&apos;ul&apos;, class_=&quot;note-list&quot;)[0] lis = [] # 倒序输出 for li in ul.children: if isinstance(li,bs4.element.Tag): lis.append(li) for li in lis[::-1]: articleUrl = &quot;http://www.jianshu.com&quot; + (li(&quot;a&quot;, class_=&quot;title&quot;)[0].attrs[&apos;href&apos;]) title, content = crawlArticleByUrl(articleUrl) writeIntoDB(title, content)def main(): #GetArticleList(&quot;9f29e0217f4d&quot;) title, content = crawlArticleByUrl(&apos;https://www.jianshu.com/p/326d5e75fa2d&apos;) #writeIntoDB(title, content) updateArticleById(title, content, 513) print(&quot;Finish!&quot;)if __name__ == &apos;__main__&apos;: main()","link":"/2018/01/04/爬取简书文章到个人mysql数据库/"},{"title":"爬取链家武汉二手房数据并进行回归分析","text":"本文先对链家网最新的武汉二手房数据进行爬取，提取房价面积和平米单价并以逗号分割存储在txt文件中，最后对数据分别进行线性回归和多项式回归，并以绘制相关图查看效果。 1. 数据爬取1234567891011121314151617181920212223242526272829303132333435363738394041import requestsfrom bs4 import BeautifulSoupimpor&lt;!-- more --&gt;t bs4import osdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def getAreaPrice(url,path): html = getHTMLText(url) soup = BeautifulSoup(html, &apos;html.parser&apos;) try: ul = soup.find_all(&apos;ul&apos;, class_=&quot;sellListContent&quot;)[0] with open(path,&quot;a&quot;) as f: for li in ul.children: try: if isinstance(li, bs4.element.Tag): area = li(&apos;div&apos;, class_=&quot;houseInfo&quot;)[0].text.split(&apos;|&apos;)[2][:-3] price = li(&apos;div&apos;, class_=&quot;unitPrice&quot;)[0].string[2:-4] f.write(str(float(area)).strip() + &quot;,&quot; + str(int(price)) + &quot;\\n&quot;) except: continue except: passif __name__ == &apos;__main__&apos;: list = [] path = &quot;prices.txt&quot; if os.path.exists(path): os.remove(path) pageNum = 97 for i in range(pageNum): url = &quot;https://wh.lianjia.com/ershoufang/pg&quot; + str(i) print(&quot;\\r房价数据正在下载,当前进度: {:.2f}%&quot;.format((i +1) * 100 / pageNum), end=&quot;&quot;) getAreaPrice(url,path) 2. 回归分析12345678910111213141516171819202122232425262728293031323334353637383940import matplotlib.pyplot as pltimport numpy as npfrom sklearn import linear_modelfrom sklearn.preprocessing import PolynomialFeatures datasets_X = []datasets_Y = []fr = open(&apos;prices.txt&apos;,&apos;r&apos;,encoding= &apos;utf-8&apos;)lines = fr.readlines()for line in lines: items = line.strip().split(&apos;,&apos;) datasets_X.append(float(items[0])) datasets_Y.append(int(items[1])) length = len(datasets_X)datasets_X = np.array(datasets_X).reshape([length,1])datasets_Y = np.array(datasets_Y) minX = min(datasets_X)maxX = max(datasets_X)X = np.arange(minX,maxX).reshape([-1,1])# 线性回归linear = linear_model.LinearRegression()linear.fit(datasets_X, datasets_Y)# 多项式回归poly_reg = PolynomialFeatures(degree = 4)X_poly = poly_reg.fit_transform(datasets_X)lin_reg_2 = linear_model.LinearRegression()lin_reg_2.fit(X_poly, datasets_Y)# 绘图plt.figure(figsize=(12,7)) #设置图片大小plt.scatter(datasets_X, datasets_Y, color = &apos;green&apos;,marker=&apos;.&apos;)plt.plot(X, linear.predict(X), color = &apos;red&apos;)plt.plot(X, lin_reg_2.predict(poly_reg.fit_transform(X)), color = &apos;blue&apos;)plt.xlabel(&apos;Area&apos;)plt.ylabel(&apos;Price&apos;)plt.show() 结论：如上图所示，绿色点为样本散点，红色直线是线性回归结果，蓝色曲线是多项式回归结果，很直观的表明多项式曲线拟合得更好，从图中可以看出大多数二手房面积在80-110平米之间，同时该区间房价基本是最低的，小户型房价略有提升，随着户型增大，房价上升趋势比较明显。","link":"/2017/12/08/爬取链家武汉二手房数据并进行回归分析/"},{"title":"股票数据的爬取及趋势预测","text":"本文首先在东方财富网上爬取当前上海股票和深圳股票的所有股票代码，然后利用网易股票上的接口拉取每支股票从上市以来的历史成交数据，最后通过某一支股票的历史交易数据采用svm分类算法，对数据进行训练，进行涨跌趋势预测。 1. 爬取所有股票代码 如下图所示，通过查看页面源码可以发现a标签下的href属性结尾都是以sh|z + 股票代码 + .html形式结尾，所以通过正则表达式和requests库很容易爬取到所有股票列表。 12345678910111213141516171819def getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &quot;&quot;def getStockList(lst, stockURL): html = getHTMLText(stockURL) soup = BeautifulSoup(html, &apos;html.parser&apos;) a = soup.find_all(&apos;a&apos;) for i in a: try: href = i.attrs[&apos;href&apos;] lst.append((re.findall(r&quot;[s][hz]\\d{6}&quot;, href)[0])[2:]) except: continue 2. 下载股票历史交易数据2.1 得到当前股票上市日期 如下股票上市日期的信息在class=”table_bg001 border_box limit_sale table_details” 的table标签下，此处可以通过BeautifulSoup模块find_all函数来进行定位。 1234567891011121314151617def getStockStartDate(stockCode): html = getHTMLText(&quot;http://quotes.money.163.com/f10/gszl_&quot; + stockCode + &quot;.html#01f02&quot;) soup = BeautifulSoup(html, &apos;html.parser&apos;) try: a = soup.find_all(&apos;table&apos;, class_=&quot;table_bg001 border_box limit_sale table_details&quot;)[1] except: return time.strftime(&quot;%Y%m%d&quot;) cnt = 0; date = &quot;&quot; for tr in a.children: if isinstance(tr, bs4.element.Tag): tds = tr(&apos;td&apos;) cnt = cnt + 1 if(cnt ==2): date = tds[1].string.replace(&quot;-&quot;,&quot;&quot;) break; return date 2.2 下载从上市日期到今天的交易数据 下载数据就比较简单了，直接通过网易股票接口，然后以股票代码命名在csv文件格式进行存储。1234567def getHistoryTradeInfo(stockCode): download_url = &quot;http://quotes.money.163.com/service/chddata.html?code=0&quot; + stockCode + &quot;&amp;start=&quot; + getStockStartDate(stockCode) + &quot;&amp;end=&quot; + time.strftime(&quot;%Y%m%d&quot;) + &quot;&amp;fields=TCLOSE;HIGH;LOW;TOPEN;LCLOSE;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER;TCAP;MCAP&quot; data = requests.get(download_url) f = open(&apos;histotry/&apos; + stockCode + &apos;.csv&apos;, &apos;wb&apos;) for chunk in data.iter_content(chunk_size=10000): if chunk: f.write(chunk) 3. 趋势预测 通过上面的步骤已经顺利拿到了所有上市和深市自上市以来的交易数据，下面就是最关键的趋势预测了。本部分以600196为例，查看csv文件可以看到该股票已有四千多个交易日，我们可以选取前150个交易日的开盘价，收盘价，最高价，最低价以及成交量和当天开盘价作为影响股票当天涨跌的751个特征，然后利用已有数据进行80%作为训练，20%作为测试，进行交叉验证。12345678910111213141516171819202122232425262728293031import pandas as pdimport numpy as npfrom sklearn import svmfrom sklearn.model_selection import train_test_splitdata=pd.read_csv(&apos;600196.csv&apos;,encoding=&apos;gbk&apos;,parse_dates=[0],index_col=0)data.sort_index(0,ascending=True,inplace=True) dayfeature=150featurenum=5*dayfeaturex=np.zeros((data.shape[0]-dayfeature,featurenum+1))y=np.zeros((data.shape[0]-dayfeature)) for i in range(0,data.shape[0]-dayfeature): x[i,0:featurenum]=np.array(data[i:i+dayfeature] \\ [[u&apos;收盘价&apos;,u&apos;最高价&apos;,u&apos;最低价&apos;,u&apos;开盘价&apos;,u&apos;成交量&apos;]]).reshape((1,featurenum)) x[i,featurenum]=data.ix[i+dayfeature][u&apos;开盘价&apos;] for i in range(0,data.shape[0]-dayfeature): if data.ix[i+dayfeature][u&apos;收盘价&apos;]&gt;=data.ix[i+dayfeature][u&apos;开盘价&apos;]: y[i]=1 else: y[i]=0 clf=svm.SVC(kernel=&apos;sigmoid&apos;) # ‘linear’‘poly’‘sigmoid’ &apos;rbf&apos;result = []for i in range(5): x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2) clf.fit(x_train, y_train) result.append(np.mean(y_test == clf.predict(x_test)))print(&quot;svm classifier accuacy:&quot;)print(result) 本次实验运用了三个核函数做实验，准确率如上力数据所示。5次交叉验证的准确率相近，均为53%左右。","link":"/2017/12/08/股票数据的爬取及趋势预测/"},{"title":"计算机网络之概述(上）","text":"","link":"/2017/06/28/计算机网络之概述(上）/"},{"title":"解决win下SSH Secure Shell无法远程登录ubuntu的问题","text":"如下图所示，准备在ubuntu中部署javaweb项目，但是在windows准备用SSH Secure Shell远程登录时提示客户端与服务器端采用的压缩算法不同，经过文中五步解决问题。 #####1. 安装ssh服务1sudo apt-get install openssh-server #####2.启动ssh服务1sudo ps -e |grep ssh 有sshd,说明ssh服务已经启动，如果没有启动，输入:1sudo service ssh start #####3. 打开ssh配置文件1sudo vi /etc/ssh/sshd_config #####4. 修改配置文件允许root用户登录，将”PermitRootLogin without-password”更改为“PermitRootLogin yes”然后在配置文件末尾添加：123Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96 KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org #####5. 重启ssh服务1sudo /etc/init.d/ssh restart","link":"/2017/11/11/解决win下SSH Secure Shell无法远程登录ubuntu的问题/"},{"title":"记一次不太成功的频繁full gc排查过程","text":"上周自己负责的一个应用出现频繁full gc的问题，不得不尝试优化一下。第一次做这种事只能先看看网上的文章，然后亲自尝试怎么去完成减少full gc的频率，降低young gc的频率这一目标。虽然最终只是勉强解决了，但还是希望记录下来给下一次积攒经验。 先给出前后对比图，选取了上周优化前后的两个典型工作日上午9:00到晚上9:00的GC情况。从前两张图可以看出一天要发生高达上10次的full gc，young gc也非常频繁。第三张优化后的图已经没有出现full gc，young gc的频率也大大降低了，所以说基本完成目标。 接下来说明排查过程 #####1.jps命令查看进程idjps是java后自带的查看虚拟机进程状态命令工具，用如下命令就可以看到虚拟机执行主类和进程ID.jps -l #####2. jmap命令导出堆转储文件jmap是java自带的内存映像工具，能将当前应用运行内存的情况导出为文件。注意格式，file后面是导出路径，最后的数字为上一步得到的进程id。一般导出来的文件都比较大，我导出的有2.1G，而且进行分析也很耗性能，所以导出后都要传输到其它机器上进行分析，并且为了避免占用磁盘空间删除本地文件。jmap -dump:format=b,file=kfwebHeap1016.hprof 35073 #####3.mat工具分析堆转储文件mat是eclipse提供的堆转储文件分析工具，用mat打开mat上一步导出的文件，如下图所示，可以看到总体内存占用情况的扇形图，哪个文件占用内存最多就可以一目了然了。 点击histogram就可以看出各个对象的内存占用情况，如下所示 点击Leak Suspects就可以给出最有可能发生内存泄漏的几种情况。能很好的帮助用户进行内存分析，这也是mat强大的重要体现，如下：到这里应该是最关键的环节了，可能因为没有经验，看来看去也没看出哪里不对，所以只能作罢，这条路已经走不下去了，所以说这次分析不太成功。 #####4.G1来了后来向一个老同事说明了我的情况，他问我用的什么垃圾回收器，我说用的是默认的，年经代用Parallel Scavenge，老年代用Parallel Old，他说让我先换到G1试试吧。然后我查了一下，发现G1果然比较牛逼，虽然保留了以前的新生代Eden，Survivor和老年代的概念，但新生代和老年代不再物理隔离，而且它将内存分为很多等大的region，每个region根据需要都有可能成为S(Surviror),E(Eden), O(Old)的一种，所以G1既能回收新生代也能回收老年代，它以垃圾回收为第一（这也是它名字的由来:Garbage First，G1）目标，励志于取决CMS, 并且在java9是已经是jdk默认的垃圾回收器了。说了这么多，暂时没有多时间深入研究，不管怎么样还是值得一试的。于是在应用的jvm启动参数加了如下一行:-XX:+UseG1GC当然只是在一台机器上作了处理，也便于与其它机器作对比。 #####5.MetaSpace调整通过调整后的这台机器与其它机器对比，gc情况还是改善了不少，但是在查看gc日志时发现了这么这个频繁出现的问题：Metadata GC Threshold由于元数据空间不足导致的GC.原来在G1中设置PermSize(永久代大小)已经没用了，取而代之的是MetaSpace参数，虽然这个用的是并非堆内存而是机器的物理内存并且最大大小没有限制，但是默认初始大小只有20m，所以要作出调整：-XX:MetaspaceSize=128m加了之后果然就没有出现这个问题了 #####6. 解决Humongous Allocation在gc日志中还发现频繁出现：G1 Humongous Allocation这个是由于大型对象分配导致的问题，大型(Humongous)对象是指超过G1的Region 50%的内存对象，频繁大型对象内存内存分配会导致性能问题，而且如果一个region中大型对象过多的话则最后一个大型对内象边界和该region的边界之间的空间将不会被使用，如果有多个这样的region将会导致堆内存的碎片化，在jdk1.8u40之前这些大型对象的清理在full gc期间进行完成。较新的jvm也是把大型对象放在清理阶段，要解决上面的问题有两种方法。1.增加region的大小(注意要在1到32m之间并且为2的整数次幂)2.增加堆内存大小 总结：其实这一次只是引进了G1垃圾回收器并且对相关参数进行调整，但是促使我去了解jvm相关的知识和工具使用，还是有很很大收获的。","link":"/2018/10/21/记一次不太成功的频繁full gc排查过程/"},{"title":"详解BFS和DFS及Java实现","text":"1.图的表示 图是由顶点和边组成，图最常用的两种方法就是邻接表和邻接矩阵。这两种办法分别用表和矩阵的方式描述图中各顶点之间的联系。 下面分别展示了两种表示上面这个图的方法： 2.图的遍历 广度优先遍历和深度优先遍历是遍历图的两种最常用的方法，下面将详细进行介绍。 2.1 广度优先遍历(BFS) 即Breadth First Search，其主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列（FIFO）中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对A再加1，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问），而对于连通图来说，每个顶点都会被访问。加上每个顶点的邻接链表都会被遍历，因此BFS的时间复杂度是Θ（V+E），其中V是顶点个数，E是边数，也就是所有邻接表中的元素个数。为了更好的说明这个过程，下图列出了对一个图的BFS的过程。 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.HashMap;import java.util.LinkedList;import java.util.Queue;public class BFSDemo { public static void main(String[] args) { //构造各顶点 LinkedList&lt;Character&gt; list_s = new LinkedList&lt;Character&gt;(); list_s.add(&apos;w&apos;); list_s.add(&apos;r&apos;); LinkedList&lt;Character&gt; list_w = new LinkedList&lt;Character&gt;(); list_w.add(&apos;s&apos;); list_w.add(&apos;i&apos;); list_w.add(&apos;x&apos;); LinkedList&lt;Character&gt; list_r = new LinkedList&lt;Character&gt;(); list_r.add(&apos;s&apos;); list_r.add(&apos;v&apos;); LinkedList&lt;Character&gt; list_x = new LinkedList&lt;Character&gt;(); list_x.add(&apos;w&apos;); list_x.add(&apos;i&apos;); list_x.add(&apos;u&apos;); list_x.add(&apos;y&apos;); LinkedList&lt;Character&gt; list_v = new LinkedList&lt;Character&gt;(); list_v.add(&apos;r&apos;); LinkedList&lt;Character&gt; list_i = new LinkedList&lt;Character&gt;(); list_i.add(&apos;u&apos;); list_i.add(&apos;x&apos;); list_i.add(&apos;w&apos;); LinkedList&lt;Character&gt; list_u = new LinkedList&lt;Character&gt;(); list_u.add(&apos;i&apos;); list_u.add(&apos;x&apos;); list_u.add(&apos;y&apos;); LinkedList&lt;Character&gt; list_y = new LinkedList&lt;Character&gt;(); list_y.add(&apos;u&apos;); list_y.add(&apos;x&apos;); //构造图 HashMap&lt;Character, LinkedList&lt;Character&gt;&gt; graph = new HashMap&lt;Character, LinkedList&lt;Character&gt;&gt;(); graph.put(&apos;s&apos;, list_s); graph.put(&apos;w&apos;, list_w); graph.put(&apos;r&apos;, list_r); graph.put(&apos;x&apos;, list_x); graph.put(&apos;v&apos;, list_v); graph.put(&apos;i&apos;, list_i); graph.put(&apos;y&apos;, list_y); graph.put(&apos;u&apos;, list_u); //记录每个顶点离起始点的距离，也即最短距离 HashMap&lt;Character, Integer&gt; dist = new HashMap&lt;Character, Integer&gt;(); //遍历的起始点 char start = &apos;s&apos;; //调用广度优先方法 bfs(graph, dist, start); } private static void bfs(HashMap&lt;Character, LinkedList&lt;Character&gt;&gt; graph, HashMap&lt;Character, Integer&gt; dist, char start) { Queue&lt;Character&gt; q = new LinkedList&lt;&gt;(); q.add(start);// 将s作为起始顶点加入队列 dist.put(start, 0); int i = 0; while (!q.isEmpty()) { char top = q.poll();// 取出队首元素 i++; System.out.println(&quot;The &quot; + i + &quot;th element:&quot; + top + &quot; Distance from s is:&quot; + dist.get(top)); int d = dist.get(top) + 1;// 得出其周边还未被访问的节点的距离 for (Character c : graph.get(top)) { if (!dist.containsKey(c))// 如果dist中还没有该元素说明还没有被访问 { dist.put(c, d); q.add(c); } } } }} 运行结果：12345678The 1th element:s Distance from s is:0The 2th element:w Distance from s is:1The 3th element:r Distance from s is:1The 4th element:i Distance from s is:2The 5th element:x Distance from s is:2The 6th element:v Distance from s is:2The 7th element:u Distance from s is:3The 8th element:y Distance from s is:3 2.2 深度优先遍历(DFS) 即Depth First Search,深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。具体看下图： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.HashMap;import java.util.LinkedList;public class DFSDemo { public static void main(String[] args) { //构造各顶点 LinkedList&lt;Character&gt; list_u = new LinkedList&lt;Character&gt;(); list_u.add(&apos;v&apos;); list_u.add(&apos;x&apos;); LinkedList&lt;Character&gt; list_v = new LinkedList&lt;Character&gt;(); list_v.add(&apos;y&apos;); LinkedList&lt;Character&gt; list_y = new LinkedList&lt;Character&gt;(); list_y.add(&apos;x&apos;); LinkedList&lt;Character&gt; list_x = new LinkedList&lt;Character&gt;(); list_x.add(&apos;v&apos;); LinkedList&lt;Character&gt; list_w = new LinkedList&lt;Character&gt;(); list_w.add(&apos;y&apos;); list_w.add(&apos;z&apos;); LinkedList&lt;Character&gt; list_z = new LinkedList&lt;Character&gt;(); //构造图 HashMap&lt;Character, LinkedList&lt;Character&gt;&gt; graph = new HashMap&lt;Character, LinkedList&lt;Character&gt;&gt;(); graph.put(&apos;u&apos;, list_u); graph.put(&apos;v&apos;, list_v); graph.put(&apos;y&apos;, list_y); graph.put(&apos;x&apos;, list_x); graph.put(&apos;w&apos;, list_w); graph.put(&apos;z&apos;, list_z); HashMap&lt;Character, Boolean&gt; visited = new HashMap&lt;Character, Boolean&gt;(); //调用深度优先遍历方法 dfs(graph, visited); } private static void dfs(HashMap&lt;Character, LinkedList&lt;Character&gt;&gt; graph, HashMap&lt;Character, Boolean&gt; visited) { visit(graph, visited, &apos;u&apos;);// 为了和图中的顺序一样，我认为控制了DFS先访问u节点 visit(graph, visited, &apos;w&apos;); } //通过一个全局变量count记录了进入每个节点和离开每个节点的时间 static int count; private static void visit(HashMap&lt;Character, LinkedList&lt;Character&gt;&gt; graph, HashMap&lt;Character, Boolean&gt; visited, char start) { if (!visited.containsKey(start)) { count++; System.out.println(&quot;The time into element &quot; + start + &quot;:&quot; + count);// 记录进入该节点的时间 visited.put(start, true); for (char c : graph.get(start)) { if (!visited.containsKey(c)) { visit(graph, visited, c);// 递归访问其邻近节点 } } count++; System.out.println(&quot;The time out element &quot; + start + &quot;:&quot; + count);// 记录离开该节点的时间 } }} 运行结果：123456789101112The time into element u:1The time into element v:2The time into element y:3The time into element x:4The time out element x:5The time out element y:6The time out element v:7The time out element u:8The time into element w:9The time into element z:10The time out element z:11The time out element w:12","link":"/2017/07/02/详解BFS和DFS及Java实现/"},{"title":"豆瓣电视剧评论的爬取以及进行情感分析+生成词云","text":"很多时候我们要了解一部电视剧或电影的好坏时都会去豆瓣上查看评分和评论，本文基于豆瓣上对某一部电视剧评论的爬取，然后进行SnowNLP情感分析，最后生成词云，给人一个直观的印象 1. 爬取评论以前段时间比较火热的《猎场》为例，因豆瓣网有反爬虫机制，所以在爬取时要带登录后的cookie文件，保存在cookie.txt文件里，具体代码及结果如下： 1234567891011121314151617181920212223242526import requests, codecsfrom lxml import htmlimport timeimport randomheader = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&apos;}f_cookies = open(&apos;cookie.txt&apos;, &apos;r&apos;)cookies = {}for line in f_cookies.read().split(&apos;;&apos;): name, value = line.strip().split(&apos;=&apos;, 1) cookies[name] = value#print(cookies)for num in range(0, 500, 20): url = &apos;https://movie.douban.com/subject/26322642/comments?start=&apos; + str( num) + &apos;&amp;amp;limit=20&amp;amp;sort=new_score&amp;amp;status=P&amp;amp;percent_type=&apos; with codecs.open(&apos;comment.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f: try: r = requests.get(url, headers=header, cookies=cookies) result = html.fromstring(r.text) comment = result.xpath( &quot; // div[@class =&apos;comment&apos;] / p / text() &quot;) for i in comment: f.write(i.strip() + &apos;\\r\\n&apos;) except Exception as e: print(e) time.sleep(1 + float(random.randint(1, 100)) / 20) 2. 情感分析SnowNLP是python中用来处理文本内容的，可以用来分词、标注、文本情感分析等，情感分析是简单的将文本分为两类，积极和消极，返回值为情绪的概率，越接近1为积极，接近0为消极。代码如下：12345678910111213141516import numpy as npfrom snownlp import SnowNLPimport matplotlib.pyplot as pltf = open(&apos;comment.txt&apos;, &apos;r&apos;, encoding=&apos;UTF-8&apos;)list = f.readlines()sentimentslist = []for i in list: s = SnowNLP(i) # print s.sentiments sentimentslist.append(s.sentiments)plt.hist(sentimentslist, bins=np.arange(0, 1, 0.01), facecolor=&apos;g&apos;)plt.xlabel(&apos;Sentiments Probability&apos;)plt.ylabel(&apos;Quantity&apos;)plt.title(&apos;Analysis of Sentiments&apos;)plt.show() 3. 生成词云 词云的生成主要用到了结巴分词和wordcloud，前者是针对中文进行分词的处理库，后者可以根据分词处理结果定制化生成词云，详细代码如下： 123456789101112131415161718192021222324252627282930313233#coding=utf-8import matplotlib.pyplot as pltfrom scipy.misc import imreadfrom wordcloud import WordCloudimport jieba, codecsfrom collections import Countertext = codecs.open(&apos;comment.txt&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;).read()text_jieba = list(jieba.cut(text))c = Counter(text_jieba) # 计数word = c.most_common(800) # 取前500bg_pic = imread(&apos;src.jpg&apos;)wc = WordCloud( font_path=&apos;C:\\Windows\\Fonts\\SIMYOU.TTF&apos;, # 指定中文字体 background_color=&apos;white&apos;, # 设置背景颜色 max_words=2000, # 设置最大显示的字数 mask=bg_pic, # 设置背景图片 max_font_size=200, # 设置字体最大值 random_state=20 # 设置多少种随机状态，即多少种配色)wc.generate_from_frequencies(dict(word)) # 生成词云wc.to_file(&apos;result.jpg&apos;)# showplt.imshow(wc)plt.axis(&quot;off&quot;)plt.figure()plt.imshow(bg_pic, cmap=plt.cm.gray)plt.axis(&quot;off&quot;)plt.show()","link":"/2018/01/08/豆瓣电视剧评论的爬取以及进行情感分析+生成词云/"},{"title":"采用线程池处理异步任务并获取最终结果","text":"以前对线程池的理解大多处于理论阶段，知道为什么要用以及怎么用，各个参数的含意设置及原理，也明白submit和excute的区别，但是在实际工作时遇到对异步任务处理时却不知道怎么先批量提交到线程池，利用线程池批量处理后再批量获取返回结果，通过同事指点再知道invokeAll方法，因此看了一下源码并写了一个简单的demo invokeAll是AbstractExecutorService抽象类下的一个方法，源码如下, 该方法主要是接受一个异步任务列表，这段代码主要是有两个for循环，第一个for循环是将列表中的任务添加到线程池运行起来，第二个for循环是通过f.get来阻塞所有未完成的任务直到完成，最后finally里面尝试取消出现异常完成的任务。 123456789101112131415161718192021222324252627282930public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException { if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try { for (Callable&lt;T&gt; t : tasks) { RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); execute(f); } for (int i = 0, size = futures.size(); i &lt; size; i++) { Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) { try { f.get(); } catch (CancellationException ignore) { } catch (ExecutionException ignore) { } } } done = true; return futures; } finally { if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); }} 使用线程池调用invokeAll的demo：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;public class ThreadPoolDemo { public static void main(String[] args) { new ThreadPoolDemo().execute(); } public void execute(){ ThreadPoolExecutor executor = new ThreadPoolExecutor(12, 12, 2000, TimeUnit.MICROSECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000)); List&lt;Handler&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 100; i++){ list.add(new Handler(String.valueOf(i))); } try { //会按照添加到List的次序返回，该方法阻塞至所有任务完成 List&lt;Future&lt;String&gt;&gt; results = executor.invokeAll(list); results.stream().forEach( future -&gt; { try { System.out.println(future.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); } catch (Exception e) { e.printStackTrace(); } //关闭线程池 executor.shutdown(); } private class Handler implements Callable&lt;String&gt; { //模拟传参，实际可为对象类型 String value; public Handler(String value){ this.value = value; } public String call(){ try { //模拟任务的处理过程0-1000ms Thread.sleep((int)(Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } //模拟返回参数，实际可为对象类型 System.out.println(value); return value + &quot;value&quot;; } }} 运行结果: 如上图所示，所有任务添加到线程池后执行并没有次序，但最后返回的结果是按照最初添加list的顺序，即利用了线程池并发处理的特点，又有序获取到了所有异步任务的最终执行结果。","link":"/2018/10/31/采用线程池处理异步任务并获取最终结果/"},{"title":"采用动态规划的思想解决三种经典问题之Java实现","text":"当遇到复杂问题时我们经常会通过递归的方式将大事化小，小事化了。但是有时候将复杂问题简单地分解成几个子问题，问题求解耗时会按问题规模呈幂级数增加。这时候为了节约重复求相同子问题的时间，引入一个数组(或临时变量)，不管它们是否对最终解有用，把所有子问题的解存于该数组(或临时变量)中，这就是动态规划的基本思想。 ###1.Fibonacci数列该数列的递归形式如下，即从每二项开始每一项等于前两项之和： 根据定义可以用递归方式写出如下代码：1234public int fib(int n) { // 计算Fibonacci数列的第n项（二分递归版）：O(2^n) return (2 &gt; n) ? n // 若到达递归基，直接取值 : fib(n - 1) + fib(n - 2); // 否则，递归计算前两项，其和即为正解} 递规版本的时间复杂度将呈指数级别，明显不能很好的解决问题，现通过牺牲空间复杂度，利用动态规划的思想将时间复杂度控制降低到O(n).123456789101112public static int fib1(int n) { // 计算Fibonacci数列的第n项（动态规划版）：O(n) if(n &lt; 2) return n; int a = 0;//第一个值 int b = 1;//第二个值 int tmp = 0;//辅助变量 for(int i = 2;i &lt;= n;i++){ tmp = a + b; a = b; b = tmp; } return tmp; } ###2.爬楼梯 问题描述：有一座高度为n级的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶，求出一共有多少种走法。 分析：因为每1步只能走1级或者2级，所以走到第n级的前一步有且只有两种情况，第一种情况是从第n - 1级走1级，第二种情况是从第n - 2级走2级。由此我们就可以得到此问题的递归公式：123F(1) = 1;F(2) = 2;F(n) = F(n - 1) + F(n - 2); 看到这里，相信聪明的你很快就反映过来了这不就是上面的Fibonacci数列问题嘛(注意：起始值不同)，下面直接给出动态规划思想的代码实现:123456789101112public static int getNum(int n) { if(n &lt;= 2) return n; int a = 1;//只有1级台阶的情况 int b = 2;//有2级台阶的情况 int tmp = 0;//辅助变量 for(int i = 3;i &lt;= n;i++){ tmp = a + b; a = b; b = tmp; } return tmp; } ###3.最长公共子序列有了上面两个动态规划实现的热身，下面看一个复杂点的问题，首先看一下两个定义：子序列(Sequence)：由序列中若干字符，按原相对次序构成。 最长公共子序列(Longest Common Subsequence）:两个序列公共子序列中的最长者，下面简称LCS,可能出现下面两种比较复杂的情况：1).可能有多个 2).可能有歧义 现用递归的思想分析如下：对于序列A[0,n]和B[0,m]，LCS(A,B)无非三种情况：1) 若n = - 1或 m = - 1，则取作空序列(“”)2) 若A[n] = ‘X’ = B[m],则取作LCS(A[0,n), B[0,m)) + ‘X’,示意图如下： 3) 若A[n] != B[m],则在LCS(A[0,n], B[0,m))与LCS(A[0,n), B[0,m])中取更长者示意图如下： 如下图所示，展示了“EDUCATIONAL”和“ADVANTAGE”通过递归思想求最长公共子序列的过程。 代码实现如下：123456789101112131415 /** * 递归方式实现求两个字符串最长公共字序列的长度 * @param str1 第一个字符串 * @param m 第一个字符串需要比较的长度 * @param str2 第二个字符串 * @param n 第一个字符串需要比较的长度 * @return */public static int lcs(String str1,int m,String str2,int n){ if(m == 0 || n == 0) return 0;//如果其中有一个元素为空则返回0 if(str1.charAt(m - 1) == str2.charAt(n - 1)) return lcs(str1,m - 1,str2,n - 1) + 1;//如果需要比较的两个字符串最后一个字符相同则将问题缩小 //剩下的情况则两个字符串的最后一个字符不相等，取两种情况中的最大值 return getMax(lcs(str1,m - 1,str2,n),lcs(str1,m,str2,n - 1));} 可以看出如果最后一个字符不相等，反而会将问题的规模扩大，当m与n大小接近时，时间复杂度也呈指数级别。下面将考虑通过动态规划的思想来实现：构造一个二维辅助数组，从上往下依次计算，如下图所示： 代码实现如下：1234567891011121314151617181920212223 /** * 非递归方式实现求两个字符串最长公共字序列的长度 * @param str1 第一个字符串 * @param m 第一个字符串需要比较的长度 * @param str2 第二个字符串 * @param n 第一个字符串需要比较的长度 * @return */public static int lcs1(String str1,int m,String str2,int n){ if(m == 0 || n == 0) return 0; //构建一个m + 1行 n + 1列的辅助二维数组,里面的元素初始值都为0 int[][] arr = new int[m + 1][n + 1]; //依次求二维数组中的值 for(int i = 1;i &lt;= m;i ++){ for(int j = 1;j &lt;= n; j ++){ //当最后一个字符相等时等于左上角的元素加1 if(str1.charAt(i - 1) == str2.charAt(j - 1)) arr[i][j] = arr[i - 1][j - 1] + 1; //不相等时取紧邻左边元素和上边元素者的大者 else arr[i][j] = getMax(arr[i - 1][j],arr[i][j - 1]); } } return arr[m][n];//二维数组右下角的元素即我们需要的值} 总结：动态规划的思想通过牺牲空间复杂度的方式来大大减小时间复杂度，将自顶而下的计算方式改为自底而上，把已计算过的实例结果制表备查，从而取得非常显著的效果。","link":"/2017/07/02/采用动态规划的思想解决三种经典问题之Java实现/"},{"title":"阿里云服务器部署JavaWeb项目","text":"#####1. 如果tomcat已经运行，则先要杀掉tomcat进程 #####2. 删除tomcat目录webapps下的项目文件 #####3. 上传war包到webapps目录下 #####4. 运行bin目录下的catalina.sh，即可以带日志形式启动tomcat并解压war包ctrl + c即可退出该模式 #####5. 运行bin目录下的startup.sh即可启动tomcat运行shutdown.sh可关闭tomcat 通过以上五步就可成功将一个JavaWeb项目部署到阿里云服务器。","link":"/2018/01/03/阿里云服务器部署JavaWeb项目/"},{"title":"Google Guava Cache 全解析","text":"Google Guava Cache是一种非常优秀本地缓存解决方案，提供了基于容量，时间和引用的缓存回收方式。基于容量的方式内部实现采用LRU算法，基于引用回收很好的利用了Java虚拟机的垃圾回收机制。其中的缓存构造器CacheBuilder采用构建者模式提供了设置好各种参数的缓存对象，缓存核心类LocalCache里面的内部类Segment与jdk1.7及以前的ConcurrentHashMap非常相似，都继承于ReetrantLock，还有六个队列，以实现丰富的本地缓存方案。本文先介绍了Guava Cache囊括的基本使用方法，然后结合体系类图和LocalCache的数据结构对典型的几个方法源码进行流程分析。 为什么要用本地缓存 相对于IO操作 速度快，效率高相对于Redis Redis是一种优秀的分布式缓存实现，受限于网卡等原因，远水救不了近火。 DB + Redis + LocalCache = 高效存储，高效访问 什么时候用 愿意消耗一些内存空间来提升速度 预料到某些键会被多次查询 缓存中存放的数据总量不会超出内存容量 怎么用 设置缓存容量 设置超时时间 提供移除监听器 提供缓存加载器 构建缓存 Demo1:12345678910111213141516171819202122232425262728293031323334353637383940public class GuavaCacheDemo1 { public static void main(String[] args){ CacheLoader&lt;String, String&gt; loader = new CacheLoader&lt;String, String&gt; () { public String load(String key) throws Exception { Thread.sleep(1000); if(&quot;key&quot;.equals(key)) return null; System.out.println(key + &quot; is loaded from a cacheLoader!&quot;); return key + &quot;&apos;s value&quot;; } }; RemovalListener&lt;String, String&gt; removalListener = new RemovalListener&lt;String, String&gt;() { public void onRemoval(RemovalNotification&lt;String, String&gt; removal) { System.out.println(&quot;[&quot; + removal.getKey() + &quot;:&quot; + removal.getValue() + &quot;] is evicted!&quot;); } }; LoadingCache&lt;String, String&gt; testCache = CacheBuilder.newBuilder() .maximumSize(7) .expireAfterWrite(10, TimeUnit.MINUTES) .removalListener(removalListener) .build(loader); for (int i = 0; i &lt; 10; i ++){ String key = &quot;key&quot; + i; String value = &quot;value&quot; + i; testCache.put(key,value); System.out.println(&quot;[&quot; + key + &quot;:&quot; + value + &quot;] is put into cache!&quot;); } System.out.println(testCache.getIfPresent(&quot;key6&quot;)); try{ System.out.println(testCache.get(&quot;key&quot;)); } catch(Exception e){ e.printStackTrace(); } }} 运行效果： 加载CacheLoader如果有合理的默认方法来加载或计算与键关联的值。 LoadingCache是附带CacheLoader构建而成的缓存实现。创建自己的CacheLoader通常只需要简单地实现V load(K key) throws Exception方法。 从LoadingCache查询的正规方式是使用get(K)方法。这个方法要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值。由于CacheLoader可能抛出异常，LoadingCache.get(K)也声明为抛出ExecutionException异常。 Callable如果没有合理的默认方法来加载或计算与键关联的值，或者想要覆盖默认的加载运算，同时保留“获取缓存-如果没有-则计算”[get-if-absent-compute]的原子语义。 所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K, Callable)方法。这个方法返回缓存中相应的值，或者用给定的Callable运算并把结果加入到缓存中。在整个加载方法完成前，缓存项相关的可观察状态都不会更改。这个方法简便地实现了模式”如果有缓存则返回；否则运算、缓存、然后返回”。 Demo2:123456789101112131415161718192021222324252627282930public class GuavaCacheDemo2 { static Cache&lt;String, String&gt; testCache = CacheBuilder.newBuilder() .maximumSize(3) .build(); public static void main(String[] args){ testCache.put(&quot;1234&quot;,&quot;45&quot;); System.out.println(testCache.getIfPresent(&quot;key6&quot;)); try { System.out.println(testCache.get(&quot;123&quot;, new Callable&lt;String&gt;() { public String call() throws Exception { return &quot;134&quot;; } })); System.out.println(testCache.get(&quot;1234&quot;, new Callable&lt;String&gt;() { public String call() throws Exception { return &quot;134&quot;; } })); } catch (ExecutionException e) { e.printStackTrace(); } }} 运行效果： Cache.put但自动加载是首选的，因为它可以更容易地推断所有缓存内容的一致性。使用cache.put(key, value)方法可以直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值。使用Cache.asMap()视图提供的任何方法也能修改缓存。但请注意，asMap视图的任何方法都不能保证缓存项被原子地加载到缓存中。进一步说，asMap视图的原子运算在Guava Cache的原子加载范畴之外，所以相比于Cache.asMap().putIfAbsent(K,V)，Cache.get(K, Callable) 应该总是优先使用。 ##缓存回收Guava Cache提供了三种基本的缓存回收方式: ###1. 基于容量回收maximumSize(long)：当缓存中的元素数量超过指定值时。 ###2. 定时回收expireAfterAccess(long, TimeUnit)：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。expireAfterWrite(long, TimeUnit)：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。 ###3. 基于引用回收（Reference-based Eviction）CacheBuilder.weakKeys()：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。CacheBuilder.weakValues()：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。CacheBuilder.softValues()：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。 显式清除任何时候，你都可以显式地清除缓存项，而不是等到它被回收：个别清除：Cache.invalidate(key)批量清除：Cache.invalidateAll(keys)清除所有缓存项：Cache.invalidateAll() 移除监听器通过CacheBuilder.removalListener(RemovalListener)，你可以声明一个监听器，以便缓存项被移除时做一些额外操作。缓存项被移除时，RemovalListener会获取移除通知[RemovalNotification]，其中包含移除原因[RemovalCause]、键和值。 统计CacheBuilder.recordStats()：用来开启Guava Cache的统计功能。统计打开后，Cache.stats()方法会返回CacheS tats 对象以提供如下统计信息： hitRate()：缓存命中率；averageLoadPenalty()：加载新值的平均时间，单位为纳秒；evictionCount()：缓存项被回收的总数，不包括显式清除。 此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能要求高的应用中我们建议密切关注这些数据。 Demo3:12345678910111213141516171819202122public class GuavaCacheDemo3 { static Cache&lt;String, Object&gt; testCache = CacheBuilder.newBuilder() .weakValues() .recordStats() .build(); public static void main(String[] args){ Object obj1 = new Object(); testCache.put(&quot;1234&quot;,obj1); obj1 = new String(&quot;123&quot;); System.gc(); System.out.println(testCache.getIfPresent(&quot;1234&quot;)); System.out.println(testCache.stats()); }} 运行结果 LRU缓存回收算法 LRU（Least?recently?used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 1.?新数据插入到链表头部；2.?每当缓存命中（即缓存数据被访问），则将数据移到链表头部；3.?当链表满的时候，将链表尾部的数据丢弃。 Guava Cache中借助读写队列来实现LRU算法。 Guava Cache体系类图 #####CacheBuilder缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。主要采用builder的模式，CacheBuilder的每一个方法都返回这个CacheBuilder知道build方法的调用。注意build方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。 #####LocalManualCache作为LocalCache的一个内部类，在构造方法里面会把LocalCache类型的变量传入，并且调用方法时都直接或者间接调用LocalCache里面的方法。 #####LocalLoadingCache可以看到该类继承了LocalManualCache并实现接口LoadingCache。覆盖了get，getUnchecked等方法。 #####LocalCacheGuava Cache中的核心类，重点了解。 LocalCache数据结构 根据上面的分析可知，LocalCache为Guava Cache的核心类，先看一个该类的数据结构： LocalCache的数据结构与ConcurrentHashMap很相似，都由多个segment组成，且各segment相对独立，互不影响，所以能支持并行操作。每个segment由一个table和若干队列组成。缓存数据存储在table中，其类型为AtomicReferenceArray。 #####Segment&lt;K, V&gt;[] segments;Segment继承于ReetrantLock，减小锁粒度，提高并发效率。 AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table;类似于HasmMap中的table一样，相当于entry的容器。 #####ReferenceEntry&lt;K, V&gt; referenceEntry;基于引用的Entry,其实现类有弱引用Entry,强引用Entry等 ReferenceQueue keyReferenceQueue;已经被GC，需要内部清理的键引用队列。 ReferenceQueue valueReferenceQueue;已经被GC，需要内部清理的值引用队列。 Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; recencyQueue;记录升级可访问列表清单时的entries,当segment上达到临界值或发生写操作时该队列会被清空。 Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;按照写入时间进行排序的元素队列，写入一个元素时会把它加入到队列尾部。 Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;按照访问时间进行排序的元素队列，访问(包括写入)一个元素时会把它加入到队列尾部。 put public V put(K key, V value); //onlyIfAbsent为falsepublic V putIfAbsent(K key, V value); //onlyIfAbsent为true 该方法显式往本地缓存里面插入值。从下面的流程图中可以看出，在执行每次put前都会进行preWriteCleanUP，在put返回前如果更新了entry则要进行evictEntries操作。 preWriteCleanup void preWriteCleanup(long now)； 传人参数只有当前时间。 键值引用队列中都是存储已经被GC，等待清除的entry信息，所以首先去处理这个里面的entry. 读写队列里面是按照读写时间排序的，取出队列中的首元素，如果当前时间与该元素的时间相差值大于设定值，则进行回收。 evictEntriesvoid evictEntries(ReferenceEntry&lt;K, V&gt; newest)； 传入的参数为最新的Entry，可能是刚插入的，也可能是刚更新过的。 该方法只有在设置了在构建缓存的时候指定了maximumSize才会往下执行。首先清除recencyQueue，判断该元素自身的权重是否超过上限，如果超过则移除当前元素。然后判断总的权重是否大于上限，如果超过则去accessQueue里找到队首(即最不常访问的元素)进行移除，直到小于上限。 getIfPresent public V getIfPresent(Object key)；该方法从本地缓存中找值，如果找不到返回null，找到就返回相应的值。 get 首先会在缓存中找，缓存中找不到再通过load加载。 remove public V remove(@Nullable Object key)；调用LocalManualCache的invalidate(Object key)方法即可调用remove.","link":"/2017/08/20/Google Guava Cache 全解析/"},{"title":"Hibernate构架(一) 初探","text":"ORM，Object Relation Mapping，即对象关系映射。Hibernate就是ORM的实现，使对象在数据库的存储和获取非常的方便。 1.Hibernate开发流程 1.1 引入jar文件hibernate3.jar核心 + required 必须引入的(6个) + jpa 目录 + 数据库驱动包 1.2 写对象类Employee.java1234567public class Employee { private int empId; private String empName; private Date workDate; } 1.3 配置对象的映射Employee.hbm.xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.a_hello&quot;&gt; &lt;class name=&quot;Employee&quot; table=&quot;employee&quot;&gt; &lt;!-- 主键 ，映射--&gt; &lt;id name=&quot;empId&quot; column=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 非主键，映射 --&gt; &lt;property name=&quot;empName&quot; column=&quot;empName&quot;&gt;&lt;/property&gt; &lt;property name=&quot;workDate&quot; column=&quot;workDate&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 1.4 主配置文件hibernate.cfg.xml12345678910111213141516171819&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库连接配置 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hib_demo&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 加载所有映射 --&gt; &lt;mapping resource=&quot;cn/itcast/a_hello/Employee.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 1.5 测试App.java1234567891011121314151617181920212223242526 public class App { @Test public void testHello() throws Exception { // 对象 Employee emp = new Employee(); emp.setEmpName(&quot;班长&quot;); emp.setWorkDate(new Date()); // 获取加载配置文件的管理类对象 Configuration config = new Configuration(); config.configure(); // 默认加载src/hibenrate.cfg.xml文件 // 创建session的工厂对象 SessionFactory sf = config.buildSessionFactory(); // 创建session (代表一个会话，与数据库连接的会话) Session session = sf.openSession(); // 开启事务 Transaction tx = session.beginTransaction(); //保存-数据库 session.save(emp); // 提交事务 tx.commit(); // 关闭 session.close(); sf.close(); }} 2. Hibernate Api2.1 Configuration 配置管理类对象 1234 config.configure(); 加载主配置文件的方法(hibernate.cfg.xml) 默认加载src/hibernate.cfg.xmlconfig.configure(“cn/config/hibernate.cfg.xml”); 加载指定路径下指定名称的主配置文件config.buildSessionFactory(); 创建session的工厂对象 2.2 SessionFactory session的工厂（或者说代表了这个hibernate.cfg.xml配置文件） 12sf.openSession(); 创建一个sesison对象sf.getCurrentSession(); 创建session或取出session对象 2.3 Session session对象维护了一个连接(Connection), 代表了与数据库连接的会话。 Hibernate最重要的对象： 只用使用hibernate与数据库操作，都用到这个对象 1234567891011session.beginTransaction(); 开启一个事务； hibernate要求所有的与数据库的操作必须有事务的环境，否则报错！更新：session.save(obj); 保存一个对象session.update(emp); 更新一个对象session.saveOrUpdate(emp); 保存或者更新的方法：没有设置主键，执行保存；有设置主键，执行更新操作; 如果设置主键不存在报错！主键查询：session.get(Employee.class, 1); 主键查询session.load(Employee.class, 1); 主键查询 (支持懒加载) 2.4 Transaction hibernate事务对象 3.Hibernate.cfg.xml 主配置 主配置文件中主要配置：数据库连接信息、其他参数、映射信息！ 3.1 数据库连接参数配置12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;!-- 通常，一个session-factory节点代表一个数据库 --&gt; &lt;session-factory&gt; &lt;!-- 1. 数据库连接配置 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hib_demo&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- 数据库方言配置， hibernate在运行的时候，会根据不同的方言生成符合当前数据库语法的sql --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 2. 其他相关配置 --&gt; &lt;!-- 2.1 显示hibernate在运行时候执行的sql语句 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 2.2 格式化sql --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 2.3 自动建表 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 3. 加载所有映射 &lt;mapping resource=&quot;cn/itcast/a_hello/Employee.hbm.xml&quot;/&gt; --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 4.映射配置 普通字段类型 主键映射 单列主键映射 多列作为主键映射主键生成策略，查看api：org.hibernate.id.factory.DefaultIdentifierGeneratorFactory 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- 映射文件: 映射一个实体类对象； 描述一个对象最终实现可以直接保存对象数据到数据库中。 --&gt;&lt;!-- package: 要映射的对象所在的包(可选,如果不指定,此文件所有的类都要指定全路径) auto-import 默认为true， 在写hql的时候自动导入包名 如果指定为false, 再写hql的时候必须要写上类的全名； 如：session.createQuery(&quot;from cn.itcast.c_hbm_config.Employee&quot;).list(); --&gt;&lt;hibernate-mapping package=&quot;cn.itcast.c_hbm_config&quot; auto-import=&quot;true&quot;&gt; &lt;!-- class 映射某一个对象的(一般情况，一个对象写一个映射文件，即一个class节点) name 指定要映射的对象的类型 table 指定对象对应的表； 如果没有指定表名，默认与对象名称一样 --&gt; &lt;class name=&quot;Employee&quot; table=&quot;employee&quot;&gt; &lt;!-- 主键 ，映射--&gt; &lt;id name=&quot;empId&quot; column=&quot;id&quot;&gt; &lt;!-- 主键的生成策略 identity 自增长(mysql,db2) sequence 自增长(序列)， oracle中自增长是以序列方法实现 native 自增长【会根据底层数据库自增长的方式选择identity或sequence】 如果是mysql数据库, 采用的自增长方式是identity 如果是oracle数据库， 使用sequence序列的方式实现自增长 increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。) assigned 指定主键生成策略为手动指定主键的值 uuid 指定uuid随机生成的唯一的值 foreign (外键的方式， one-to-one讲) --&gt; &lt;generator class=&quot;uuid&quot;/&gt; &lt;/id&gt; &lt;!-- 普通字段映射 property name 指定对象的属性名称 column 指定对象属性对应的表的字段名称，如果不写默认与对象属性一致。 length 指定字符的长度, 默认为255 type 指定映射表的字段的类型，如果不指定会匹配属性的类型 java类型： 必须写全名 hibernate类型： 直接写类型，都是小写 --&gt; &lt;property name=&quot;empName&quot; column=&quot;empName&quot; type=&quot;java.lang.String&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;workDate&quot; type=&quot;java.util.Date&quot;&gt;&lt;/property&gt; &lt;!-- 如果列名称为数据库关键字，需要用反引号或改列名。 --&gt; &lt;property name=&quot;desc&quot; column=&quot;`desc`&quot; type=&quot;java.lang.String&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 5.复合主键映射1234567891011// 复合主键类public class CompositeKeys implements Serializable{ private String userName; private String address; // .. get/set}public class User { // 名字跟地址，作为复合主键，不会重复 private CompositeKeys keys; private int age;} User.hbm.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.d_compositeKey&quot; auto-import=&quot;true&quot;&gt; &lt;class name=&quot;User&quot;&gt; &lt;!-- 复合主键映射 --&gt; &lt;composite-id name=&quot;keys&quot;&gt; &lt;key-property name=&quot;userName&quot; type=&quot;string&quot;&gt;&lt;/key-property&gt; &lt;key-property name=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/key-property&gt; &lt;/composite-id&gt; &lt;property name=&quot;age&quot; type=&quot;int&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; App2.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class App2 { private static SessionFactory sf; static { // 创建sf对象 sf = new Configuration() .configure() .addClass(User.class) //（测试） 会自动加载映射文件：Employee.hbm.xml .buildSessionFactory(); } //1. 保存对象 @Test public void testSave() throws Exception { Session session = sf.openSession(); Transaction tx = session.beginTransaction(); // 对象 CompositeKeys keys = new CompositeKeys(); keys.setAddress(&quot;广州棠东&quot;); keys.setUserName(&quot;Jack&quot;); User user = new User(); user.setAge(20); user.setKeys(keys); // 保存 session.save(user); tx.commit(); session.close(); } @Test public void testGet() throws Exception { Session session = sf.openSession(); Transaction tx = session.beginTransaction(); //构建主键再查询 CompositeKeys keys = new CompositeKeys(); keys.setAddress(&quot;广州棠东&quot;); keys.setUserName(&quot;Jack&quot;); // 主键查询 User user = (User) session.get(User.class, keys); // 测试输出 if (user != null){ System.out.println(user.getKeys().getUserName()); System.out.println(user.getKeys().getAddress()); System.out.println(user.getAge()); } tx.commit(); session.close(); }}","link":"/2017/06/11/Hibernate构架(一) 初探/"},{"title":"Hibernate构架(三） 状态，缓存，映射","text":"1.对象的状态 Hibernate中对象的状态： 临时/瞬时状态、持久化状态、游离状态。 1.1 临时状态 直接new出来的对象; 不处于session的管理;数据库中没有对象的记录; 1.2 持久化状态 当调用session的save/saveOrUpdate/get/load/list等方法的时候，对象就是持久化状态。处于持久化状态的对象，当对对象属性进行更改的时候，会反映到数据库中! 特点：处于session的管理;数据库中有对应的记录; 1.3 游离状态 不处于session的管理；数据库中有对应的记录;Session关闭后，对象的状态； 2. 一级缓存 1）Hibenate中一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！2）当调用session的save/saveOrUpdate/get/load/list/iterator方法的时候，都会把对象放入session的缓存中。3）Session的缓存由hibernate维护， 用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。特点： 只在(当前)session范围有效，作用时间短，效果不是特别明显！ 在短时间内多次操作数据库，效果比较明显！ ####2.1 缓存相关几个方法的作用123session.flush(); 让一级缓存与数据库同步session.evict(arg0); 清空一级缓存中指定的对象session.clear(); 清空一级缓存中缓存的所有对象 session.save():实体被纳入session缓存，session计划执行sql，此时查询不会有结果（无插入sql的执行）;session.flush():session“清理”缓存，发送执行sql，但不提交事务，此时在同一session中执行查询可以查询到结果（处于同一个数据库会话，尽管该会话的事物尚未提交，数据库中无真实的数据，此时查询到的应该是数据库本身事务机制的缓存），但在另外的查询中不会有结果（比如在native mysql中，因为不处于同一个数据库会话中）；commit():发送执行sql并提交事务；事务完成 ####2.2 list与iterator查询的区别list() 一次把所有的记录都查询出来，会放入缓存，但不会从缓存中获取数据iteratorN+1查询； N表示所有的记录总数即会先发送一条语句查询所有记录的主键（1），再根据每一个主键再去数据库查询（N）！会放入缓存，也会从缓存中取数据！ 3.懒加载 当用到数据的时候才向数据库查询，这就是hibernate的懒加载特性。 3.1 lazy 值true 使用懒加载false 关闭懒加载extra (在集合数据懒加载时候提升效率)在真正使用数据的时候才向数据库发送查询的sql；如果调用集合的size()/isEmpty()方法，只是统计，不真正查询数据！ 3.2 get、load方法区别get: 及时加载，只要调用get方法立刻向数据库查询load:默认使用懒加载，当用到数据的时候才向数据库查询。 3.3 懒加载异常 Session关闭后，不能使用懒加载数据！如果session关闭后，使用懒加载数据报错：org.hibernate.LazyInitializationException: could not initialize proxy - no Session 如何解决session关闭后不能使用懒加载数据的问题？a.方式1： 先使用一下数据dept.getDeptName();b.方式2：强迫代理对象初始化Hibernate.initialize(dept);c.方式3：关闭懒加载设置lazy=false;d.方式4： 在使用数据之后，再关闭session！ ##4.组件映射与继承映射 4.1 组件映射 类组合关系的映射，也叫做组件映射！注意：组件类和被包含的组件类，共同映射到一张表！需求： 汽车与车轮 1234567891011public class Car { private int id; private String name; // 车轮 private Wheel wheel;}// 车轮public class Wheel { private int count; private int size;} 123456789101112131415&lt;hibernate-mapping package=&quot;cn.itcast.d_component&quot;&gt; &lt;class name=&quot;Car&quot; table=&quot;t_car&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;!-- 组件映射 --&gt; &lt;component name=&quot;wheel&quot;&gt; &lt;property name=&quot;size&quot;&gt;&lt;/property&gt; &lt;property name=&quot;count&quot;&gt;&lt;/property&gt; &lt;/component&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4.2 继承映射12345678910111213141516171819202122232425262728// 动物类public abstract class Animal { private int id; private String name;}public class Cat extends Animal{ // 抓老鼠 private String catchMouse; public String getCatchMouse() { return catchMouse; } public void setCatchMouse(String catchMouse) { this.catchMouse = catchMouse; } } public class Monkey extends Animal { // 吃香蕉 private String eatBanana; public String getEatBanana() { return eatBanana; } public void setEatBanana(String eatBanana) { this.eatBanana = eatBanana; } } 4.2.1 所有子类映射到一张表 子类较多，且子类较为简单，即只有个别属性！好处：因为使用一个映射文件， 减少了映射文件的个数。缺点：（不符合数据库设计原则） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- 继承映射， 所有的子类都映射到一张表 --&gt;&lt;hibernate-mapping package=&quot;cn.itcast.e_extends2&quot;&gt; &lt;class name=&quot;Animal&quot; table=&quot;t_animal&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 指定鉴别器字段(区分不同的子类) --&gt; &lt;discriminator column=&quot;type_&quot;&gt;&lt;/discriminator&gt; &lt;property name=&quot;name&quot;&gt;&lt;/property&gt; &lt;!-- 子类：猫 每个子类都用subclass节点映射 注意：一定要指定鉴别器字段，否则报错！ 鉴别器字段：作用是在数据库中区别每一个子类的信息， 就是一个列 discriminator-value=&quot;cat_&quot; 指定鉴别器字段,即type_字段的值 如果不指定，默认为当前子类的全名 --&gt; &lt;subclass name=&quot;Cat&quot; discriminator-value=&quot;cat_&quot;&gt; &lt;property name=&quot;catchMouse&quot;&gt;&lt;/property&gt; &lt;/subclass&gt; &lt;!-- 子类：猴子 --&gt; &lt;subclass name=&quot;Monkey&quot; discriminator-value=&quot;monkey_&quot;&gt; &lt;property name=&quot;eatBanana&quot;&gt;&lt;/property&gt; &lt;/subclass&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ###4.2 每个类映射一张表(3张表) 一个映射文件，存储所有的子类； 子类父类都对应表；缺点：表结构比较负责，插入一条子类信息，需要用2条sql： 往父类插入、往子类插入！ 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- 继承映射， 每个类对应一张表(父类也对应表) --&gt;&lt;hibernate-mapping package=&quot;cn.itcast.e_extends3&quot;&gt; &lt;class name=&quot;Animal&quot; table=&quot;t_animal&quot;&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;&gt;&lt;/property&gt; &lt;!-- 子类：猫 t_cat key 指定_cat表的外键字段 --&gt; &lt;joined-subclass name=&quot;Cat&quot; table=&quot;t_cat&quot;&gt; &lt;key column=&quot;t_animal_id&quot;&gt;&lt;/key&gt; &lt;property name=&quot;catchMouse&quot;&gt;&lt;/property&gt; &lt;/joined-subclass&gt; &lt;!-- 子类：猴子 t_monkey --&gt; &lt;joined-subclass name=&quot;Monkey&quot; table=&quot;t_monkey&quot;&gt; &lt;key column=&quot;t_animal_id&quot;&gt;&lt;/key&gt; &lt;property name=&quot;eatBanana&quot;&gt;&lt;/property&gt; &lt;/joined-subclass&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 4.3 每个子类映射一张表， 父类不对应表(2张表) 所有的子类都写到一个映射文件；父类不对应表； 每个子类对应一张表(推荐) 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!-- 继承映射， 每个类对应一张表(父类不对应表) --&gt;&lt;hibernate-mapping package=&quot;cn.itcast.e_extends4&quot;&gt; &lt;!-- abstract=&quot;true&quot; 指定实体类对象不对应表，即在数据库段不生成表 --&gt; &lt;class name=&quot;Animal&quot; abstract=&quot;true&quot;&gt; &lt;!-- 如果用union-subclass节点，主键生成策略不能为自增长！ --&gt; &lt;id name=&quot;id&quot;&gt; &lt;generator class=&quot;uuid&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;&gt;&lt;/property&gt; &lt;!-- 子类：猫 t_cat union-subclass table 指定为表名, 表的主键即为id列 --&gt; &lt;union-subclass name=&quot;Cat&quot; table=&quot;t_cat&quot;&gt; &lt;property name=&quot;catchMouse&quot;&gt;&lt;/property&gt; &lt;/union-subclass&gt; &lt;!-- 子类：猴子 t_monkey --&gt; &lt;union-subclass name=&quot;Monkey&quot; table=&quot;t_monkey&quot;&gt; &lt;property name=&quot;eatBanana&quot;&gt;&lt;/property&gt; &lt;/union-subclass&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt;","link":"/2017/06/13/Hibernate构架(三） 状态，缓存，映射/"},{"title":"Hibernate构架(四） 查询,连接池，二级缓存，session管理","text":"1.查询 1) Get/load主键查询2) 对象导航查询3) HQL查询， Hibernate Query language hibernate 提供的面向对象的查询语言。4) Criteria 查询， 完全面向对象的查询（Query By Criteria ,QBC）5) SQLQuery， 本地SQL查询缺点：不能跨数据库平台： 如果该了数据库，sql语句有肯能要改使用场景： 对于复杂sql，hql实现不了的情况，可以使用本地sql查询 1.1 HQL查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public class App { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } /* * 1) Get/load主键查询 2) 对象导航查询 3) HQL查询， Hibernate Query language hibernate 提供的面向对象的查询语言。 4) Criteria 查询， 完全面向对象的查询（Query By Criteria ,QBC） 5) SQLQuery， 本地SQL查询 */ @Test public void all() { Session session = sf.openSession(); session.beginTransaction(); //1) 主键查询// Dept dept = (Dept) session.get(Dept.class, 12);// Dept dept = (Dept) session.load(Dept.class, 12); //2) 对象导航查询// Dept dept = (Dept) session.get(Dept.class, 12);// System.out.println(dept.getDeptName());// System.out.println(dept.getEmps()); // 3) HQL查询 // 注意：使用hql查询的时候 auto-import=&quot;true&quot; 要设置true， // 如果是false，写hql的时候，要指定类的全名// Query q = session.createQuery(&quot;from Dept&quot;);// System.out.println(q.list()); // a. 查询全部列// Query q = session.createQuery(&quot;from Dept&quot;); //OK// Query q = session.createQuery(&quot;select * from Dept&quot;); //NOK, 错误，不支持*// Query q = session.createQuery(&quot;select d from Dept d&quot;); // OK// System.out.println(q.list()); // b. 查询指定的列 【返回对象数据Object[] 】// Query q = session.createQuery(&quot;select d.deptId,d.deptName from Dept d&quot;); // System.out.println(q.list()); // c. 查询指定的列, 自动封装为对象 【必须要提供带参数构造器】// Query q = session.createQuery(&quot;select new Dept(d.deptId,d.deptName) from Dept d&quot;); // System.out.println(q.list()); // d. 条件查询: 一个条件/多个条件and or/between and/模糊查询 // 条件查询： 占位符// Query q = session.createQuery(&quot;from Dept d where deptName=?&quot;);// q.setString(0, &quot;财务部&quot;);// q.setParameter(0, &quot;财务部&quot;);// System.out.println(q.list()); // 条件查询： 命名参数// Query q = session.createQuery(&quot;from Dept d where deptId=:myId or deptName=:name&quot;);// q.setParameter(&quot;myId&quot;, 12);// q.setParameter(&quot;name&quot;, &quot;财务部&quot;);// System.out.println(q.list()); // 范围// Query q = session.createQuery(&quot;from Dept d where deptId between ? and ?&quot;);// q.setParameter(0, 1);// q.setParameter(1, 20);// System.out.println(q.list()); // 模糊// Query q = session.createQuery(&quot;from Dept d where deptName like ?&quot;);// q.setString(0, &quot;%部%&quot;);// System.out.println(q.list()); // e. 聚合函数统计// Query q = session.createQuery(&quot;select count(*) from Dept&quot;);// Long num = (Long) q.uniqueResult();// System.out.println(num); // f. 分组查询 //-- 统计t_employee表中，每个部门的人数 //数据库写法：SELECT dept_id,COUNT(*) FROM t_employee GROUP BY dept_id; // HQL写法// Query q = session.createQuery(&quot;select e.dept, count(*) from Employee e group by e.dept&quot;);// System.out.println(q.list()); session.getTransaction().commit(); session.close(); } // g. 连接查询 @Test public void join() { Session session = sf.openSession(); session.beginTransaction(); //1) 内连接 【映射已经配置好了关系，关联的时候，直接写对象的属性即可】// Query q = session.createQuery(&quot;from Dept d inner join d.emps&quot;); //2) 左外连接// Query q = session.createQuery(&quot;from Dept d left join d.emps&quot;); //3) 右外连接 Query q = session.createQuery(&quot;from Employee e right join e.dept&quot;); q.list(); session.getTransaction().commit(); session.close(); } // g. 连接查询 - 迫切连接 @Test public void fetch() { Session session = sf.openSession(); session.beginTransaction(); //1) 迫切内连接 【使用fetch, 会把右表的数据，填充到左表对象中！】// Query q = session.createQuery(&quot;from Dept d inner join fetch d.emps&quot;);// q.list(); //2) 迫切左外连接 Query q = session.createQuery(&quot;from Dept d left join fetch d.emps&quot;); q.list(); session.getTransaction().commit(); session.close(); } // HQL查询优化 @Test public void hql_other() { Session session = sf.openSession(); session.beginTransaction(); // HQL写死// Query q = session.createQuery(&quot;from Dept d where deptId &lt; 10 &quot;); // HQL 放到映射文件中 Query q = session.getNamedQuery(&quot;getAllDept&quot;); q.setParameter(0, 10); System.out.println(q.list()); session.getTransaction().commit(); session.close(); }} 1.2 Criteria 查询1234567891011121314151617//4) Criteria 查询， @Test public void criteria() { Session session = sf.openSession(); session.beginTransaction(); Criteria criteria = session.createCriteria(Employee.class); // 构建条件 criteria.add(Restrictions.eq(&quot;empId&quot;, 12));// criteria.add(Restrictions.idEq(12)); // 主键查询 System.out.println(criteria.list()); session.getTransaction().commit(); session.close(); 1.3 SQL查询123456789101112131415// 5) SQLQuery， 本地SQL查询 // 不能跨数据库平台： 如果该了数据库，sql语句有肯能要改。 @Test public void sql() { Session session = sf.openSession(); session.beginTransaction(); SQLQuery q = session.createSQLQuery(&quot;SELECT * FROM t_Dept limit 5;&quot;) .addEntity(Dept.class); // 也可以自动封装 System.out.println(q.list()); session.getTransaction().commit(); session.close(); } 1.4 分页查询12345678910111213141516171819202122232425// 分页查询 @Test public void all() { Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery(&quot;from Employee&quot;); // 从记录数 ScrollableResults scroll = q.scroll(); // 得到滚动的结果集 scroll.last(); // 滚动到最后一行 int totalCount = scroll.getRowNumber() + 1;// 得到滚到的记录数，即总记录数 // 设置分页参数 q.setFirstResult(0); q.setMaxResults(3); // 查询 System.out.println(q.list()); System.out.println(&quot;总记录数：&quot; + totalCount); session.getTransaction().commit(); session.close(); } 2.连接池 Hibernate 自带的也有一个连接池，且对C3P0连接池也有支持 2.1 Hbm 自带连接池只维护一个连接，比较简陋。 可以查看hibernate.properties文件查看连接池详细配置: 【Hbm对C3P0连接池支持， 核心类】 告诉hib使用的是哪一个连接池技术。hibernate.connection.provider_class org.hibernate.connection.C3P0ConnectionProvider 2.2 Hbm中的C3P0Hibernate.cfg.xml 中增加连接池相关配置：12345678910&lt;!-- 【连接池配置】 --&gt; &lt;!-- 配置连接驱动管理类 --&gt; &lt;property name=&quot;hibernate.connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 配置连接池参数信息 --&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;4&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;5000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; 3.二级缓存 Hibernate提供了基于应用程序级别的缓存， 可以跨多个session，即不同的session都可以访问缓存数据。 这个换存也叫二级缓存。 Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。 如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架都可以。 举例123456789101112&lt;!--****************** 【二级缓存配置】****************** --&gt; &lt;!-- a. 开启二级缓存 --&gt; &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;!-- b. 指定使用哪一个缓存框架(默认提供的) --&gt; &lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;org.hibernate.cache.HashtableCacheProvider&lt;/property&gt; &lt;!-- 开启查询缓存 --&gt; &lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt; &lt;!-- c. 指定哪一些类，需要加入二级缓存 --&gt; &lt;class-cache usage=&quot;read-write&quot; class=&quot;cn.itcast.b_second_cache.Dept&quot;/&gt; &lt;class-cache usage=&quot;read-only&quot; class=&quot;cn.itcast.b_second_cache.Employee&quot;/&gt; &lt;!-- 集合缓存[集合缓存的元素对象，也加加入二级缓存] --&gt; &lt;collection-cache usage=&quot;read-write&quot; collection=&quot;cn.itcast.b_second_cache.Dept.emps&quot;/&gt; 测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class App { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } // 1. 测试二级缓存的使用 // 没有/有用 二级缓存 @Test public void testCache() { Session session1 = sf.openSession(); session1.beginTransaction(); // a. 查询一次 Dept dept = (Dept) session1.get(Dept.class, 5); dept.getEmps().size();// 集合 session1.getTransaction().commit(); session1.close(); System.out.println(&quot;------&quot;); // 第二个session Session session2 = sf.openSession(); session2.beginTransaction(); // a. 查询一次 dept = (Dept) session2.get(Dept.class, 5); // 二级缓存配置好； 这里不查询数据库 dept.getEmps().size(); session2.getTransaction().commit(); session2.close(); } @Test public void listCache() { Session session1 = sf.openSession(); session1.beginTransaction(); // HQL查询 【setCacheable 指定从二级缓存找，或者是放入二级缓存】 Query q = session1.createQuery(&quot;from Dept&quot;).setCacheable(true); System.out.println(q.list()); session1.getTransaction().commit(); session1.close(); Session session2 = sf.openSession(); session2.beginTransaction(); q = session2.createQuery(&quot;from Dept&quot;).setCacheable(true); System.out.println(q.list()); // 不查询数据库： 需要开启查询缓存 session2.getTransaction().commit(); session2.close(); }} 4.session管理1234567891011121314151617181920212223242526272829303132public class App_session { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } @Test public void testSession() throws Exception { //openSession: 创建Session, 每次都会创建一个新的session Session session1 = sf.openSession(); Session session2 = sf.openSession(); System.out.println(session1 == session2);//false session1.close(); session2.close(); //getCurrentSession 创建或者获取session // 线程的方式创建session // 一定要配置：&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; Session session3 = sf.getCurrentSession();// 创建session，绑定到线程 Session session4 = sf.getCurrentSession();// 从当前访问线程获取session System.out.println(session3 == session4);//true // 关闭 【以线程方式创建的session，可以不用关闭； 线程结束session自动关闭】 //session3.close(); //session4.close(); 报错，因为同一个session已经关闭了！ }}","link":"/2017/06/15/Hibernate构架(四） 查询,连接池，二级缓存，session管理/"},{"title":"Idea中搭建zheng开源项目环境","text":"zheng项目(地址)是基于Spring+SpringMVC+Mybatis分布式发系统架构，包含用户管理，权限管理，内容管理等模块，后端采用Shiro，Dubbo，ZooKeeper，ActiveMQ，nginx等一些主流框架，前端采用jQuery，Bootstrap等主流技术，给中小企业提供了一站式解决方案。因此对于我们来说是一个很好的学习项目，但是其环境搭建并不是一个简单的过程，本文针对自己的搭建过程进行记录。 1. 克隆代码到本地，导入代码到idea, 下载依赖 2. 新建zheng数据库并导入数据 3. JDK，Tomcat， MavenJDK:1.8.0_131Tomcat: 7.0.53Maven: 3.5.2 4. 安装Redis并启动4.1 下载redis并安装地址：https://github.com/MSOpenTech/redis/releases 4.2 设置密码说明：此步可不做，因为zheng项目配置中redis密码为空，而且重启redis后密码会重置为空。如果你需要为redis设置一个密码则进行此步。1234redis-cli.exe -h 127.0.0.1 -p 6379config get requirepassconfig set requirepass &quot;root&quot;auth root 4.3再下载redis可视化管理工具地址： https://redisdesktop.com/download 4.4 连接redis打开redis可视化管理工具，填写好配置信息测试成功后即可建立redis连接 5. 下载安装zookeeper并启动地址：http://www.apache.org/dyn/closer.cgi/zookeeper/选择一个镜像地址进入下载 将zoo_sample.cfg复制一份并重命名为zoo.cfg 双击bin目录下的zkServer.cmd即可启动 6. 安装ActiveMQ并启动下载地址：http://activemq.apache.org/download-archives.html 解压然后到对应bin目录启动 浏览器访问：http://localhost:8161/admin，默认用户名和密码都是admin 登录成功页面 7.nginx下载地址：http://nginx.org/ a. 安装完nginx后将zheng\\project-tools\\nginx路径下的一个文件夹和文件拷贝到nginx-1.14.0\\conf路径并修改值为自己的项目路径 b.将zheng\\project-tools的nginx.bat拷贝到nginx-1.14.0\\路径 8. 修改host添加如下部分 12345678910111213127.0.0.1 ui.zhangshuzheng.cn 127.0.0.1 upms.zhangshuzheng.cn 127.0.0.1 cms.zhangshuzheng.cn 127.0.0.1 pay.zhangshuzheng.cn 127.0.0.1 ucenter.zhangshuzheng.cn 127.0.0.1 wechat.zhangshuzheng.cn 127.0.0.1 api.zhangshuzheng.cn 127.0.0.1 oss.zhangshuzheng.cn 127.0.0.1 config.zhangshuzheng.cn 127.0.0.1 zkserver 127.0.0.1 rdserver 127.0.0.1 dbserver 127.0.0.1 mqserver 9. 修改数据库连接信息说明：zheng项目中配置的mysql连接信息登录名为root，密码为123456，redis密码为空。如果你的配置是这样，则不需要进行此步操作。 ######a. 数据库连接密码都是通过AES加密，因此需要先把明文密码在工具类中进行转换 ######b. 修改配置文件(每个涉及到连接数据库的模块在启动时都要修改) 10. 权限管理系统upms直接在idea里启动upms-rpc-service ####11. 内容管理系统cms 12. dubbo-admin######a. 克隆https://github.com/apache/incubator-dubbo-ops到本地，并在dubbo-admin文件夹执行以下命令生成war包1mvn package -Dmaven.skip.test=true ######b. 将war包放入tomcat的webapps目录，修改tomcat端口为8088并启动 ######c. 访问dubbo-admin后台管理页面 ##总结如下图，用金字塔形状表示用到的工具及部署时的启动顺序。","link":"/2018/05/24/Idea中搭建zheng开源项目环境/"},{"title":"JAVA基础系列（三） 面向对象","text":"万事万物皆对象，对象是具有某些属性和功能的统一体。面向对象开发即不断地创建对象，使用对象，指挥对象，销毁对象。 1. 类与对象类：是一组相关的属性和行为的集合对象：是该类事物的具体体现举例：学生为一个类，某一具体的学生如班长就是一个对象 1.1 类的组成成员变量 + 构造函数 + 成员方法 1234567891011121314151617181920class Person{ public String name; public Integer age; public Person(String name,Integer age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; }} 1.2 对象内存图创建一个对象，要在栈区，堆区，方法区使用内存，具体见以下的Demo; 123456public class PersonDemo { public static void main(String[] args) { Person p1 = new Person(&quot;小红&quot;,11); Person p2 = new Person(&quot;小明&quot;,13); }} 在内存分配中如下图： 2. 几种变量 2.1 局部变量与成员变量 2.2 成员变量与静态变量 3. 面向对象的特征3.1 封装 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式.封装提高了代码的复用性和安全性。 3.2 继承 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可 3.2.1 格式 class 子类名 extends 父类名 {} 3.2.2 特点(1)Java只支持单继承，不支持多继承。12class SubDemo extends Demo{} //okclass SubDemo extends Demo1,Demo2...//error (2) Java支持多层继承(继承体系)123class A{}class B extends A{}class C extends B{} 3.2.3 注意事项(1) 子类只能继承父类所有非私有的成员(成员方法和成员变量)(2) 子类不能继承父类的构造方法，但是可以通过super()关键字去访问父类构造方法。Demo: 123456789101112131415161718192021222324252627282930313233class Father { private int num = 10; public int num2 = 20; //私有方法，子类不能继承 private void method() { System.out.println(num); System.out.println(num2); } public void show() { System.out.println(num); System.out.println(num2); }}class Son extends Father { public void function() { //num可以在Father中访问private //子类不能继承父类的私有成员变量 //System.out.println(num); System.out.println(num2); }}class ExtendsDemo { public static void main(String[] args) { // 创建对象 Son s = new Son(); //子类不能继承父类的私有成员方法 //s.method(); s.show(); s.function(); }} 3.3 多态 某一个事物，在不同时刻表现出来的不同状态.前提是要有继承关系,有方法重写,有父类引用指向子类对象。 Demo：1234567891011121314151617181920212223242526public class PolymDemo { public static void main(String[] args) { Animal animal1 = new Dog(); animal1.eat(); // 狗吃肉 Animal animal2 = new Cat(); animal2.eat(); // 猫吃鱼 }}class Animal { public void eat() { System.out.println(&quot;eat&quot;); }}class Dog extends Animal { public void eat() { System.out.println(&quot;狗吃肉&quot;); }}class Cat extends Animal { public void eat() { System.out.println(&quot;猫吃鱼&quot;); }} 4. 类的初始化过程 Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ClassInitDemo { public static void main(String[] args) { Base tmp = new Derived(); /** 初始化过程 * Base:static init block invoked.. 1 * Derived:static init block invoked... 2 * Base:normal block invoked.. 3 * Base:constructor invoked.. 4 * Derived:normal block invoked.. 5 * Derived:constructor invoked.. 6 */ }}class Base { //1. 初始化父类中的静态成员变量和静态代码块 static int b; static { System.out.println(&quot;Base:static init block invoked..&quot;); } //3. 初始化父类的普通成员变量和代码块 int a; { System.out.println(&quot;Base:normal block invoked..&quot;); } //4. 执行父类的构造方法 public Base() { System.out.println(&quot;Base:constructor invoked..&quot;); }}class Derived extends Base { //2. 初始化子类中的静态成员变量和静态代码块 static int e = 4; static { System.out.println(&quot;Derived:static init block invoked...&quot;); } //5. 初始化子类的普通成员变量和代码块 int d; { System.out.println(&quot;Derived:normal block invoked..&quot;); } //6. 执行子类的构造方法 public Derived() { System.out.println(&quot;Derived:constructor invoked..&quot;); }} 5. 抽象类 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。 格式 1234abstract class 类名 { public abstract void 抽象方法名(); public void 非抽象方法名();} 注意: (a)抽象类不一定有抽象方法，有抽象方法的类一定是抽象类(b)抽象类有构造方法，但不能被初始化，构造方法用来给子类访问其成员变量(c)abstract不能与private,final,static关键字共存 6. 接口 为了体现事物功能的扩展性，Java中就提供了接口来定义这些额外功能，并不给出具体实现 6.1 格式1234567891011121314//接口类interface 接口名 { void 方法1(); String 方法2();}//实现类class 类名 implements 接口名 { void 方法1(){ do something; } String 方法2(){ do something; }} 注意：(a)接口不能实例化(b)接口的子类要么是抽象类,要么重写接口中的所有抽象方法 6.2 接口成员的特点 成员变量只能是常量默认修饰符 public static final 构造方法没有，因为接口主要是扩展功能的，而没有具体存在成员方法 只能是抽象方法默认修饰符 public abstract 6.3 类与接口的关系 类与类：继承关系，只能单继承，但是可以多层继承 类与接口：实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口 接口与接口：继承关系，可以单继承，也可以多继承 6.4 接口与抽象类对比 7. 内部类 把类定义在其他类的内部，这个类就被称为内部类。 访问特点： 内部类可以直接访问外部类的成员，包括私有。外部类要访问内部类的成员，必须创建对象。Demo:12345678910111213141516class Outer { private int num = 10; class Inner { public void show() { //可以直接访问外部类的私有成员变量 System.out.println(num); } } public void method() { //找不到符号 //show(); Inner i = new Inner(); i.show(); } } 7.1 成员内部类 123456789101112131415161718192021class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); } }}class OuterDemo { public static void main(String[] args) { Outer.Inner oi = new Outer().new Inner(); oi.show(); } } 7.2 局部内部类 1234567891011121314151617181920class Outer { public void method() { final int n = 100; class Inner { public void show() { System.out.println(n); } } Inner i = new Inner(); i.show(); }}class OuterDemo { public static void main(String[] args) { Outer o = new Outer(); o.method(); } } 7.3 匿名内部类 12345678910111213141516171819202122abstract class Person { public abstract void show();}class PersonDemo { public void method(Person p) { p.show(); }}class PersonTest { public static void main(String[] args) { //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); pd.method(new Person() { public void show() { System.out.println(“show”); } }); }}","link":"/2017/05/31/JAVA基础系列（三） 面向对象/"},{"title":"JAVA基础系列（九） GUI(图形界面编程)","text":"Graphical User Interface(图形用户接口)。用图形的方式，来显示计算机操作的界面，这样更方便更直观。 1.awt和swing包java.awt：Abstract Window ToolKit (抽象窗口工具包)，需要调用本地系统方法实现功能。属重量级控件。javax.swing：在AWT的基础上，建立的一套图形界面系统，其中提供了更多的组件，而且完全由Java实现。增强了移植性，属轻量级控件。 2. GUI继承体系图 3. 事件监听机制流程 4.GUI案例4.1 窗体关闭事件1234567891011121314151617181920212223242526272829import java.awt.Frame;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class FrameDemo { public static void main(String[] args) { // 创建窗体对象 Frame f = new Frame(&quot;窗体关闭案例&quot;); // 设置窗体属性 f.setBounds(400, 200, 400, 300); // 让窗体关闭 // 事件源 // 事件：对窗体的处理 // 事件处理：关闭窗口(System.exit(0)); // 事件监听 // 用适配器类改进 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); // 设置窗体可见 f.setVisible(true); }} 4.2 按钮点击事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.awt.Button;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/* * 需求：把按钮添加到窗体，并对按钮添加一个点击事件。 * A：创建窗体对象 * B:创建按钮对象 * C:把按钮添加到窗体 * D:窗体显示 */public class FrameDemo { public static void main(String[] args) { // 创建窗体对象 Frame f = new Frame(&quot;添加按钮&quot;); // 设置属性 f.setBounds(400, 200, 400, 300); // 设置布局为流式布局 f.setLayout(new FlowLayout()); // 创建按钮对象 Button bu = new Button(&quot;点我啊&quot;); // bu.setSize(20, 10); // 把按钮添加到窗体 f.add(bu); // 设置窗体可以关闭 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); bu.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;你再点试试&quot;); } }); // 窗体显示 f.setVisible(true); }} 4.3 把数据通过文本框转移到文本域123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FrameDemo { public static void main(String[] args) { // 创建窗体对象 Frame f = new Frame(&quot;数据转移&quot;); // 设置窗体属性和布局 f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建文本框 final TextField tf = new TextField(20); // 创建按钮 Button bu = new Button(&quot;数据转移&quot;); // 创建文本域 final TextArea ta = new TextArea(10, 40); // 把组件添加到窗体 f.add(tf); f.add(bu); f.add(ta); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); // 对按钮添加事件 bu.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // 获取文本框的值 String tf_str = tf.getText().trim(); // 清空数据 tf.setText(&quot;&quot;); // 设置给文本域 // ta.setText(tf_str); // 追加和换行 ta.append(tf_str + &quot;\\r\\n&quot;); //获取光标 tf.requestFocus(); } }); // 设置窗体显示 f.setVisible(true); }} 4.4 鼠标事件案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.awt.Button;import java.awt.Color;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class FrameDemo { public static void main(String[] args) { // 创建窗体对象 final Frame f = new Frame(&quot;更改背景色&quot;); // 设置窗体属性和布局 f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建四个按钮 Button redButton = new Button(&quot;红色&quot;); Button greenButton = new Button(&quot;绿色&quot;); Button buleButton = new Button(&quot;蓝色&quot;); // 添加按钮 f.add(redButton); f.add(greenButton); f.add(buleButton); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); // 对按钮添加鼠标的进入事件 redButton.addMouseListener(new MouseAdapter() { @Override public void mouseEntered(MouseEvent e) { f.setBackground(Color.RED); } @Override public void mouseExited(MouseEvent e) { f.setBackground(Color.WHITE); } }); greenButton.addMouseListener(new MouseAdapter() { @Override public void mouseEntered(MouseEvent e) { f.setBackground(Color.GREEN); } @Override public void mouseExited(MouseEvent e) { f.setBackground(Color.WHITE); } }); buleButton.addMouseListener(new MouseAdapter() { @Override public void mouseEntered(MouseEvent e) { f.setBackground(Color.BLUE); } @Override public void mouseExited(MouseEvent e) { f.setBackground(Color.WHITE); } }); // 设置窗体显示 f.setVisible(true); }} 4.5 键盘事件案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Label;import java.awt.TextField;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/* * 你输入的如果是非数字字符，就取消你键盘录入的效果。 */public class FrameDemo { public static void main(String[] args) { // 创建窗体对象并设置属性 Frame f = new Frame(&quot;不能输入非数字字符&quot;); f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); // 创建Label标签对象 Label label = new Label(&quot;请输入你的QQ号码，不能是非数字，不信你试试&quot;); TextField tf = new TextField(40); // 添加到窗体上 f.add(label); f.add(tf); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); // 给文本框添加事件 tf.addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { // 如果你取得的字符不是数字字符就取消事件 // 思路：先获取字符，判断字符，取消事件 // char getKeyChar() char ch = e.getKeyChar();// System.out.println(ch); if(!(ch&gt;=&apos;0&apos; &amp;&amp; ch&lt;=&apos;9&apos;)){ e.consume(); } } }); // 设置窗体可见 f.setVisible(true); }} 4.6 多级菜单4.6.1 菜单继承体系 4.6.1 多级菜单构成 MenuBar里面包含Menu,Menu里面包含MenuItem,MenuItem 里面定义监听事件。,注意Menu里面还可以包含Menu，构成多级菜单。 Demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.awt.FlowLayout;import java.awt.Frame;import java.awt.Menu;import java.awt.MenuBar;import java.awt.MenuItem;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.IOException;/* * 多级菜单 */public class FrameDemo { public static void main(String[] args) { // 创建窗体对象并设置属性 final Frame f = new Frame(&quot;多级菜单&quot;); f.setBounds(400, 200, 400, 300); f.setLayout(new FlowLayout()); final String name = f.getTitle(); // 创建菜单栏 MenuBar mb = new MenuBar(); // 创建菜单 Menu m1 = new Menu(&quot;文件&quot;); Menu m2 = new Menu(&quot;更改名称&quot;); // 创建菜单项 final MenuItem mi1 = new MenuItem(&quot;好好学习&quot;); final MenuItem mi2 = new MenuItem(&quot;天天向上&quot;); MenuItem mi3 = new MenuItem(&quot;恢复标题&quot;); MenuItem mi4 = new MenuItem(&quot;打开记事本&quot;); MenuItem mi5 = new MenuItem(&quot;退出系统&quot;); //Menu里面包含MenuItem m2.add(mi1); m2.add(mi2); m2.add(mi3); //Menu里面还可以包含Menu m1.add(m2); //Menu里面包含MenuItem m1.add(mi4); m1.add(mi5); //MenuBar里面包含Menu mb.add(m1); // 设置菜单栏 f.setMenuBar(mb); // 设置窗体关闭 f.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); mi1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.setTitle(mi1.getLabel()); } }); mi2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.setTitle(mi2.getLabel()); } }); mi3.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.setTitle(name); } }); mi4.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { Runtime r = Runtime.getRuntime(); try { r.exec(&quot;notepad&quot;); } catch (IOException e1) { e1.printStackTrace(); } } }); mi5.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.exit(0); } }); // 设置窗体可见 f.setVisible(true); }} 5. Netbeans工具 Netbean也是一款很好Java IDE，用来做swing或者awt界面，可以直接创建JPaner窗体和JFrame窗体，有非常方便的组件面板，可实现拖动编程，大大提高开发界面的效率。","link":"/2017/06/03/JAVA基础系列（九） GUI(图形界面编程)/"},{"title":"JAVA基础系列（二） 语法","text":"本文内容构架： 1.关键字&gt; 定义：被Java语言赋予特定含义的单词,组成关键字的字母全部小写&gt; 注：goto和const作为保留字在JDK的新版本中可能提升为关键字,但目前并不使用。## 2.标识符&gt; 定义：给变量,方法,类等起名字时使用的字符序列### 组成规则英文大小写字母数字字符$和_### 注意事项不能以数字开头不能是Java中的关键字区分大小写### 常见命名规则- 包(其实就是文件夹,用于解决相同类名问题)acamy,cn.acamy- 类或者接口Student,HelloWorld- 方法和变量name,main,studentName- 常量MAX,STUDENT_MAX_AGE## 3.注释&gt; 定义：用于解释说明程序的文字### 分类- #### 单行注释格式： // 注释文字- #### 多行注释格式：/* 注释文字 */- #### 文档注释格式：/** 注释文字 */ 注：对于单行和多行注释，不会被JVM解释执行.对于文档注释，注释内容可以被JDK提供的工具 javadoc 所解析,生成一套以网页文件形式体现的该程序的说明文档。## 4.常量&gt; 定义： 在程序执行的过程中其值不可以发生改变### 分类#### 字面值常量- (a) 字符串常量: 用双引号括起来的内容- (b) 整数常量: 所有整数 eg:12,23- (c) 小数常量: 所有小数 eg:12.34,56.78- (d) 字符常量: 用单引号括起来的内容 eg:‘a’,’A’,’0’- (e) 布尔常量: 较为特有，只有true和false- (f) 空常量: null(数组部分讲解)- (g)自定义常量(面向对象部分讲)## 5.变量&gt; 定义：在程序执行的过程中，在某个范围内其值可以发生改变的量,如同数学中的未知数### 格式数据类型 变量名 = 初始化值;## 6.数据类型&gt; 定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存总分配了不同大小的内存空间### 分类 注：String是字符串类### 大小### 转换boolean类型不能转换为其他的数据类型- #### 默认转换byte,short,char—int—long—float—doublebyte,short,char相互之间补转换，他们参与运算首先转换为int类型- #### 强制转换目标类型 变量名=(目标类型)(被转换的数据);## 7. 运算符### 7.1 算术运算符### 7.2 赋值运算符- 符号： = , +=, -=, =, /=, %==为基本的赋值运算符，其他的为扩展的赋值运算符### 7.3 比较运算符### 7.4 逻辑运算符- ### “&amp;”和“&amp;&amp;”的区别：单&amp;时，左边无论真假，右边都进行运算；双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。即遵循短路规则。 “|”和“||”的区别同理，双或时，左边为真，右边不参与运算。### 7.5 位运算符123&lt;&lt;：就是将左边的操作数在内存中的二进制数据左移右边操作数指定的位数，右边被移空的部分补0。相当于乘与2的倍数&gt;&gt;：右移稍微复杂一点，如果最高位是0，左边被移空的位就填入0；如果最高位是1，左边被移空的位就填入1。相当于除以2的倍数&gt;&gt;&gt;：无论最高位是1还是0，左边被移空的高位都填入0。 7.6 三目运算符 格式(关系表达式) ? 表达式1：表达式2；如果条件为true，运算后的结果是表达式1；如果条件为false，运算后的结果是表达式2； 示例：获取两个数中大数。12int x=3,y=4,z;`z = (x&gt;y)?x:y; //z变量存储的就是两个数的大数。 8.语句 8.1 顺序结构 定义： 程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。 总的来说： 写在前面的先执行，写在后面的后执行. 8.2 选择结构8.2.1 if语句 格式 12345678if(关系表达式1) { 语句体1; }else if (关系表达式2) { 语句体2; } else { 语句体n+1; } 流程图 8.2.3 switch语句123456789101112switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; } 流程图 注意事项: case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 default可以省略吗?可以省略。一般不建议。除非判断的值是固定的。(单选题) break可以省略吗?可以省略，一般不建议。否则结果可能不是你想要的 default的位置一定要在最后吗?可以出现在switch语句任意位置。 switch语句的结束条件遇到break执行到程序的末尾 8.3 循环结构 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。 循环语句的组成(a) 初始化语句：一条或者多条语句，这些语句完成一些初始化操作。(b)判断条件语句：这是一个boolean 表达式，这个表达式能决定是否执行循环体。(c) 循环体语句：这个部分是循环体语句，也就是我们要多次做的事情。(d)控制条件语句：这个部分在一次循环体结束后，下一次循环判断条件执行前执行。通过用于控制循环条件中的变量，使得循环在合适的时候结束。 8.3.1 for语句 格式 123for(初始化语句;判断条件语句;控制条件语句) { 循环体语句; } 执行流程图 #####注意事项(a)判断条件语句的结果是一个boolean类型(b)循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。(c)一般来说：有左大括号就没有分号，有分号就没有左大括号8.3.2 while语句 1234while(判断条件语句) { 循环体语句; 控制条件语句; } 流程图 8.3.3 do…while语句1234do { 循环体语句; 控制条件语句; } while((判断条件语句); -流程图 8.3.4 跳转和中断 break中断当前循环体， continue中断当前次循环，继续下次循环，return结束方法，返回到上层调用的方法.形象来说，这三者都是具有一定的杀伤力，大小排序为return &gt; break &gt; continue. 9.方法 方法就是完成特定功能的代码块 12345修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) { 函数体; return 返回值; }) 9.1 修饰符的访问能力 9.2 重载与重写(a)重载(overload) 让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重载Overloading是一个类中多态性的一种表现。 (b)重写（override) 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 . (c) 对比 10.数组 定义：数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 ###格式 12数据类型[] 数组名; //格式1数据类型 数组名[]; //格式2 ###初始化 12数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; // 静态初始化数据类型[] 数组名 = new 数据类型[数组长度]; //动态初始化 ###二维数组 定义：二维数组其实就是一个元素为一维数组的数组 1234567数据类型[][] 变量名 = new 数据类型[m][n];//格式1数据类型[][] 变量名 = new 数据类型[m][];//格式2数据类型[][] 变量名 = new 数据类型[][]{{元素…},{元素…},{元素…}};//格式3数据类型[][] 变量名 = {{元素…},{元素…},{元素…}};//格式3简化版 注：格式2和格式3都能构造出锯齿数组，即每行的元素个数可以不同。","link":"/2017/05/25/JAVA基础系列（二） 语法/"},{"title":"JAVA基础系列（十一）反射","text":"通过class文件对象，去使用该文件中的成员变量Field，构造方法Constructor，成员方法Method。 1.获取class文件对象 获取class文件对象的方式：1:Object类的getClass()方法2:数据类型的静态属性class3:Class.forName(String className); 注意：在开发是我们一般用第三种，因为第三种是一个字符串，而不是一个具体的类名。这样我们就可以把这样的字符串配置到配置文件中。 Demo:辅助类Person123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hust.jianshu.reflectDemos.acamy;public class Person { private String name; int age; public String address; public Person() { } private Person(String name) { this.name = name; } Person(String name, int age) { this.name = name; this.age = age; } public Person(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } public void show() { System.out.println(&quot;show&quot;); } public void method(String s) { System.out.println(&quot;method &quot; + s); } public String getString(String s, int i) { return s + &quot;---&quot; + i; } private void function() { System.out.println(&quot;function&quot;); } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &quot;]&quot;; }} Demo:获取class文件对象的几种方式123456789101112131415161718192021222324public class ReflectDemo { public static void main(String[] args) throws ClassNotFoundException { // 方式1 Person p = new Person(); Class c = p.getClass(); Person p2 = new Person(); Class c2 = p2.getClass(); System.out.println(p == p2);// false System.out.println(c == c2);// true // 方式2 Class c3 = Person.class; // int.class; // String.class; System.out.println(c == c3);//true // 方式3 // ClassNotFoundException Class c4 = Class.forName(&quot;com.hust.jianshu.reflectDemos.acamy.Person&quot;); System.out.println(c == c4);//true }} 2.获取构造方法 通过反射既可以获取公有构造方法，也可以暴力访问私有构造方法。同时可以单个获取，也可以批量获取。 Demo:通过反射获取构造方法并使用1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取字节码文件对象 Class c = Class.forName(&quot;com.hust.jianshu.reflectDemos.acamy.Person&quot;); // 获取多个构造方法 // public Constructor[] getConstructors():所有公共构造方法 // public Constructor[] getDeclaredConstructors():所有构造方法 Constructor[] cons = c.getDeclaredConstructors(); for (Constructor con : cons) { System.out.println(con); } // 获取单个构造方法 // 获取无参构造方法对象 // public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 参数表示的是：你要获取的构造方法的构造参数个数及数据类型的class字节码文件对象 Constructor con = c.getConstructor();// 返回的是构造方法对象 // public T newInstance(Object... initargs) // 使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。 Object obj = con.newInstance(); System.out.println(obj); // 获取带参构造方法对象 // public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) Constructor con1 = c.getConstructor(String.class, int.class, String.class); // 通过带参构造方法对象创建对象 // public T newInstance(Object... initargs) Object obj1 = con1.newInstance(&quot;林青霞&quot;, 27, &quot;北京&quot;); System.out.println(obj1); // 获取私有构造方法对象 // NoSuchMethodException：每个这个方法异常 // 原因是一开始我们使用的方法只能获取公共的，下面这种方式就可以了。 Constructor con2 = c.getDeclaredConstructor(String.class); // 用该私有构造方法创建对象 // IllegalAccessException:非法的访问异常。 // 暴力访问 con2.setAccessible(true);// 值为true则指示反射的对象在使用时应该取消Java语言访问检查。 Object obj2 = con2.newInstance(&quot;风清扬&quot;); System.out.println(obj2); }} ## 3.获取成员变量＞通过反射可以获取所有类型的成员变量，并且在创建对象后可以对获取的成员变量设置值 Demo:通过反射获取成员变量并使用123456789101112131415161718192021222324252627282930313233343536373839404142import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取字节码文件对象 Class c = Class.forName(&quot;com.hust.jianshu.reflectDemos.acamy.Person&quot;); // 获取多个的成员变量 // Field[] fields = c.getFields();所有公共成员变量 Field[] fields = c.getDeclaredFields();// 所有成员变量 for (Field field : fields) { System.out.println(field); } // 通过无参构造方法创建对象 Constructor con = c.getConstructor(); Object obj = con.newInstance(); System.out.println(obj); // 获取单个的成员变量 // 获取address并对其赋值 Field addressField = c.getField(&quot;address&quot;); // public void set(Object obj,Object value) // 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 addressField.set(obj, &quot;北京&quot;); // 给obj对象的addressField字段设置值为&quot;北京&quot; System.out.println(obj); // 获取name并对其赋值 // NoSuchFieldException Field nameField = c.getDeclaredField(&quot;name&quot;); // IllegalAccessException nameField.setAccessible(true); nameField.set(obj, &quot;林青霞&quot;); System.out.println(obj); // 获取age并对其赋值 Field ageField = c.getDeclaredField(&quot;age&quot;); ageField.setAccessible(true); ageField.set(obj, 27); System.out.println(obj); }} 4.获取成员方法 通过反射可以获取对象的所有类型成员变量，并调用 Demo:通过反射获取成员方法并使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取字节码文件对象 Class c = Class.forName(&quot;com.hust.jianshu.reflectDemos.acamy.Person&quot;); // 获取所有的方法 // Method[] methods = c.getMethods(); // 获取自己的包括父亲的公共方法 Method[] methods = c.getDeclaredMethods(); // 获取自己的所有的方法 for (Method method : methods) { System.out.println(method); } Constructor con = c.getConstructor(); Object obj = con.newInstance(); // 获取单个方法并使用 // public void show() // public Method getMethod(String name,Class&lt;?&gt;... parameterTypes) // 第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型 Method m1 = c.getMethod(&quot;show&quot;); // public Object invoke(Object obj,Object... args) // 返回值是Object接收,第一个参数表示对象是谁，第二参数表示调用该方法的实际参数 m1.invoke(obj); // 调用obj对象的m1方法 System.out.println(&quot;----------&quot;); // public void method(String s) Method m2 = c.getMethod(&quot;method&quot;, String.class); m2.invoke(obj, &quot;hello&quot;); System.out.println(&quot;----------&quot;); // public String getString(String s, int i) Method m3 = c.getMethod(&quot;getString&quot;, String.class, int.class); Object objString = m3.invoke(obj, &quot;hello&quot;, 100); System.out.println(objString); // String s = (String)m3.invoke(obj, &quot;hello&quot;,100); // System.out.println(s); System.out.println(&quot;----------&quot;); // private void function() Method m4 = c.getDeclaredMethod(&quot;function&quot;); m4.setAccessible(true); m4.invoke(obj); }} ##5.反射应用举例 5.1 通过反射越过泛型检查 集合里面的泛型是给编绎器看的，在编绎成字节码后已经去掉了该类型，变成时论的Object类型，可以通过反编绎工具验证一下。正是由于集合里面的泛型有这种机制，我们才可以利用反射得到字节码文件，越过泛型检查 Demo:在ArrayList集合中添加一个字符串数据1234567891011121314151617181920212223import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;public class ArrayListDemo { public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 创建集合对象 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // array.add(&quot;hello&quot;); array.add(10); Class c = array.getClass(); // 集合ArrayList的class文件对象 Method m = c.getMethod(&quot;add&quot;, Object.class); m.invoke(array, &quot;hello&quot;); // 调用array的add方法，传入的值是hello m.invoke(array, &quot;world&quot;); m.invoke(array, &quot;java&quot;); System.out.println(array); }} 5.2 反射工具类 Demo: 反射工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.lang.reflect.Field;public class ToolDemo { public static void main(String[] args) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { Person p = new Person(); Tool t = new Tool(); t.setProperty(p, &quot;name&quot;, &quot;林青霞&quot;); t.setProperty(p, &quot;age&quot;, 27); System.out.println(p); System.out.println(&quot;-----------&quot;); Dog d = new Dog(); t.setProperty(d, &quot;sex&quot;, &apos;男&apos;); t.setProperty(d, &quot;price&quot;, 12.34f); System.out.println(d); }}class Tool { public void setProperty(Object obj, String propertyName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { // 根据对象获取字节码文件对象 Class c = obj.getClass(); // 获取该对象的propertyName成员变量 Field field = c.getDeclaredField(propertyName); // 取消访问检查 field.setAccessible(true); // 给对象的成员变量赋值为指定的值 field.set(obj, value); }}class Dog { char sex; float price; @Override public String toString() { return sex + &quot;---&quot; + price; }}class Person { private String name; public int age; @Override public String toString() { return name + &quot;---&quot; + age; } 6.动态代理 代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。举例：春季回家买票让人代买动态代理：在程序运行过程中产生的这个对象,动态代理其实就是通过反射来生成一个代理 Demo:反射实现动态代理类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test { public static void main(String[] args) { UserDao ud = new UserDaoImpl(); System.out.println(ud.getClass().getName());// ...UserDaoImpl ud.add(); ud.delete(); ud.update(); ud.find(); System.out.println(&quot;-----------&quot;); // 我们要创建一个动态代理对象 // Proxy类中有一个方法可以创建动态代理对象 // 我准备对ud对象做一个代理对象 MyInvocationHandler handler = new MyInvocationHandler(ud); // public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] // interfaces,InvocationHandler h) // ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 // Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 // InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 UserDao proxy = (UserDao) Proxy.newProxyInstance(ud.getClass() .getClassLoader(), ud.getClass().getInterfaces(), handler); // 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型， // 也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式， // 以$开头，proxy为中，最后一个数字表示对象的标号。 System.out.println(proxy.getClass().getName());// ...$Proxy0 proxy.add(); proxy.delete(); proxy.update(); proxy.find(); }}// 每一个动态代理类都必须要实现InvocationHandler这个接口，// 并且每个代理类的实例都关联到了一个handler，// 当我们通过代理对象调用一个方法的时候，// 这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。class MyInvocationHandler implements InvocationHandler { private Object target; // 目标对象 public MyInvocationHandler(Object target) { this.target = target; } // proxy:代表动态代理对象 // method:代表正在执行的方法 // args:代表调用目标方法时传入的实参 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;权限校验&quot;); Object result = method.invoke(target, args); System.out.println(&quot;日志记录&quot;); return result; // 返回的是代理对象 }}class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(&quot;添加功能&quot;); } @Override public void delete() { System.out.println(&quot;删除功能&quot;); } @Override public void update() { System.out.println(&quot;修改功能&quot;); } @Override public void find() { System.out.println(&quot;查找功能&quot;); }}interface UserDao { public abstract void add(); public abstract void delete(); public abstract void update(); public abstract void find();}","link":"/2017/06/04/JAVA基础系列（十一）反射/"},{"title":"JAVA基础系列（十）网络编程","text":"用来实现网络互连的不同计算机上运行的程序间可以进行数据交换. 1.网络层次划分 为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。 除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示： 不同的层里面的内容和传输对象也不相同，参考如下图所示： 2.网络通信用要素 IP地址:InetAddress 网络中设备的标识，不易记忆，可用主机名 端口号 用于标识进程的逻辑地址，不同进程的标识 传输协议 通讯的规则 常见协议：TCP，UDP 2.1 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址 为了方便我们对IP地址的获取和操作，java提供了一个类InetAddress 供我们使用,常见用法参考下面的Demo:1234567891011121314151617import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressDemo { public static void main(String[] args) throws UnknownHostException { // public static InetAddress getByName(String host) // InetAddress address = InetAddress.getByName(&quot;liuyi&quot;); InetAddress address = InetAddress.getByName(&quot;192.168.1.4&quot;); // 获取两个东西：主机名，IP地址 // public String getHostName() String name = address.getHostName(); // public String getHostAddress() String ip = address.getHostAddress(); System.out.println(name + &quot;---&quot; + ip); }} 2.2 端口号 物理端口 网卡口逻辑端口 我们指的就是逻辑端口 A:每个网络程序都会至少有一个逻辑端口 B:用于标识进程的逻辑地址，不同进程的标识 C:有效端口：0~65535，其中0~1024系统使用或保留端口。 2.3 传输协议 指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则,常见的有UDP和TCP协议，它们之间的区别如下： ##3.Socket套接字 网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 3.1 Socket原理机制通信的两端都有Socket。网络通信其实就是Socket间的通信。数据在两个Socket间通过IO传输。 3.2 Socket机制图解 4.UDP传输 DatagramSocket与DatagramPacket建立发送端，接收端。建立数据包。调用Socket的发送接收方法。关闭Socket。发送端与接收端是两个独立的运行程序。 4.1 UDP传输-发送端思路 A:创建发送端Socket对象B:创建数据，并把数据打包C:调用Socket对象的发送方法发送数据包D:释放资源 Demo:12345678910111213141516171819202122import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class SendDemo { public static void main(String[] args) throws IOException { // 创建发送端的Socket对象 DatagramSocket ds = new DatagramSocket(); // 创建数据并打包 byte[] bys = &quot;helloworld&quot;.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(&quot;192.168.1.4&quot;), 12345); // 发送数据 ds.send(dp); // 释放资源 ds.close(); }} 4.2 UDP传输-接收端思路A:创建接收端Socket对象B:创建一个数据包(接收容器)C:调用Socket对象的接收方法接收数据D:解析数据包，并显示在控制台E:释放资源 Demo:123456789101112131415161718192021222324252627282930import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;/* * 多次启动接收端： * java.net.BindException: Address already in use: Cannot bind * 端口被占用。 */public class ReceiveDemo { public static void main(String[] args) throws IOException { // 创建接收端的Socket对象 DatagramSocket ds = new DatagramSocket(12345); // 创建一个包裹 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); // 接收数据 ds.receive(dp); // 解析数据 String ip = dp.getAddress().getHostAddress(); String s = new String(dp.getData(), 0, dp.getLength()); System.out.println(&quot;from &quot; + ip + &quot; data is : &quot; + s); // 释放资源 ds.close(); }} 4.3 UDP案例 从键盘录入数据进行发送，如果输入的是886那么客户端就结束输入数据。 接收端代码：1234567891011121314151617181920212223242526272829303132333435package com.hust.jianshu.netDemos.itcast_04;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;/* * 多次启动接收端： * java.net.BindException: Address already in use: Cannot bind * 端口被占用。 */public class ReceiveDemo { public static void main(String[] args) throws IOException { // 创建接收端的Socket对象 DatagramSocket ds = new DatagramSocket(12345); while (true) { // 创建一个包裹 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); // 接收数据 ds.receive(dp); // 解析数据 String ip = dp.getAddress().getHostAddress(); String s = new String(dp.getData(), 0, dp.getLength()); System.out.println(&quot;from &quot; + ip + &quot; data is : &quot; + s); } // 释放资源 // 接收端应该一直开着等待接收数据，是不需要关闭 // ds.close(); }} 发送端代码：12345678910111213141516171819202122232425262728293031323334353637import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * 数据来自于键盘录入 * 键盘录入数据要自己控制录入结束。 */public class SendDemo { public static void main(String[] args) throws IOException { // 创建发送端的Socket对象 DatagramSocket ds = new DatagramSocket(); // 封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; while ((line = br.readLine()) != null) { if (&quot;886&quot;.equals(line)) { break; } // 创建数据并打包 byte[] bys = line.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(&quot;192.168.1.4&quot;), 12345); // 发送数据 ds.send(dp); } // 释放资源 ds.close(); }} 5.TCP传输 Socket和ServerSocket建立客户端和服务器端建立连接后，通过Socket中的IO流进行数据的传输关闭socket同样，客户端与服务器端是两个独立的应用程序。 5.1 TCP传输-客户端思路1:建立客户端的Socket服务,并明确要连接的服务器。2:如果连接建立成功,就表明,已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入.该通道称为Socket流,Socket流中既有读取流,也有写入流.3:通过Socket对象的方法,可以获取这两个流4:通过流的对象可以对数据进行传输5:如果传输数据完毕,关闭资源 Demo:12345678910111213141516171819202122232425import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientDemo { public static void main(String[] args) throws IOException { // 创建客户端Socket对象 Socket s = new Socket(&quot;192.168.1.4&quot;, 9999); // 获取输出流 OutputStream os = s.getOutputStream(); os.write(&quot;今天天气很好,适合睡觉&quot;.getBytes()); // 获取输入流 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys);// 阻塞 String client = new String(bys, 0, len); System.out.println(&quot;client:&quot; + client); // 释放资源 s.close(); }} 5.2 TCP传输-服务端思路1:建立服务器端的socket服务，需要一个端口2:服务端没有直接流的操作,而是通过accept方法获取客户端对象，在通过获取到的客户端对象的流和客户端进行通信3:通过客户端的获取流对象的方法,读取数据或者写入数据4:如果服务完成,需要关闭客户端,然后关闭服务器，但是,一般会关闭客户端,不会关闭服务器,因为服务端是一直提供服务的 Demo:123456789101112131415161718192021222324252627282930import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerDemo { public static void main(String[] args) throws IOException { // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(9999); // 监听客户端的连接 Socket s = ss.accept(); // 阻塞 // 获取输入流 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); // 阻塞 String server = new String(bys, 0, len); System.out.println(&quot;server:&quot; + server); // 获取输出流 OutputStream os = s.getOutputStream(); os.write(&quot;数据已经收到&quot;.getBytes()); // 释放资源 s.close(); // ss.close(); }} 5.3 TCP传输案例 客户端发送文本文件，服务端接收文本文件 服务端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class UploadServer { public static void main(String[] args) throws IOException { // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(11111); while (true) { Socket s = ss.accept(); //单独开启一个线程以处理多个客户端同时发送文件 new Thread(new UserThread(s)).start(); } }}class UserThread implements Runnable { private Socket s; public UserThread(Socket s) { this.s = s; } @Override public void run() { try { // 封装通道内的流 BufferedReader br = new BufferedReader(new InputStreamReader( s.getInputStream())); // 封装文本文件 // BufferedWriter bw = new BufferedWriter(new // FileWriter(&quot;Copy.java&quot;)); // 为了防止名称冲突 String newName = System.currentTimeMillis() + &quot;.java&quot;; BufferedWriter bw = new BufferedWriter(new FileWriter(newName)); String line = null; while ((line = br.readLine()) != null) { // 阻塞 bw.write(line); bw.newLine(); bw.flush(); } // 给出反馈 BufferedWriter bwServer = new BufferedWriter( new OutputStreamWriter(s.getOutputStream())); bwServer.write(&quot;文件上传成功&quot;); bwServer.newLine(); bwServer.flush(); // 释放资源 bw.close(); s.close(); } catch (IOException e) { e.printStackTrace(); } }} 客户端代码：12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class UploadClient { public static void main(String[] args) throws IOException { // 创建客户端Socket对象 Socket s = new Socket(&quot;192.168.1.4&quot;, 11111); // 封装文本文件 // BufferedReader br = new BufferedReader(new FileReader( // &quot;InetAddressDemo.java&quot;)); BufferedReader br = new BufferedReader(new FileReader( &quot;ReceiveDemo.java&quot;)); // 封装通道内流 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( s.getOutputStream())); String line = null; while ((line = br.readLine()) != null) { // 阻塞 bw.write(line); bw.newLine(); bw.flush(); } // Socket提供了一个终止，它会通知服务器你别等了，我没有数据过来了 s.shutdownOutput(); // 接收反馈 BufferedReader brClient = new BufferedReader(new InputStreamReader( s.getInputStream())); String client = brClient.readLine(); // 阻塞 System.out.println(client); // 释放资源 br.close(); s.close(); }}","link":"/2017/06/04/JAVA基础系列（十）网络编程/"},{"title":"JavaWeb基础之Cookie与Session","text":"Cookie:Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。Session:Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务。 1.javax.servlet.http.Cookie Java提供操作Cookie的API 1.1 演示Cookie的创建与使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CookieDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.创建Cookie对象 Cookie cookie1 = new Cookie(&quot;name&quot;,&quot;eric&quot;); /** * 1）设置cookie的有效路径。默认情况：有效路径在当前web应用下。 /demo *有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下 *访问服务器时就会带着cookie信息，否则不带cookie信息。 */ //cookie1.setPath(&quot;/demo&quot;); /** * 2)设置cookie的有效时间 * 正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的时间。 负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失了！！ 零：表示删除同名的cookie数据 */ //cookie1.setMaxAge(20); //20秒，从最后不调用cookie开始计算 cookie1.setMaxAge(-1); //cookie保存在浏览器内存（会话cookie） //cookie1.setMaxAge(0); //2.把cookie数据发送到浏览器（通过响应头发送： set-cookie名称） //response.setHeader(&quot;set-cookie&quot;, cookie.getName()+&quot;=&quot;+cookie.getValue()+&quot;,email=eric@qq.com&quot;); //推荐使用这种方法，避免手动发送cookie信息 response.addCookie(cookie1); //3.接收浏览器发送的cookie信息 /*String name = request.getHeader(&quot;cookie&quot;); System.out.println(name);*/ Cookie[] cookies = request.getCookies(); //注意：判断null,否则空指针 if(cookies!=null){ //遍历 for(Cookie c:cookies){ String name = c.getName(); String value = c.getValue(); System.out.println(name+&quot;=&quot;+value); } }else{ System.out.println(&quot;没有接收cookie数据&quot;); } }} 1.2. Cookie的使用实例，用户上次访问时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HistServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); // 获取当前时间 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); String curTime = format.format(new Date()); // 取得cookie Cookie[] cookies = request.getCookies(); String lastTime = null; if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equals(&quot;lastTime&quot;)) { // 有lastTime的cookie，已经是第n次访问 lastTime = cookie.getValue();// 上次访问的时间 // 第n次访问 // 1.把上次显示时间显示到浏览器 response.getWriter().write( &quot;欢迎回来，你上次访问的时间为：&quot; + lastTime + &quot;,当前时间为：&quot; + curTime); // 2.更新cookie cookie.setValue(curTime); cookie.setMaxAge(1 * 30 * 24 * 60 * 60); // 3.把更新后的cookie发送到浏览器 response.addCookie(cookie); break; } } } /** * 第一次访问（没有cookie 或 有cookie，但没有名为lastTime的cookie） */ if (cookies == null || lastTime == null) { // 1.显示当前时间到浏览器 response.getWriter().write(&quot;你是首次访问本网站，当前时间为：&quot; + curTime); // 2.创建Cookie对象 Cookie cookie = new Cookie(&quot;lastTime&quot;, curTime); cookie.setPath(&quot;/CookieDemo&quot;); cookie.setMaxAge(-1);// 设置浏览器关闭cookie就丢失 // cookie.setMaxAge(1*30*24*60*60);//保存一个月 // 3.把cookie发送到浏览器保存 response.addCookie(cookie); } }} 效果如下： 注意：浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 2. javax.servlet.http.HttpSession Java提供操作Session的API,服务器在浏览器第一次访问时如果创建了一个Session对象就会给该对象分配一个id并以Cookie的形式保存在浏览器中，以后在有效期内浏览器访问服务器时就会带着该id,服务器通过该id就能匹配到存储在服务器中对应的信息。 2.1 Sesision的存储原理Demo:12345678910111213141516171819202122232425262728public class SessionDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setCharacterEncoding(&quot;UTF=8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); // 使用request对象的getSession()获取session，如果session不存在则创建一个 HttpSession session = request.getSession(); // 将数据存储到session中 session.setAttribute(&quot;data&quot;, &quot;acamy&quot;); // 获取session的Id String sessionId = session.getId(); // 判断session是不是新创建的 response.getWriter().println(new Date()); if (session.isNew()) { response.getWriter().print(&quot;session创建成功，session的id是：&quot; + sessionId); } else { response.getWriter().print( &quot;服务器已经存在该session了，session的id是：&quot; + sessionId); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); }} 效果如下： 2.2.浏览器禁用Cookie后的session处理 当我们想实现提供用户浏览过的商品时，利用上面的Cookie和Session思想很容易实现，但是如果浏览器作了上图中的设置，也就是禁用了Cookie,我们又该如何实现呢，这就需要用到URL重写： 用于对sendRedirect方法后的url地址进行重写。response.encodeRedirectURL(java.lang.String url) //用于对表单action和超链接的url地址进行重写response.encodeURL(java.lang.String url) String javax.servlet.http.HttpServletResponse.encodeURL(String url)Encodes the specified URL by including the session ID in it, or, if encoding is not needed, returns the URL unchanged. The implementation of this method includes the logic to determine whether the session ID needs to be encoded in the URL. For example, if the browser supports cookies, or session tracking is turned off, URL encoding is unnecessary.看了上面官方对该方法的解释就是对特定的URL添加session ID进行编码，如果不需要的话就不会对URL作任何改变。所有对该方法的实现应该包含判断session ID的信息是否需要添加到URL里面对URL作改变的逻辑。例如，如果浏览器支持cookies,或者session跟踪关了的话，就不对URL作改变。 下面看实例源码： IndexServlet:首页，列出所有书12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class IndexServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); // 创建Session request.getSession(); out.write(&quot;本网站有如下书：&lt;br/&gt;&quot;); Set&lt;Map.Entry&lt;String, Book&gt;&gt; set = DB.getAll().entrySet(); for (Map.Entry&lt;String, Book&gt; me : set) { Book book = me.getValue(); String url = request.getContextPath() + &quot;/buyServlet?id=&quot; + book.getId(); // response. encodeURL(java.lang.String // url)用于对表单action和超链接的url地址进行重写，通过此方法带上JSESSSIONID url = response.encodeURL(url);// 将超链接的url地址进行重写 out.println(book.getName() + &quot; &lt;a href=&apos;&quot; + url + &quot;&apos;&gt;购买&lt;/a&gt;&lt;br/&gt;&quot;); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); }}/** * @author gacl 模拟数据库 */class DB { private static Map&lt;String, Book&gt; map = new LinkedHashMap&lt;String, Book&gt;(); static { map.put(&quot;1&quot;, new Book(&quot;1&quot;, &quot;javaweb开发&quot;)); map.put(&quot;2&quot;, new Book(&quot;2&quot;, &quot;spring开发&quot;)); map.put(&quot;3&quot;, new Book(&quot;3&quot;, &quot;hibernate开发&quot;)); map.put(&quot;4&quot;, new Book(&quot;4&quot;, &quot;struts开发&quot;)); map.put(&quot;5&quot;, new Book(&quot;5&quot;, &quot;ajax开发&quot;)); } public static Map&lt;String, Book&gt; getAll() { return map; }}class Book { private String id; private String name; public Book() { super(); } public Book(String id, String name) { super(); this.id = id; this.name = name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }} BuyServlet:点击购买后的逻辑12345678910111213141516171819202122232425262728public class BuyServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String id = request.getParameter(&quot;id&quot;); Book book = DB.getAll().get(id); // 得到用户想买的书 HttpSession session = request.getSession(); HashSet&lt;Book&gt; set = (HashSet) session.getAttribute(&quot;set&quot;); // 得到用户用于保存所有书的容器 if (set == null) { set = new HashSet&lt;Book&gt;(); session.setAttribute(&quot;set&quot;, set); } set.add(book); // response. encodeRedirectURL(java.lang.String // url)用于对sendRedirect方法后的url地址进行重写 String url = request.getContextPath() + &quot;/listCartServlet&quot;; url = response.encodeRedirectURL(url);//通过此方法带上JSESSSIONID System.out.println(url); response.sendRedirect(url); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); }} ListCartServlet:购物车页面1234567891011121314151617181920212223242526public class ListCartServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter out = response.getWriter(); HttpSession session = request.getSession(); HashSet&lt;Book&gt; set = (HashSet) session.getAttribute(&quot;set&quot;); if (set == null || set.size() == 0) { out.write(&quot;对不起，您还没有购买任何商品!!&quot;); return; } // 显示用户买过的商品 out.write(&quot;您买过如下商品:&lt;br&gt;&quot;); for (Book book : set) { out.write(book.getName() + &quot;&lt;br/&gt;&quot;); } } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); }} 查看首页源码如下： 但当我们刷新列表页时会发现URL里面带的JSESSSIONID已经改变，购物车页面也会清空，所以并不能实现完全没禁用Cookie效果。 当我们开启Cookie时，只有在第一次访问列表页面时会有JSESSSIONID的信息,但我们刷新列表页面时，购物车页面没有清空，页面源码如下所示，没有了JSESSSIONID的信息，证明了encode方法的智能性。 2.3 session对象的销毁时机 session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间，例如： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 设置Session的有效时间:以分钟为单位--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。123HttpSession session = request.getSession();//手工调用session.invalidate方法，摧毁sessionsession.invalidate();","link":"/2017/06/06/JavaWeb基础之Cookie与Session/"},{"title":"JavaWeb基础之JSP初探","text":"JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术，jsp文件相当于在html页面嵌套java代码，即方便排版又为用户提供了动态数据。 1. 第一个JSP页面 如下所示，我们在..WebRoot目录下面定义firstJSP.jsp并写下内容，布置到tomcat服务器后我们就可以像访问静态html页面一样去访问该页面。 12345678910111213141516171819&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.text.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个jsp页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% //写java代码 //获取当前时间 SimpleDateFormat sdf = new SimpleDateFormat(); String curDate = sdf.format(new Date()); //输出内容到浏览器 //response.getWriter().write(&quot;&quot;); out.write(&quot;当前时间为：&quot;+curDate); %&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： 2.JSP页面执行过程 我们接下来看下JSP页面是如何编绎嵌套在html里面的代码，并向浏览器输出。首先，tomcat服务器在浏览器每一次访问时就将jsp文件翻译成java文件，并把java文件编绎成class字节码文件，我们在tomcat的work对应项目目录下可以找到这两个文件： 然后看一下firstJSP_jsp.java里面的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* * Generated by the Jasper component of Apache Tomcat * Version: Apache Tomcat/7.0.57 * Generated at: 2017-06-07 11:33:50 UTC * Note: The last modified time of this file was set to * the last modified time of the source file after * generation to assist with modification tracking. */package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.*;import java.text.*;public final class firstJSP_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private javax.el.ExpressionFactory _el_expressionfactory; private org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() { return _jspx_dependants; } public void _jspInit() { _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); } public void _jspDestroy() { } public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try { response.setContentType(&quot;text/html;charset=utf-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\\r\\n&quot;); out.write(&quot;&lt;!DOCTYPE HTML PUBLIC \\&quot;-//W3C//DTD HTML 4.01 Transitional//EN\\&quot;&gt;\\r\\n&quot;); out.write(&quot;&lt;html&gt;\\r\\n&quot;); out.write(&quot; &lt;head&gt; \\r\\n&quot;); out.write(&quot; &lt;title&gt;第一个jsp页面&lt;/title&gt; \\r\\n&quot;); out.write(&quot; &lt;/head&gt;\\r\\n&quot;); out.write(&quot; \\r\\n&quot;); out.write(&quot; &lt;body&gt;\\r\\n&quot;); out.write(&quot; &quot;); //写java代码 //获取当前时间 SimpleDateFormat sdf = new SimpleDateFormat(); String curDate = sdf.format(new Date()); //输出内容到浏览器 //response.getWriter().write(&quot;&quot;); out.write(&quot;当前时间为：&quot;+curDate); out.write(&quot;\\r\\n&quot;); out.write(&quot; &lt;/body&gt;\\r\\n&quot;); out.write(&quot;&lt;/html&gt;\\r\\n&quot;); } catch (java.lang.Throwable t) { if (!(t instanceof javax.servlet.jsp.SkipPageException)){ out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try { if (response.isCommitted()) { out.flush(); } else { out.clearBuffer(); } } catch (java.io.IOException e) {} if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); } } finally { _jspxFactory.releasePageContext(_jspx_page_context); } }} 通过上面的源码知道翻译成的java文件是一个HttpJspBase类，查看API可知该类继承于HttpServlet，到此为止我们基本上可以下一个结论：Jsp就是一个servlet程序当我们每次访问JSP页面时就会执行类里面的_jspService方法，可以看到这个方法包含了JSP页面的所有内容。并且放在一个try代码块里面。同Servlet的生命周期类似，该类的构造方法和_jspInit()方法只在每一次访问时执行，在tomcat服务器重新布署时执行_jspDestroy()方法。 将JSP页面的执行过程用流程图的形式总结如下： 3.JSP语法3.1 Jsp模板jsp页面中的html代码就是jsp的模板 3.2 Jsp表达式语法：&lt;%=变量或表达式%&gt;举例：作用： 向浏览器输出变量的值或表达式计算的结果注意：1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容2）表达式后面不需要带分号结束。 3.3 Jsp的脚本语法：&lt;%java代码 %&gt;作用： 执行java代码注意：1）原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 3.4 Jsp的声明语法：&lt;%! 变量或方法 %&gt;作用： 声明jsp的变量或方法注意:1）变量翻译成成员变量，方法翻译成成员方法。 3.5 Jsp的注释语法： &lt;%!– jsp注释 –%&gt;注意;1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 ##4 Jsp的三大指令 4.1 include指令作用： 在当前页面用于包含其他页面语法： &lt;%@include file=”common/header.jsp”%&gt;注意：1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一个java源文件，再编译运行！！，这种包含叫静态包含（源码包含）2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、 body） 4.2 page指令作用： 告诉tomcat服务器如何翻译jsp文件语法：&lt;%@ pagelanguage=”java” –告诉服务器使用什么动态语言来翻译jsp文件import=”java.util.*” –告诉服务器java文件使用什么包,导入包，多个包之间用逗号分割pageEncoding=”utf-8” –告诉服务器使用什么编码翻译jsp文件（成java文件）contentType=”text/html; charset=utf-8” 服务器发送浏览器的数据类型和内容编码注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题errorPage: 指定当前jsp页面的错误处理页面。isErorrPage: 指定当前页面是否为错误处理页面。false，不是错误处理页面，则不能使用 exception内置对象；true，是错误处理页面，可以使用exception内置对象。配置全局的错误处理页面可在web.xml添加如下内容：123456789&lt;!-- 全局错误处理页面配置 --&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/common/500.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/common/404.html&lt;/location&gt;&lt;/error-page&gt; session: 是否开启session功能。false，不能用session内置对象；true，可以使用session内置对象。buffer: jsp页面的缓存区大小。isELIgnore： 是否忽略EL表达式。%&gt; 4.3 taglib指令 Taglib指令用于在JSP页面中导入标签库,后面再看 ##5.JSP基本组成语法实例 header.jsp:用于测试include指令12&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt; 头部页面的内容 script.jsp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!-- page指令 --&gt;&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Jsp语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- include指令 --&gt; &lt;%@include file=&quot;common/header.jsp&quot;%&gt; &lt;!-- jsp表达式 --&gt; &lt;% //变量 String name = &quot;acamy&quot;; int a = 10; int b =20; %&gt; &lt;%=name %&gt; &lt;br/&gt; &lt;%=(a-b) %&gt; &lt;hr/&gt; &lt;!-- jsp脚本 --&gt; &lt;% //生成随机数 Random ran = new Random(); float num = ran.nextFloat(); %&gt; 随机小数：&lt;%=num %&gt; &lt;hr/&gt; &lt;!-- 穿插html代码 --&gt; &lt;% for(int i=1;i&lt;=6;i++){ %&gt; &lt;h&lt;%=i %&gt;&gt;标题&lt;%=i %&gt;&lt;/h&lt;%=i %&gt;&gt; &lt;% } %&gt; &lt;hr/&gt; &lt;!-- 练习： 使用脚本和html代码显示99乘法表 --&gt; &lt;% for(int i=1;i&lt;=9;i++){//行 for(int j=1;j&lt;=i;j++){//公式 %&gt; &lt;%=i %&gt; x &lt;%=j %&gt;=&lt;%=(i*j) %&gt; &lt;% } %&gt; &lt;br/&gt; &lt;% } %&gt; &lt;% String age = &quot;20&quot;; /* 脚本中不能声明方法 public String getAge(){ return age; } */ %&gt; &lt;!-- jsp声明 --&gt; &lt;%! //变量 String name = &quot;jacky&quot;; public String getName(){ return name; } /*jsp声明中不能重复定义翻译好的一些方法 public void _jspInit(){ } */ %&gt; &lt;!-- html注释 --&gt; &lt;%-- &lt;jsp:forward page=&quot;/01.hello.jsp&quot;&gt;&lt;/jsp:forward&gt; --%&gt; &lt;%-- jsp注释 --%&gt; &lt;/body&gt;&lt;/html&gt; 效果如下：","link":"/2017/06/07/JavaWeb基础之JSP初探/"},{"title":"JavaWeb基础之JSP标签","text":"标签的作用是用来替换jsp脚本，将脚本封装在类里面。 1.内置标签 也称动作标签，不需要在jsp页面导入，分为转发标签，参数标签，包含标签，具体使用语法如下： 12345678910111213 &lt;%--转发标签和参数标签 &lt;jsp:forward page=&quot;forward.jsp&quot;&gt;&lt;!-- more --&gt; &lt;jsp:param value=&quot;jacky&quot; name=&quot;name&quot;/&gt; &lt;jsp:param value=&quot;123456&quot; name=&quot;password&quot;/&gt; &lt;/jsp:forward&gt; --%&gt; &lt;%--包含标签 --%&gt; &lt;%-- &lt;jsp:include page=&quot;/common/header.jsp&quot;&gt; &lt;jsp:param value=&quot;lucy&quot; name=&quot;name&quot;/&gt; &lt;/jsp:include&gt; --%&gt; 注意：这里面的包含标签称为动态包含，而前面讲的jsp指定中的include指定为静态包含。两者区分如下： 2.jstl标签 JSTL (全名:Java Standard Tag Library -java标准标签库 )包括：核心标签库 （c标签库） 天天用国际化标签（fmt标签库）EL函数库（fn函数库）xml标签库（x标签库）sql标签库（sql标签库） 使用JSTL标签步骤1） 导入jstl支持的jar包（标签背后隐藏的java代码） 注意：使用javaee5.0的项目自动导入jstl支持jar包2）使用taglib指令导入标签库 &lt;%@taglib uri=”tld文件的uri名称” prefix=”简写” %&gt;3）在jsp中使用标签 核心标签库的重点标签：1.保存数据： &lt;c:set&gt;&lt;/c:set&gt; 2.获取数据： &lt;c:out value=””&gt;&lt;/c:out&gt;3.单条件判断 &lt;c:if test=””&gt;&lt;/c:if&gt;4.多条件判断 &lt;c:choose&gt;&lt;/c:choose&gt; &lt;c:when test=””&gt;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;/c:otherwise&gt;5.循环数据 &lt;c:forEach&gt;&lt;/c:forEach&gt; &lt;c:forTokens items=”” delims=””&gt;&lt;/c:forTokens&gt;5.重定向 &lt;c:redirect&gt;&lt;/c:redirect&gt; 实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,gz.itcast.b_entity.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%--导入标签库 --%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;核心标签库&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用标签 --%&gt; &lt;%--set标签 :保存数据(保存到域中)默认保存到page域 --%&gt; &lt;c:set var=&quot;name&quot; value=&quot;rose&quot; scope=&quot;request&quot;&gt;&lt;/c:set&gt; &lt;% String msg = null; pageContext.setAttribute(&quot;msg&quot;,msg); %&gt; ${msg } &lt;br/&gt; &lt;%--out标签： 获取数据（从域中） default： 当value值为null时，使用默认值 escapeXml: 是否对value值进行转义，false，不转义，true，转义（默认） --%&gt; &lt;c:out value=&quot;${msg}&quot; default=&quot;&lt;h3&gt;标题3&lt;/h3&gt;&quot; escapeXml=&quot;true&quot;&gt;&lt;/c:out&gt; &lt;hr/&gt; &lt;%--if标签 ：单条件判断--%&gt; &lt;c:if test=&quot;${!empty msg}&quot;&gt; 条件成立 &lt;/c:if&gt; &lt;hr/&gt; &lt;%--choose标签+when标签+otherwirse标签: 多条件判断 --%&gt; &lt;c:set var=&quot;score&quot; value=&quot;56&quot;&gt;&lt;/c:set&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${score&gt;=90 &amp;&amp; score&lt;=100}&quot;&gt; 优秀 &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;=80 &amp;&amp; score&lt;90}&quot;&gt; 良好 &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;=70 &amp;&amp; score&lt;80}&quot;&gt; 一般 &lt;/c:when&gt; &lt;c:when test=&quot;${score&gt;=60 &amp;&amp; score&lt;70}&quot;&gt; 及格 &lt;/c:when&gt; &lt;c:otherwise&gt; 不及格 &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;%-- forEach标签：循环 --%&gt; &lt;% //List List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,28)); list.add(new Student(&quot;lucy&quot;,38)); //放入域中 pageContext.setAttribute(&quot;list&quot;,list); //Map Map&lt;String,Student&gt; map = new HashMap&lt;String,Student&gt;(); map.put(&quot;100&quot;,new Student(&quot;mark&quot;,20)); map.put(&quot;101&quot;,new Student(&quot;maxwell&quot;,30)); map.put(&quot;102&quot;,new Student(&quot;narci&quot;,40)); //放入域中 pageContext.setAttribute(&quot;map&quot;,map); %&gt; &lt;hr/&gt; &lt;%-- begin=&quot;&quot; : 从哪个元素开始遍历，从0开始.默认从0开始 end=&quot;&quot;: 到哪个元素结束。默认到最后一个元素 step=&quot;&quot; ： 步长 (每次加几) ，默认1 items=&quot;&quot;： 需要遍历的数据（集合） var=&quot;&quot;： 每个元素的名称 varStatus=&quot;&quot;： 当前正在遍历元素的状态对象。（count属性：当前位置，从1开始） --%&gt; &lt;c:forEach items=&quot;${list}&quot; var=&quot;student&quot; varStatus=&quot;varSta&quot;&gt; 序号：${varSta.count} - 姓名：${student.name } - 年龄：${student.age}&lt;br/&gt; &lt;/c:forEach&gt; &lt;hr/&gt; &lt;c:forEach items=&quot;${map}&quot; var=&quot;entry&quot;&gt; ${entry.key } - 姓名： ${entry.value.name } - 年龄：${entry.value.age }&lt;br/&gt; &lt;/c:forEach&gt; &lt;hr/&gt; &lt;%-- forToken标签： 循环特殊字符串 --%&gt; &lt;% String str = &quot;java-php-net-平面&quot;; pageContext.setAttribute(&quot;str&quot;,str); %&gt; &lt;c:forTokens items=&quot;${str}&quot; delims=&quot;-&quot; var=&quot;s&quot;&gt; ${s }&lt;br/&gt; &lt;/c:forTokens&gt; &lt;%--redrict:重定向 --%&gt; &lt;c:redirect url=&quot;http://www.baidu.com&quot;&gt;&lt;/c:redirect&gt; &lt;/body&gt;&lt;/html&gt; 3.自定义标签 通过自定义标签，可以个性化的实现一些功能。开发步骤如下： 需求： 通过自定义标签向浏览器输出当前客户的IP地址1）编写一个普通的java类，继承SimpleTagSupport类，叫标签处理器类1234567891011121314151617181920212223242526272829303132333435/** * 标签处理器类 * @author APPle * 1）继承SimpleTagSupport * */public class ShowIpTag extends SimpleTagSupport{ private JspContext context; /** * 传入pageContext */ @Override public void setJspContext(JspContext pc) { this.context = pc; } /** * 2）覆盖doTag方法 */ @Override public void doTag() throws JspException, IOException { //向浏览器输出客户的ip地址 PageContext pageContext = (PageContext)context; HttpServletRequest request = (HttpServletRequest)pageContext.getRequest(); String ip = request.getRemoteHost(); JspWriter out = pageContext.getOut(); out.write(&quot;使用自定义标签输出客户的IP地址：&quot;+ip); }} 2）在web项目的WEB-INF目录下建立myTag.tld文件，这个tld叫标签库的声明文件。（参考核心标签库的tld文件）1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;!-- 标签库的版本 --&gt; &lt;tlib-version&gt;1.1&lt;/tlib-version&gt; &lt;!-- 标签库前缀 --&gt; &lt;short-name&gt;myTag&lt;/short-name&gt; &lt;!-- tld文件的唯一标记 --&gt; &lt;uri&gt;http://gz.acamy.cn&lt;/uri&gt; &lt;!-- 一个标签的声明 --&gt; &lt;tag&gt; &lt;!-- 标签名称 --&gt; &lt;name&gt;showIp&lt;/name&gt; &lt;!-- 标签处理器类的全名 --&gt; &lt;tag-class&gt;gz.itcast.a_tag.ShowIpTag&lt;/tag-class&gt; &lt;!-- 输出标签体内容格式 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 3） 在jsp页面的头部导入自定义标签库 &lt;%@taglib uri=&quot;http://gz.acamy.cn&quot; prefix=&quot;myTag&quot;%&gt;4） 在jsp中使用自定义标签 &lt;myTag:showIp&gt;&lt;/myTag:showIp&gt; 效果如下： 执行过程：前提： tomcat服务器启动时，加载到每个web应用，加载每个web应用的WEB-INF目录下的所有文件！！！例如。web.xml, tld文件！！！1）访问01.hellotag.jsp资源2）tomcat服务器把jsp文件翻译成java源文件-&gt;编译class-&gt;构造类对象-&gt;调用_jspService（）方法3）检查jsp文件的taglib指令，是否存在一个名为http://gz.acamy.cn的tld文件。如果没有，则报错4）上一步已经读到myTag.tld文件5）读到myTag:showIp 到myTag.tld文件中查询是否存在为showIp的标签6）找到对应的标签，则读到内容7）得到 cn.acamy.a_tag.ShowIpTag,构造ShowIpTag对象，然后调用ShowIpTag里面的方法","link":"/2017/06/08/JavaWeb基础之JSP标签/"},{"title":"Java内存模型","text":"Java Memory Model，通过定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节，屏蔽掉各种硬件和操作系统的内存访问差异。 1.JMM的抽象结构 如下图所示，线程之间的共享变量(实例域，静态域和数组元素)存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory),本地内存中存储了该线程以读/写共享变量的副本。JMM决定一个线程对共享变量的写入何时对另一个线程可见。 在上图中，如果线程A和线程B要进行通信，必须要经历以下两个步骤：1) 线程A把本地内存中A中更新近的共享变量刷新到主内存中去。2) 线程B到主内存中去读取线程A之前已更新过的共享变量。 2.内存间的交互操作 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 3.重排序 重排序是指编绎器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序分为编译器优化的重排序，指令级并行的重排序和内存系统的重排序。从Java源代码到最终实际执行的指令序列，会分别经历这3种重排序，如下所示： 上图中的1属于编绎器重排序，2和3属于处理器重排序。 3.1 内存屏障 Memory Barrier，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：1、保证特定操作的执行顺序。2、影响某些数据（或则是某条指令的执行结果）的内存可见性。 为了保证内存可见性，Java编绎器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障分为4类，如下所示： 3.2 happens-before 从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。 在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。 与程序员密切相关的happens-before规则如下：1、程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。2、监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。3、volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。4、传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。 注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。 3.3 数据依赖性 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖性分为下列3种类型，如下所示： 对于上面的3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。编绎器和处理器在重排序时，会遵守数据依赖性，而不会改变存在数据依赖关系的两个操作的执行顺序。 3.4 as-if-serial as-if-serial语义的意思是：不管怎么重排序（编绎器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编绎器，runtime和处理器都必须遵守as-if-serial语义。 3.5 示例为了具体说明，请看下面计算圆面积的代码示例： 123double pi = 3.14; //Adouble r = 1.0; //Bdouble area = pi * r * r; //C 上面3个操作的数据依赖关系如下图所示： A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。下图是该程序的两种执行顺序: 3.6 重排序对多线程的影响先看如下示例代码：12345678910111213141516class ReorderExample { int a = 0; boolean flag = false; public void writer() { a = 1; //1 flag = true; //2 } public void reader() { if (flag) { //3 int i = a * a; //4 //s…… } }} flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？答案是：不一定能看到。由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作1和操作2重排序时，可能会产生什么效果？请看下面的程序执行时序图，如下图所示： 上图中操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，在里多线程程序的语义被重排序破坏了！ 下面再让我们看看，当操作3和操作4重排序时会产生什么效果（借助这个重排序，可便说明控制依赖性）。下面是操作3和操作4重排序后，程序执行的时序图，如下图所示: 在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条件判断为真时，就把该计算结果写入变量i中。 从上图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！ 通过上例可以得出结论：在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。","link":"/2017/06/30/Java内存模型/"},{"title":"SpringBoot2.0学习(四)-MyBatis","text":"MyBatis是一款优秀的持久层构架，它支持定制化SQL语句、存储过程以及高级映射，可以通过简单的XML或注解配置和映射原生信息，将POJOs映射成数据库中的记录，从而方便进行增删改查的操作(官网)。本文会分别介绍通过XML、自动生成、注解三种传统使用MyBatis的方式以及在SpringBoot中使用MyBatis。 GitHub源码地址 1. XML配置方式使用MyBatis1.1 引入依赖(jdbc,mysql,mybatis)1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1.2 配置数据库连接信息resources:mybatis/mybatis.properties1234jdbc.driver-class=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=123456jdbc.url=jdbc:mysql://localhost:3306/test 1.3 配置Mybatisresources:mybatis/mybatis-config.xml12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;mybatis/mybatis.properties&quot; /&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver-class}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.4 配置映射信息resources:mybatis/mappers/UserMapper.xml123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.hebaohua.springbootmybatis.mappers.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.hebaohua.springbootmybatis.entity.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt;&lt;/mapper&gt; 1.5运行测试12345678910111213141516public class XmlConfigDemo { public static void main(String[] args) throws IOException { ResourceLoader resourceLoader = new DefaultResourceLoader(); Resource resource = resourceLoader.getResource(&quot;classpath:/mybatis/mybatis-config.xml&quot;); InputStream inputStream = resource.getInputStream(); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); try { User user = session.selectOne(&quot;com.hebaohua.springbootmybatis.mappers.UserMapper.selectUser&quot;, 4); System.out.println(user); } finally { session.close(); } }} 运行效果: 2. 使用MyBatis配置生成器此处只讲解在idea中使用maven连接Mysql的配置方式, 其它可以查看网址. 2.1 首先添加Maven插件123456789101112&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; 注意: 不要忘了下面的mysql驱动依赖 2.2 编写生成配置文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;TestTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/test&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- Java 模型对象生成器 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.hebaohua.springbootmybatisgenerator.entity&quot; targetProject=&quot;${user.dir}/src/main/java&quot;/&gt; &lt;!-- SQL Mapper XML 生成器 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mybatis.mappers&quot; targetProject=&quot;${user.dir}/src/main/resources&quot;/&gt; &lt;!-- SQL Mapper Java 接口 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.hebaohua.springbootmybatisgenerator.mappers&quot; targetProject=&quot;${user.dir}/src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; &gt; &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySQL&quot; identity=&quot;true&quot; /&gt; &lt;columnOverride column=&quot;name&quot;/&gt; &lt;columnOverride column=&quot;age&quot;/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 注意命名为generatorConfig.xml，并且直接放在resources下面 2.3 执行生成命令在项目根目录打开命令窗口并执行mvn mybatis-generator:generate下图中的四个文件，然后其添加如XML方式中的配置信息。 2.4 运行测试上一步中产生的文件提供了关于数据库user表中丰富的增删改查接口，使我们在使用起来非常的方便。 123456789101112131415161718public class Demo { public static void main(String[] args) throws IOException { ResourceLoader resourceLoader = new DefaultResourceLoader(); Resource resource = resourceLoader.getResource(&quot;classpath:/mybatis/mybatis-config.xml&quot;); InputStream inputStream = resource.getInputStream(); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); try { UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectByExample(null); System.out.println(users); } finally { session.close(); } }} 运行效果: 3. 使用注解注解的方式总是能减少繁琐的配置文件。 3.1 编写注解Mapper1234567891011@Mapperpublic interface UserMapper { @Results(value = { @Result(property = &quot;id&quot;, column = &quot;id&quot;, id = true), @Result(property = &quot;name&quot;, column = &quot;name&quot;), @Result(property = &quot;age&quot;, column = &quot;age&quot;) }) @Select(&quot;SELECT id,name,age FROM user WHERE id = #{id}&quot;) User selectUser(int id);} 3.2 运行测试同样需要引入全局配置文件，并注意要增加以下内容:123&lt;mappers&gt; &lt;mapper class=&quot;com.hebaohua.springbootmybatisannotation.mappers.UserMapper&quot;/&gt;&lt;/mappers&gt; 测试代码:123456789101112131415161718public class Demo { public static void main(String[] args) throws IOException { ResourceLoader resourceLoader = new DefaultResourceLoader(); Resource resource = resourceLoader.getResource(&quot;classpath:/mybatis/mybatis-config.xml&quot;); InputStream inputStream = resource.getInputStream(); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); try { UserMapper userMapper = session.getMapper(UserMapper.class); User user= userMapper.selectUser(4); System.out.println(user); } finally { session.close(); } }} 运行效果: 4.SpringBoot中使用MyBatis通过查看 MybatisAutoConfiguration以及MybatisProperties源码可知，在SpringBoot的配置文件中配置好datasource以及以“mybatis”开头的相关配置就会自动装配SqlSessionFactory，SqlSessionTemplate对象，因此在Contorller中就可以直接使用。 1234567@org.springframework.context.annotation.Configuration@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration ` 123456789@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)public class MybatisProperties { public static final String MYBATIS_PREFIX = &quot;mybatis&quot;; /** * Location of MyBatis xml config file. */ private String configLocation; SpringBoot配置文件：123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/testmybatis.config-location=classpath:/mybatis/mybatis-config.xml Controller类:1234567891011@RestControllerpublic class MyBatisController { @Autowired private SqlSessionTemplate sqlSessionTemplate; @GetMapping(&quot;/user/{id}&quot;) public User getUser(@PathVariable int id){ User user = sqlSessionTemplate.selectOne(&quot;com.hebaohua.springbootmybatisannotation.mappers.UserMapper.selectUser&quot;,id); return user; }} 运行效果:","link":"/2018/05/31/SpringBoot2.0学习(四)-MyBatis/"},{"title":"Spring初探","text":"可以解决对象创建以及对象之间依赖关系的一种框架 1.第一个Spring程序 1.1 引入jar文件 spring-framework-3.2.5.RELEASEcommons-logging-1.1.3.jar 日志spring-beans-3.2.5.RELEASE.jar bean节点spring-context-3.2.5.RELEASE.jar spring上下文节点spring-core-3.2.5.RELEASE.jar spring核心功能spring-expression-3.2.5.RELEASE.jar spring表达式相关表 1.2 配置applicationContext.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- IOC容器的配置： 要创建的所有的对象都配置在这里--&gt; &lt;bean id=&quot;user&quot; class=&quot;cn.itcast.a_hello.User&quot; init-method=&quot;init_user&quot; destroy-method=&quot;destroy_user&quot; scope=&quot;singleton&quot; lazy-init=&quot;false&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;user1&quot; class=&quot;cn.itcast.a_hello.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 1.3 测试测试一：得到IOC容器的两种方法12345678910111213141516171819202122232425public class App1_get_ioc { // 1. 通过工厂类得到IOC容器创建的对象 @Test public void testIOC() throws Exception { // 创建对象 // User user = new User(); // 现在，把对象的创建交给spring的IOC容器 Resource resource = new ClassPathResource(&quot;cn/acamy/a_hello/applicationContext.xml&quot;); // 创建容器对象(Bean的工厂), IOC容器 = 工厂类 + applicationContext.xml BeanFactory factory = new XmlBeanFactory(resource); // 得到容器创建的对象 User user = (User) factory.getBean(&quot;user&quot;); System.out.println(user.getId()); } //2. （方便）直接得到IOC容器对象 @Test public void testAc() throws Exception { // 得到IOC容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/acamy/a_hello/applicationContext.xml&quot;); // 从容器中获取bean User user = (User) ac.getBean(&quot;user&quot;); System.out.println(user); }} 测试二：相关参数1) 对象创建： 单例/多例 scope=”singleton”, 默认值， 即 默认是单例 【service/dao/工具类】 scope=”prototype”, 多例； 【Action对象】 2) 什么时候创建? scope=”prototype” 在用到对象的时候，才创建对象。 scope=”singleton” 在启动(容器初始化之前)， 就已经创建了bean，且整个应用只有一个。 3)是否延迟创建 lazy-init=”false” 默认为false, 不延迟创建，即在启动时候就创建对象 lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 （只对单例有效） 4) 创建对象之后，初始化/销毁 init-method=”init_user” 【对应对象的init_user方法，在对象创建爱之后执行 】 destroy-method=”destroy_user” 【在调用容器对象的destriy方法时候执行，(容器用实现类)】 12345678910111213141516171819public class App2_bean { @Test public void testIOC() throws Exception { // 得到IOC容器对象 【用实现类，因为要调用销毁的方法】 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/acamy/a_hello/applicationContext.xml&quot;); System.out.println(&quot;-----容器创建-----&quot;); // 从容器中获取bean User user1 = (User) ac.getBean(&quot;user&quot;); User user2 = (User) ac.getBean(&quot;user1&quot;); System.out.println(user1); System.out.println(user2); // 销毁容器对象 ac.destroy(); }} 效果如下： 2. SpringIOC容器 spring核心内容,创建对象 &amp; 处理对象的依赖关系 2.1 创建对象1） 调用无参数构造器2） 带参数构造器3） 工厂创建对象(静态方法和非静态方法) 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 1. 默认无参数构造器 --&gt; &lt;bean id=&quot;user1&quot; class=&quot;cn.itcast.b_create_obj.User&quot;&gt;&lt;/bean&gt; &lt;!-- 2. 带参数构造器 --&gt; &lt;bean id=&quot;user2&quot; class=&quot;cn.itcast.b_create_obj.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;int&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;Jack&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 定义一个字符串，值是&quot;Jack&quot; ; String s = new String(&quot;jack&quot;)--&gt; &lt;bean id=&quot;str&quot; class=&quot;java.lang.String&quot;&gt; &lt;constructor-arg value=&quot;Jacks&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;user3&quot; class=&quot;cn.itcast.b_create_obj.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;int&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; ref=&quot;str&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 3. 工厂类创建对象 --&gt; &lt;!-- # 3.1 工厂类，实例方法 --&gt; &lt;!-- 先创建工厂 --&gt; &lt;bean id=&quot;factory&quot; class=&quot;cn.itcast.b_create_obj.ObjectFactory&quot;&gt;&lt;/bean&gt; &lt;!-- 在创建user对象，用factory方的实例方法 --&gt; &lt;bean id=&quot;user4&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;&lt;/bean&gt; &lt;!-- # 3.2 工厂类： 静态方法 --&gt; &lt;!-- class 指定的就是工厂类型 factory-method 一定是工厂里面的“静态方法” --&gt; &lt;bean id=&quot;user&quot; class=&quot;cn.itcast.b_create_obj.ObjectFactory&quot; factory-method=&quot;getStaticInstance&quot;&gt;&lt;/bean&gt; &lt;!-- 对象写法 --&gt; &lt;!-- 问题：spring配置文件中，bean节点的id与name属性的区别? id 不能有特殊符号, 且唯一，且不能以数字开始 name 可以有特殊符号 --&gt; &lt;bean id=&quot;1test&quot; name=&quot;test&quot; class=&quot;cn.itcast.b_create_obj.User&quot;&gt;&lt;/bean&gt; 2.2 对象依赖关系2.2.1 通过构造函数1234&lt;bean id=&quot;user1&quot; class=&quot;cn.itcast.c_property.User&quot; scope=&quot;prototype&quot;&gt; &lt;constructor-arg value=&quot;100&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Tom&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 2.2.2 通过set方法给属性注入值1234&lt;bean id=&quot;user&quot; class=&quot;cn.itcast.c_property.User&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;101&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;Jack&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.3 bean依赖123456789101112131415161718192021222324&lt;!-- dao instance --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c_property.UserDao&quot;&gt;&lt;/bean&gt; &lt;!-- service instance --&gt; &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c_property.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- action instance --&gt; &lt;bean id=&quot;userAction1&quot; class=&quot;cn.itcast.c_property.UserAction&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ##############内部bean############## --&gt; &lt;bean id=&quot;userAction2&quot; class=&quot;cn.itcast.c_property.UserAction&quot;&gt; &lt;property name=&quot;userService&quot;&gt; &lt;bean class=&quot;cn.itcast.c_property.UserService&quot;&gt; &lt;property name=&quot;userDao&quot;&gt; &lt;bean class=&quot;cn.itcast.c_property.UserDao&quot;&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 2.2.4 p名称空间1234567&lt;bean id=&quot;user&quot; class=&quot;cn.itcast.c_property.User&quot; p:name=&quot;Jack0001&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.c_property.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.c_property.UserService&quot; p:userDao-ref=&quot;userDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userAction&quot; class=&quot;cn.itcast.c_property.UserAction&quot; p:userService-ref=&quot;userService&quot;&gt;&lt;/bean&gt; 2.2.5 自动装配 根据名称自动装配：autowire=”byName”,自动去IOC容器中找与属性名同名的引用的对象，并自动注入,也可以定义到全局， 这样就不用每个bean节点都去写autowire=”byName”，但必须确保改类型在IOC容器中只有一个对象；否则报错。 12345&lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.d_auto.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.d_auto.UserService&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;!-- 根据“名称”自动装配： userAction注入的属性，会去ioc容器中自动查找与属性同名的对象 --&gt;&lt;bean id=&quot;userAction&quot; class=&quot;cn.itcast.d_auto.UserAction&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; 2.2.6 注解 注解方式可以简化spring的IOC容器的配置! 需要引入context名称空间并开启注解扫描 12xmlns:context=&quot;http://www.springframework.org/schema/context&quot; &lt;context:component-scan base-package=&quot;cn.itcast.e_anno2&quot;&gt;&lt;/context:component-scan&gt; 分类@Component 指定把一个对象加入IOC容器 @Service 作用同@Component； 在业务逻辑层使用@Controller 作用同@Component； 在控制层使用@Repository 作用同@Component； 在持久层使用 @Resource 属性注入 123456789101112131415@Component(&quot;userAction&quot;) // 加入IOC容器，也可以用@Controllerpublic class UserAction { @Resource(name = &quot;userService&quot;) private UserService userService; public void setUserService(UserService userService) { this.userService = userService; } public String execute() { userService.save(); return null; }} 123456789101112131415161718192021@Component(&quot;userService&quot;) // userService加入ioc容器，也可以用@Servicepublic class UserService { // 会从IOC容器中找userDao对象，注入到当前字段 /* * &lt;bean id=&quot;&quot; class=&quot;&quot;&gt; * &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot; /&gt; @Resource相当于这里的配置 * &lt;/bean&gt; */ @Resource(name = &quot;userDao&quot;) private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void save() { userDao.save(); }} 12345678// 把当前对象加入ioc容器@Component(&quot;userDao&quot;) //也可以用Repository 相当于bean.xml 【&lt;bean id=userDao class=&quot;..&quot; /&gt;】public class UserDao { public void save() { System.out.println(&quot;DB:保存用户!!!&quot;); }}","link":"/2017/06/18/Spring初探/"},{"title":"Spring进阶之代理与AOP编程","text":"本文先介绍了代理中的静态代理，动态代理和Cglib代理，然后通过示例分别展示了如何通过注解和XML方式实现AOP编程，并且列举了切入点表达式的常用形式。 1. 代理 代理（Proxy）是一种设计模式，为需要访问的对象提供了一个替身或者点位符以控制对这个对象的访问。使得可以在目标对象实现的基础上，增强额外的功能操作。 1.1 静态代理 代理对象与真实对象实现相同的接口，实现访问控制。 举例： 1234567891011121314151617181920212223242526272829303132333435363738public class App { public static void main(String[] args) { // 目标对象 IUserDao target = new UserDao(); // 代理 IUserDao proxy = new UserDaoProxy(target); proxy.save(); // 执行的是，代理的方法 }}interface IUserDao { void save();}class UserDao implements IUserDao{ @Override public void save() { System.out.println(&quot;-----已经保存数据！！！------&quot;); }}class UserDaoProxy implements IUserDao{ // 接收保存目标对象 private IUserDao target; public UserDaoProxy(IUserDao target) { this.target = target; } @Override public void save() { System.out.println(&quot;开始事务...&quot;); target.save(); // 执行目标对象的方法 System.out.println(&quot;提交事务...&quot;); } } 总结：可以做到在不修改目标对象的功能前提下，对目标对象功能扩展。但因为代理对象，需要与目标对象实现一样的接口。所以会有很多代理类，类太多。而且一旦接口增加方法，目标对象与代理对象都要维护。 1.2 动态代理 代理对象，不需要实现接口，代理对象的生成，是利用JDKAPI， 动态的在内存中构建代理对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class App { public static void main(String[] args) { // 目标对象 IUserDao target = new UserDao(); // 【原始的类型 class cn.itcast.b_dynamic.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); }}class ProxyFactory { // 维护一个目标对象 private Object target; public ProxyFactory(Object target){ this.target = target; } // 给目标对象，生成代理对象 public Object getProxyInstance() { return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开启事务&quot;); // 执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务&quot;); return returnValue; } }); }}interface IUserDao { void save(); }class UserDao implements IUserDao{ @Override public void save() { System.out.println(&quot;-----已经保存数据！！！------&quot;); }} 总结:代理对象不需要实现接口，但是目标对象一定要实现接口；否则不能用动态代理！ 1.3 Cglib代理 也叫做子类代理。可以代理没有实现接口的类，通过在内存中构建一个子类对象从而实现对目标对象功能的扩展 注意：1) 需要引入cglib – jar文件， 但是spring的核心包中已经包括了cglib功能，所以直接引入spring-core-3.2.5.jar即可。 2）引入功能包后，就可以在内存中动态构建子类 3）代理的类不能为final， 否则报错。 4） 目标对象的方法如果为final/static, 那么就不会被拦截，即不会执行目标对象额外的业务方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class App { public static void main(String[] args) { // 目标对象 UserDao target = new UserDao(); // class cn.itcast.c_cglib.UserDao System.out.println(target.getClass()); // 代理对象 UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance(); // UserDao子类：class cn.itcast.c_cglib.UserDao$$EnhancerByCGLIB$$25d4aeab System.out.println(proxy.getClass()); // 执行代理对象的方法 proxy.save(); }}class ProxyFactory implements MethodInterceptor{ // 维护目标对象 private Object target; public ProxyFactory(Object target){ this.target = target; } // 给目标对象创建代理对象 public Object getProxyInstance(){ //1. 工具类 Enhancer en = new Enhancer(); //2. 设置父类 en.setSuperclass(target.getClass()); //3. 设置回调函数 en.setCallback(this); //4. 创建子类(代理对象) return en.create(); } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;开始事务.....&quot;); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务.....&quot;); return returnValue; }} 2. AOP编程 Aspect Oriented Programming,即面向切面编程。对很多功能都有的重复的代码抽取，再在运行的时候网业务方法上动态植入“切面类代码”,让关注点(大量重复)代码与业务代码分离！开发者对关注点代码写一次即可,只需要关注核心业务,大大减少了代码的重复量。 关注点：重复代码就叫做关注点；切面: 关注点形成的类，就叫切面(类)！切入点: 执行目标对象方法，动态植入切面代码。 可以通过切入点表达式，指定拦截哪些类的哪些方法； 给指定的类在运行的时候植入切面类代码。 举例：123456789101112131415161718192021// 保存一个用户public void add(User user) { Session session = null; Transaction trans = null; try { session = HibernateSessionFactoryUtils.getSession(); // 【关注点代码】 trans = session.beginTransaction(); // 【关注点代码】 session.save(user); // 核心业务代码 trans.commit(); //…【关注点代码】 } catch (Exception e) { e.printStackTrace(); if(trans != null){ trans.rollback(); //..【关注点代码】 } } finally{ HibernateSessionFactoryUtils.closeSession(session); ////..【关注点代码】 } } 2.1 注解方式实现AOP编程步骤： 1） 先引入aop相关jar文件 （aspectj aop优秀组件）1234spring-aop-3.2.5.RELEASE.jar 【spring3.2源码】aopalliance.jar 【spring2.5源码/lib/aopalliance】aspectjweaver.jar 【spring2.5源码/lib/aspectj】或【aspectj-1.8.2\\lib】aspectjrt.jar 【spring2.5源码/lib/aspectj】或【aspectj-1.8.2\\lib】 2） bean.xml中引入aop名称空间,并开启aop注解1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;cn.itcast.e_aop_anno&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 开启aop注解方式 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 3) 编写注解类 1234567891011121314151617181920212223242526272829303132333435363738394041@Component@Aspect // 指定当前类为切面类public class Aop { // 指定切入点表单式： 拦截哪些方法； 即为哪些类生成代理对象 @Pointcut(&quot;execution(* cn.itcast.e_aop_anno.*.*(..))&quot;) public void pointCut_(){ } // 前置通知 : 在执行目标方法之前执行 @Before(&quot;pointCut_()&quot;) public void begin(){ System.out.println(&quot;开始事务/异常...begin()&quot;); } // 后置/最终通知：在执行目标方法之后执行 【无论是否出现异常最终都会执行】 @After(&quot;pointCut_()&quot;) public void after(){ System.out.println(&quot;提交事务/关闭...after()&quot;); } // 返回后通知： 在调用目标方法结束后执行 【出现异常不执行】 @AfterReturning(&quot;pointCut_()&quot;) public void afterReturning() { System.out.println(&quot;afterReturning()&quot;); } // 异常通知： 当目标方法执行异常时候执行此关注点代码 @AfterThrowing(&quot;pointCut_()&quot;) public void afterThrowing(){ System.out.println(&quot;afterThrowing()&quot;); } // 环绕通知：环绕目标方式执行 @Around(&quot;pointCut_()&quot;) public void around(ProceedingJoinPoint pjp) throws Throwable{ System.out.println(&quot;环绕前....around(ProceedingJoinPoint pjp)&quot;); pjp.proceed(); // 执行目标方法 System.out.println(&quot;环绕后....around(ProceedingJoinPoint pjp)&quot;); } } 4) 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class App { ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/itcast/e_aop_anno/bean.xml&quot;); // 目标对象有实现接口，spring会自动选择“JDK代理” @Test public void testApp() { IUserDao userDao = (IUserDao) ac.getBean(&quot;userDao&quot;); System.out.println(userDao.getClass());//$Proxy001 userDao.save(); } // 目标对象没有实现接口， spring会用“cglib代理” @Test public void testCglib() { OrderDao orderDao = (OrderDao) ac.getBean(&quot;orderDao&quot;); System.out.println(orderDao.getClass()); orderDao.save(); } @Deprecated // 共性问题：如果目标对象有实现接口，在从容器中获取目标对象的时候，只能通过接口接收对象。 public void testApp2() { // 错误代码： 只能用接口接收 UserDao userDao = (UserDao) ac.getBean(&quot;userDao&quot;); System.out.println(userDao.getClass());//$Proxy001 userDao.save(); } @Test public void testGetObj() throws Exception { OrderDao orderDao1 = (OrderDao) ac.getBean(&quot;orderDao&quot;); OrderDao orderDao2 = (OrderDao) ac.getBean(&quot;orderDao&quot;); System.out.println(orderDao1); System.out.println(orderDao2); }}interface IUserDao { void save();}//目标对象1,实现了接口@Component // 加入容器class UserDao implements IUserDao{ @Override public void save() { System.out.println(&quot;-----核心业务：保存！！！------&quot;); }}//目标对象1,没有实现接口@Component // 加入容器@Scope(&quot;prototype&quot;)class OrderDao{ public void save() { System.out.println(&quot;-----核心业务：保存！！！------&quot;); }} 效果如下： 2.2 XML方式实现AOP编程 相对于上面的方式，在aop类中不再需要使用注解 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- dao 实例 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.f_aop_xml.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;orderDao&quot; class=&quot;cn.itcast.f_aop_xml.OrderDao&quot;&gt;&lt;/bean&gt; &lt;!-- 切面类 --&gt; &lt;bean id=&quot;aop&quot; class=&quot;cn.itcast.f_aop_xml.Aop&quot;&gt;&lt;/bean&gt; &lt;!-- Aop配置 --&gt; &lt;aop:config&gt; &lt;!-- 定义一个切入点表达式： 拦截哪些方法 --&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.f_aop_xml.*.*(..))&quot; id=&quot;pt&quot;/&gt; &lt;!-- 切面 --&gt; &lt;aop:aspect ref=&quot;aop&quot;&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 前置通知： 在目标方法调用前执行 --&gt; &lt;aop:before method=&quot;begin&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 后置通知： --&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 返回后通知 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;!-- 异常通知 --&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 3.3 切入点表达式 可以对指定的“方法”进行拦截； 从而给指定的方法所在的类生层代理对象 123456789101112131415161718192021222324252627&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.*.*(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【拦截所有public方法】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(public * *(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【拦截所有save开头的方法 】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* save*(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【拦截指定类的指定方法, 拦截时候一定要定位到方法】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(public * cn.itcast.g_pointcut.OrderDao.save(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【拦截指定类的所有方法】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.UserDao.*(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【拦截指定包，以及其自包下所有类的所有方法】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn..*.*(..))&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【多个表达式】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.UserDao.save()) || execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.UserDao.save()) or execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 下面2个且关系的，没有意义 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.UserDao.save()) &amp;&amp; execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!--&lt;aop:pointcut expression=&quot;execution(* cn.itcast.g_pointcut.UserDao.save()) and execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;!-- 【取非值】 --&gt;&lt;!--&lt;aop:pointcut expression=&quot;!execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;--&gt;&lt;aop:pointcut expression=&quot; not execution(* cn.itcast.g_pointcut.OrderDao.save())&quot; id=&quot;pt&quot;/&gt;","link":"/2017/06/18/Spring进阶之代理与AOP编程/"},{"title":"Spring进阶之对jdbc的支持以及事物管理","text":"1. Spring对jdbc支持 Spring通过引入相关的jar包能够支持c3p0连接池， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class App { // 容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/i&lt;!-- more --&gt;tcast/h_jdbc/bean.xml&quot;); @Test public void testApp() throws Exception { UserDao ud = (UserDao) ac.getBean(&quot;userDao&quot;);// ud.save(); System.out.println(ud.findById(5)); System.out.println(ud.getAll()); }}class UserDao { private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void save() { String sql = &quot;insert into t_dept(deptName) values(&apos;test&apos;);&quot;; jdbcTemplate.update(sql); } public Dept findById(int id) { String sql = &quot;select * from t_dept where deptId=?&quot;; List&lt;Dept&gt; list = jdbcTemplate.query(sql,new MyResult(), id); return (list!=null &amp;&amp; list.size()&gt;0) ? list.get(0) : null; } public List&lt;Dept&gt; getAll() { String sql = &quot;select * from t_dept&quot;; List&lt;Dept&gt; list = jdbcTemplate.query(sql, new MyResult()); return list; } class MyResult implements RowMapper&lt;Dept&gt;{ // 如何封装一行记录 @Override public Dept mapRow(ResultSet rs, int index) throws SQLException { Dept dept = new Dept(); dept.setDeptId(rs.getInt(&quot;deptId&quot;)); dept.setDeptName(rs.getString(&quot;deptName&quot;)); return dept; } }}class Dept { private int deptId; private String deptName; public int getDeptId() { return deptId; } public void setDeptId(int deptId) { this.deptId = deptId; } public String getDeptName() { return deptName; } public void setDeptName(String deptName) { this.deptName = deptName; } } 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 1. 数据源对象: C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///mysql&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2. 创建JdbcTemplate对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- dao 实例 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.h_jdbc.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2. Spring事务管理 Spring提供了对事务控制的实现。用户如果想用Spring的声明式事务管理，只需要在配置文件中配置即可； 不想使用时直接移除配置。这个实现了对事务控制的最大程度的解耦。 Spring声明式事务管理器类：Jdbc技术：DataSourceTransactionManagerHibernate技术：HibernateTransactionManager 注意：一个业务的成功： 调用的service是执行成功的，意味着service中调用的所有的dao是执行成功的。 事务应该在Service层统一控制。 2.1 XML方式实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 1. 数据源对象: C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///mysql&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2. JdbcTemplate工具类实例 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3. dao实例 --&gt; &lt;bean id=&quot;deptDao&quot; class=&quot;cn.itcast.a_tx.DeptDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4. service实例 --&gt; &lt;bean id=&quot;deptService&quot; class=&quot;cn.itcast.a_tx.DeptService&quot;&gt; &lt;property name=&quot;deptDao&quot; ref=&quot;deptDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- #############5. Spring声明式事务管理配置############### --&gt; &lt;!-- 5.1 配置事务管理器类 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 5.2 配置事务增强(如果管理事务?) --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 5.3 Aop配置： 拦截哪些方法(切入点表表达式) + 应用上面的事务增强配置 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.a_tx.DeptService.save(..))&quot; id=&quot;pt&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class App { @Test public void testApp() throws Exception { //容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/itcast/a_tx/bean.xml&quot;); // 模拟数据 Dept dept = new Dept(); dept.setDeptName(&quot;测试： 开发部&quot;); DeptService deptService = (DeptService) ac.getBean(&quot;deptService&quot;); deptService.save(dept); }}class DeptService { // 容器注入dao对象 private DeptDao deptDao; public void setDeptDao(DeptDao deptDao) { this.deptDao = deptDao; } /* * 事务控制？ */ public void save(Dept dept){ // 第一次调用 deptDao.save(dept); int i = 1/0; // 异常： 整个Service.save()执行成功的要回滚 // 第二次调用 deptDao.save(dept); }}class DeptDao { // 容器注入JdbcTemplate对象 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public void save(Dept dept){ String sql = &quot;insert into t_dept (deptName) values(?)&quot;; jdbcTemplate.update(sql,dept.getDeptName()); }}class Dept { private int deptId; private String deptName; public int getDeptId() { return deptId; } public void setDeptId(int deptId) { this.deptId = deptId; } public String getDeptName() { return deptName; } public void setDeptName(String deptName) { this.deptName = deptName; } } 2.2 注解方式实现使用注解实现Spring的声明式事务管理，更加简单！步骤： 1） 必须引入Aop相关的jar文件 2） bean.xml中指定注解方式实现声明式事务管理以及应用的事务管理器类 3）在需要添加事务控制的地方，写上: @Transactional @Transactional注解： 1）应用事务的注解 2）定义到方法上： 当前方法应用spring的声明式事务 3）定义到类上： 当前类的所有的方法都应用Spring声明式事务管理; 4）定义到父类上： 当执行父类的方法时候应用事务。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 1. 数据源对象: C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///mysql&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;3&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxStatements&quot; value=&quot;100&quot;&gt;&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2. JdbcTemplate工具类实例 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 事务管理器类 --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;cn.itcast.b_anno&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 注解方式实现事务： 指定注解方式实现事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; &lt;bean class=&quot;cn.itcast.b_anno.DeptDao&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class App { @Test public void testApp() throws Exception { //容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/itcast/b_anno/bean.xml&quot;); // 模拟数据 Dept dept = new Dept(); dept.setDeptName(&quot;测试： 开发部&quot;); DeptService deptService = (DeptService) ac.getBean(&quot;deptService&quot;); deptService.save(dept); } // 了解容器的相关方法 @Test public void testApp2() throws Exception { //1. 根据bean.xml配置路径，创建容器对象 //ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/itcast/b_anno/bean.xml&quot;); //2. 根据多个配置文件的路径，创建容器对象 //ApplicationContext ac = new ClassPathXmlApplicationContext(new String[]{}); //3. 容器对象相关方法 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;cn/itcast/b_anno/bean.xml&quot;); //3.1 从容器中获取指定名称的bean对象 //DeptDao deptDao = (DeptDao) ac.getBean(&quot;deptDao&quot;); //3.2 根据类型从容器获取实例 【改类型只能在IOC中有唯一的对象，否则报错】 //DeptDao deptDao = ac.getBean(DeptDao.class); //3.3 泛型，不需要强转 //DeptDao deptDao = ac.getBean(&quot;deptDap&quot;, DeptDao.class); //3.4 获取容器中bean对象的数量 //int count = ac.getBeanDefinitionCount(); String[] names = ac.getBeanDefinitionNames(); System.out.println(Arrays.toString(names)); }}@Servicepublic class DeptService { // 部门dao @Resource private DeptDao deptDao; // 日志dao @Resource private LogDao logDao; /* * 事务控制？ */ @Transactional( readOnly = false, // 读写事务 timeout = -1, // 事务的超时时间不限制 //noRollbackFor = ArithmeticException.class, // 遇到数学异常不回滚 isolation = Isolation.DEFAULT, // 事务的隔离级别，数据库的默认 propagation = Propagation.REQUIRED // 事务的传播行为 ) public void save(Dept dept){ logDao.insertLog(); // 保存日志 【自己开启一个事务】 int i = 1/0; deptDao.save(dept); // 保存部门 }}@Repositorypublic class DeptDao { @Resource private JdbcTemplate jdbcTemplate; public void save(Dept dept){ String sql = &quot;insert into t_dept (deptName) values(?)&quot;; jdbcTemplate.update(sql,dept.getDeptName()); }}// 测试： 日志传播行为@Repositorypublic class LogDao { @Resource private JdbcTemplate jdbcTemplate; // 始终开启事务 @Transactional(propagation = Propagation.REQUIRES_NEW) public void insertLog() { jdbcTemplate.update(&quot;insert into log_ (content) values(&apos;在保存Dept11..&apos;)&quot;); }}public class Dept { private int deptId; private String deptName; public int getDeptId() { return deptId; } public void setDeptId(int deptId) { this.deptId = deptId; } public String getDeptName() { return deptName; } public void setDeptName(String deptName) { this.deptName = deptName; } } 事务传播行为: Propagation.REQUIRED 指定当前的方法必须在事务的环境下执行； 如果当前运行的方法，已经存在事务， 就会加入当前的事务； Propagation.REQUIRED_NEW 指定当前的方法必须在事务的环境下执行； 如果当前运行的方法，已经存在事务： 事务会挂起； 会始终开启一个新的事务，执行完后； 刚才挂起的事务才继续运行。","link":"/2017/06/18/Spring进阶之对jdbc的支持以及事物管理/"},{"title":"flowable表单引擎","text":"flowable表单引擎作为一个独立的模块，也包括表单定义，部署等过程。 ####1. API及与流程引擎的结合如下图所示，表单引擎也有一个独立的配置文件，配置类，配置引擎及三个Service.在实际使用中我们也是将其配置嵌入到流程引擎的配置中，配置形式如下(省略了非相关配置)：12345678910111213141516171819202122&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;asyncExecutorActivate&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;configurators&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.flowable.form.engine.configurator.FormEngineConfigurator&quot;&gt; &lt;property name=&quot;formEngineConfiguration&quot;&gt; &lt;bean class=&quot;org.flowable.form.engine.impl.cfg.StandaloneFormEngineConfiguration&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;formRepositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getFormEngineRepositoryService&quot; /&gt; 在应用重启时数据库中会增加act_fo_为前缀的六张数据库表格：act_fo_databasechangelog: Liquibase用来跟踪数据库变量的act_fo_databasechangeloglock: Liquibase用来保证同一时刻只有一个Liquibase实例在运行act_fo_form_definition:存储表单定义的信息act_fo_form_instance:存储用户填充后表单实例信息act_fo_form_deployment:存储表单部署元数据act_fo_form_resource:存储表单定义的资源 ####2. 表单的定义表单定义文件是以.form为后缀， 内容格式为Json格式。如下示例所示。1234567891011121314151617181920212223{ &quot;key&quot;: &quot;form1&quot;, &quot;name&quot;: &quot;My first form&quot;, &quot;fields&quot;: [ { &quot;id&quot;: &quot;input1&quot;, &quot;name&quot;: &quot;Input1&quot;, &quot;type&quot;: &quot;text&quot;, &quot;required&quot;: false, &quot;placeholder&quot;: &quot;empty&quot; } ], &quot;outcomes&quot;: [ { &quot;id&quot;: &quot;null&quot;, &quot;name&quot;: &quot;Accept&quot; }, { &quot;id&quot;: &quot;null&quot;, &quot;name&quot;: &quot;Reject&quot; } ]} 该文件的key属性是其唯一性标识，表单引擎可以通过该key获取到它， 同时数据库对相同key会维护不同的版本。第二部分是表单字段数组，第三部分是表单结果。每一个表单字段都有id,name和type属性。id属性在同一个表单定义文件中必须唯一，当用户赋值时它会作为变量的名称，在上例中，也就是会创建名称为input1的变量，值由用户填入。同时表单结果也会以form_&lt;form-identifier&gt;_outcome获取得到，对于上例，用户选择的结果会赋值给form_form1_outcome， 我们可以通过${form_form1_outcome == &quot;Accept&quot;}表达式来验证表单结果是否为Accept。表单字段的type属性支持text, multi-line-text,integer,boolean,date等多种类型。 ####3. 表单的使用首先在src/main/resources文件夹下创建test.form表单定义文件，内容如下：12345678910111213141516171819202122232425262728{&quot;key&quot;: &quot;form1&quot;,&quot;name&quot;: &quot;请假流程&quot;,&quot;fields&quot;: [ { &quot;id&quot;: &quot;startTime&quot;, &quot;name&quot;: &quot;开始时间&quot;, &quot;type&quot;: &quot;date&quot;, &quot;required&quot;: true, &quot;placeholder&quot;: &quot;empty&quot; }, { &quot;id&quot;: &quot;endTime&quot;, &quot;name&quot;: &quot;结束时间&quot;, &quot;type&quot;: &quot;date&quot;, &quot;required&quot;: true, &quot;placeholder&quot;: &quot;empty&quot; }, { &quot;id&quot;: &quot;reason&quot;, &quot;name&quot;: &quot;请假原因&quot;, &quot;type&quot;: &quot;text&quot;, &quot;required&quot;: true, &quot;placeholder&quot;: &quot;empty&quot; } ]} 然后创建test-form.bpmn20.xml流程定义文件：12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; xmlns:flowable=&quot;http://flowable.org/bpmn&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.flowable.org/processdef&quot;&gt; &lt;process id=&quot;holidayRequest&quot; name=&quot;Holiday Request&quot; isExecutable=&quot;true&quot;&gt; &lt;startEvent id=&quot;startEvent&quot; flowable:formKey=&quot;form1&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;startEvent&quot; targetRef=&quot;approveTask&quot;/&gt; &lt;userTask id=&quot;approveTask&quot; name=&quot;Approve or reject request&quot; flowable:formKey=&quot;form1&quot; flowable:candidateGroups=&quot;managers&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;approveTask&quot; targetRef=&quot;holidayApprovedTask&quot;/&gt; &lt;userTask id=&quot;holidayApprovedTask&quot; name=&quot;Holiday approved&quot; flowable:formKey=&quot;form1&quot; flowable:assignee=&quot;employee&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;holidayApprovedTask&quot; targetRef=&quot;approveEnd&quot;/&gt; &lt;endEvent id=&quot;approveEnd&quot;/&gt; &lt;/process&gt;&lt;/definitions&gt; 上面的开始事件和两个用户任务都带有flowable:formKey属性。然后就可以创建测试类了，注意用runtimeService.startProcessInstanceWithForm方法启动带表单的流程，runtimeService.getStartFormModel查询流程启动时的表单信息; taskService.completeTaskWithForm填充表单完成任务，taskService.getTaskFormModel查询任务表单信息。具体测试类代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class FormTest { @Autowired private RepositoryService repositoryService; @Autowired private RuntimeService runtimeService; @Autowired private FormRepositoryService formRepositoryService; @Autowired private TaskService taskService; @Autowired private HistoryService historyService; /** * 流程以及表单的部署 */ @Test public void deployTest(){ Deployment deployment = repositoryService.createDeployment() .name(&quot;表单流程&quot;) .addClasspathResource(&quot;flowable/test-form.bpmn20.xml&quot;) .deploy(); ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery(). deploymentId(deployment.getId()) .singleResult(); String processDefinitionId = processDefinition.getId(); FormDeployment formDeployment = formRepositoryService.createDeployment() .name(&quot;definition-one&quot;) .addClasspathResource(&quot;flowable/test.form&quot;) .parentDeploymentId(deployment.getId()) .deploy(); FormDefinition formDefinition = formRepositoryService.createFormDefinitionQuery().deploymentId(formDeployment.getId()).singleResult(); String formDefinitionId = formDefinition.getId(); //启动实例并且设置表单的值 String outcome = &quot;shareniu&quot;; Map&lt;String, Object&gt; formProperties; formProperties = new HashMap&lt;&gt;(); formProperties.put(&quot;reason&quot;, &quot;家里有事&quot;); formProperties.put(&quot;startTime&quot;, Dates.format(new Date(), Dates.Pattern.DATE)); formProperties.put(&quot;endTime&quot;, Dates.format(new Date(), Dates.Pattern.DATE)); String processInstanceName = &quot;shareniu&quot;; runtimeService.startProcessInstanceWithForm(processDefinitionId, outcome, formProperties, processInstanceName); HistoricProcessInstanceEntity historicProcessInstanceEntity = (HistoricProcessInstanceEntity )historyService.createHistoricProcessInstanceQuery() .processDefinitionId(processDefinitionId) .singleResult(); String processInstanceId = historicProcessInstanceEntity.getProcessInstanceId(); //查询表单信息 FormModel fm = runtimeService.getStartFormModel(processDefinitionId, processInstanceId); System.out.println(fm.getId()); System.out.println(fm.getKey()); System.out.println(fm.getName()); System.out.println(fm.getOutcomeVariableName()); System.err.println(fm.getVersion()); List&lt;FormField&gt; fields = fm.getFields(); for (FormField ff : fields) { System.out.println(&quot;######################&quot;); System.out.println(ff.getId()); System.out.println(ff.getName()); System.out.println(ff.getType()); System.out.println(ff.getPlaceholder()); System.out.println(ff.getValue()); System.out.println(&quot;######################&quot;); } //查询个人任务并填写表单 Map&lt;String, Object&gt; formProperties2 = new HashMap&lt;&gt;(); formProperties2.put(&quot;reason&quot;, &quot;家里有事2222&quot;); formProperties2.put(&quot;startTime&quot;, Dates.format(new Date(), Dates.Pattern.DATE)); formProperties2.put(&quot;endTime&quot;, Dates.format(new Date(), Dates.Pattern.DATE)); formProperties2.put(&quot;days&quot;, &quot;3&quot;); Task task = taskService.createTaskQuery().processInstanceId(processInstanceId).singleResult(); String taskId = task.getId(); String outcome2=&quot;牛哥&quot;; taskService.completeTaskWithForm(taskId, formDefinitionId, outcome2, formProperties2); //获取个人任务表单 FormModel taskFM = taskService.getTaskFormModel(taskId); }}","link":"/2018/08/25/flowable表单引擎/"},{"title":"struts2框架(一) 初探","text":"Struts2 是一个用来开发 MVC应用程序的框架. 它提供了 Web 应用程序开发过程中的一些常见问题的解决方案:Struts2 = Struts1 + WebWork 1和2没有本质的关系 ##1.Struts2开发流程 1.1 引入jar文件 commons-fileupload-1.2.2.jar 【文件上传相关包】commons-io-2.0.1.jar 【io操作相关的包】struts2-core-2.3.4.1.jar 【struts2核心功能包】xwork-core-2.3.4.1.jar 【Xwork核心包】ognl-3.0.5.jar 【Ognl表达式功能支持表】commons-lang3-3.1.jar 【struts对java.lang包的扩展】freemarker-2.3.19.jar 【struts的标签模板库jar文件】javassist-3.11.0.GA.jar 【struts对字节码的处理相关jar】 1.2 配置web.xml tomcat服务器在启动时，首先会加载自身的web.xml，然后加载所有项目的web.xml。struts2通过在web.xml中引入过滤器来作为入口，在学习过滤器的时候我们知道过滤器的init方法会在tomcat服务器启动时调用。 123456789 &lt;!-- 引入struts核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 1.3 编写Action类 action类，也叫做动作类; 一般继承ActionSupport类,即处理请求的类 (struts中的action类取代之前的servlet).注意： action中的业务方法不能有参数，且必须返回String 12345678910import com.opensymphony.xwork2.ActionSupport;// 开发action： 处理请求public class HelloAction extends ActionSupport { // 处理请求 public String execute() throws Exception { System.out.println(&quot;访问到了action，正在处理请求&quot;); return &quot;success&quot;; }} 1.4 配置struts.xml 该配置文件的头部可以参照struts2-core-2.3.4.1.jar包下面的struts-default.xml来写。该配置文件的主要作用是将提供action的访问名称，并且和action类进行关联。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;xxxx&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;cn.acamy.action.HelloAction&quot; method=&quot;execute&quot;&gt; &lt;result name=&quot;success&quot;&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; ##2.Struts2执行流程 2.1 服务器启动 加载项目web.xml 创建Struts核心过滤器对象， 执行filter的init()123struts-default.xml, 核心功能的初始化struts-plugin.xml, struts相关插件struts.xml 用户编写的配置文件 2.2 用户访问3.用户访问Action, 服务器根据访问路径名称，找对应的aciton配置, 创建action对象4.执行默认拦截器栈中定义的18个拦截器5.执行action的业务处理方法6.根据action返回的Result来跳转到相应的页面 3. 三大配置文件的加载 从上面可以知道核心过滤器是Struts的入口，tomcat服务器在启动时会执行过滤器的init()方法，现在通过源码展示三大配置文件是如何加载的。 3.1 首先是执行web.xml引入的StrutsPrepareAndExecuteFilter初始化方法123456789101112131415161718public void init(FilterConfig filterConfig) throws ServletException { InitOperations init = new InitOperations(); try { FilterHostConfig config = new FilterHostConfig(filterConfig); init.initLogging(config); Dispatcher dispatcher = init.initDispatcher(config);// 在这里跳转 init.initStaticContentLoader(config, dispatcher); prepare = new PrepareOperations(filterConfig.getServletContext(), dispatcher); execute = new ExecuteOperations(filterConfig.getServletContext(), dispatcher); this.excludedPatterns = init.buildExcludedPatternsList(dispatcher); postInit(dispatcher, filterConfig); } finally { init.cleanup(); } } ###3.2 然后执行InitOperations的initDispatcher方法12345public Dispatcher initDispatcher( HostConfig filterConfig ) { Dispatcher dispatcher = createDispatcher(filterConfig); dispatcher.init(); return dispatcher; } 3.3 最后执行Dispatcher的init方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Load configurations, including both XML and zero-configuration strategies, * and update optional settings, including whether to reload configurations and resource files. */ public void init() { if (configurationManager == null) { configurationManager = createConfigurationManager(BeanSelectionProvider.DEFAULT_BEAN_NAME); } try { init_DefaultProperties(); // [1] init_TraditionalXmlConfigurations(); // [2]跳转到三大配置文件的相关方法 init_LegacyStrutsProperties(); // [3] init_CustomConfigurationProviders(); // [5] init_FilterInitParameters() ; // [6] init_AliasStandardObjects() ; // [7] Container container = init_PreloadConfiguration(); container.inject(this); init_CheckConfigurationReloading(container); init_CheckWebLogicWorkaround(container); if (!dispatcherListeners.isEmpty()) { for (DispatcherListener l : dispatcherListeners) { l.dispatcherInitialized(this); } } } catch (Exception ex) { if (LOG.isErrorEnabled()) LOG.error(&quot;Dispatcher initialization failed&quot;, ex); throw new StrutsException(ex); } }//三大配置文件private static final String DEFAULT_CONFIGURATION_PATHS = &quot;struts-default.xml,struts-plugin.xml,struts.xml&quot;;private void init_TraditionalXmlConfigurations() { String configPaths = initParams.get(&quot;config&quot;); if (configPaths == null) { configPaths = DEFAULT_CONFIGURATION_PATHS; } String[] files = configPaths.split(&quot;\\\\s*[,]\\\\s*&quot;); //骤个初始化 for (String file : files) { if (file.endsWith(&quot;.xml&quot;)) { if (&quot;xwork.xml&quot;.equals(file)) { configurationManager.addContainerProvider(createXmlConfigurationProvider(file, false)); } else { configurationManager.addContainerProvider(createStrutsXmlConfigurationProvider(file, false, servletContext)); } } else { throw new IllegalArgumentException(&quot;Invalid configuration file name&quot;); } } } 4.struts-default.xml, 详解 位置：struts2-core-2.3.4.1.jar/ struts-default.xml 内容： 1. bean节点指定struts在运行的时候创建的对象类型 2.指定struts-default包 【用户写的package(struts.xml)一样要继承此包 】 package struts-default 包中定义了： a. 跳转的结果类型 dispatcher 转发，不指定默认为转发 redirect 重定向 redirectAction 重定向到action资源 stream (文件下载的时候用) b. 定义了所有的拦截器 定义了32个拦截器！ 为了拦截器引用方便，可以通过定义栈的方式引用拦截器， 此时如果引用了栈，栈中的拦截器都会被引用! defaultStack 默认的栈，其中定义默认要执行的18个拦截器！ c. 默认执行的拦截器栈、默认执行的action &lt;default-interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;default-class-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot; /&gt; 1234&lt;interceptor name=&quot;prepare&quot; class=&quot;com.opensymphony.xwork2.interceptor.PrepareInterceptor&quot;/&gt;&lt;interceptor name=&quot;params&quot; class=&quot;com.opensymphony.xwork2.interceptor.ParametersInterceptor&quot;/&gt; 注意：拦截器功能与过滤器功能类似，都拦截资源，但它是struts的概念，只能在struts中用，只拦截action请求;而过滤器是servlet的概念，可以在struts项目、servlet项目用，可以拦截所有的web资源(/index.jsp/servlet/action/img/css/js)。","link":"/2017/06/11/struts2框架(一) 初探/"},{"title":"struts2框架(三)文件上传与下载","text":"通过struts-default.xml里面的fileUpload拦截器实现文件上传与下载。&lt;interceptor name=&quot;fileUpload&quot; class=&quot;org.apache.struts2.interceptor.FileUploadInterceptor&quot;/&gt; 1.FileUploadInterceptor里面的相关方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Sets the allowed extensions * 限制运行的文件的扩展名 * @param allowedExtensions A comma-delimited list of extensions */ public void setAllowedExtensions(String allowedExtensions) { allowedExtensionsSet = TextParseUtil.commaDelimitedStringToSet(allowedExtensions); } /** * Sets the allowed mimetypes * 设置允许的mimetype * @param allowedTypes A comma-delimited list of types */ public void setAllowedTypes(String allowedTypes) { allowedTypesSet = TextParseUtil.commaDelimitedStringToSet(allowedTypes); } /** * Sets the maximum size of an uploaded file * 设置上传的最大文件大小 * @param maximumSize The maximum size in bytes */ public void setMaximumSize(Long maximumSize) { this.maximumSize = maximumSize; } /* (non-Javadoc) * @see com.opensymphony.xwork2.interceptor.Interceptor#intercept(com.opensymphony.xwork2.ActionInvocation) */ public String intercept(ActionInvocation invocation) throws Exception { ActionContext ac = invocation.getInvocationContext(); HttpServletRequest request = (HttpServletRequest) ac.get(ServletActionContext.HTTP_REQUEST); if (!(request instanceof MultiPartRequestWrapper)) { if (LOG.isDebugEnabled()) { ActionProxy proxy = invocation.getProxy(); LOG.debug(getTextMessage(&quot;struts.messages.bypass.request&quot;, new Object[]{proxy.getNamespace(), proxy.getActionName()}, ac.getLocale())); } return invocation.invoke(); } ValidationAware validation = null; Object action = invocation.getAction(); if (action instanceof ValidationAware) { validation = (ValidationAware) action; } MultiPartRequestWrapper multiWrapper = (MultiPartRequestWrapper) request; if (multiWrapper.hasErrors()) { for (String error : multiWrapper.getErrors()) { if (validation != null) { validation.addActionError(error); } if (LOG.isWarnEnabled()) { LOG.warn(error); } } } // bind allowed Files Enumeration fileParameterNames = multiWrapper.getFileParameterNames(); while (fileParameterNames != null &amp;&amp; fileParameterNames.hasMoreElements()) { // get the value of this input tag // 获取标签名file1 String inputName = (String) fileParameterNames.nextElement(); // get the content type String[] contentType = multiWrapper.getContentTypes(inputName); if (isNonEmpty(contentType)) { // get the name of the file from the input tag String[] fileName = multiWrapper.getFileNames(inputName); if (isNonEmpty(fileName)) { // get a File object for the uploaded File File[] files = multiWrapper.getFiles(inputName); if (files != null &amp;&amp; files.length &gt; 0) { List&lt;File&gt; acceptedFiles = new ArrayList&lt;File&gt;(files.length); List&lt;String&gt; acceptedContentTypes = new ArrayList&lt;String&gt;(files.length); List&lt;String&gt; acceptedFileNames = new ArrayList&lt;String&gt;(files.length); String contentTypeName = inputName + &quot;ContentType&quot;; String fileNameName = inputName + &quot;FileName&quot;; for (int index = 0; index &lt; files.length; index++) { if (acceptFile(action, files[index], fileName[index], contentType[index], inputName, validation, ac.getLocale())) { acceptedFiles.add(files[index]); acceptedContentTypes.add(contentType[index]); acceptedFileNames.add(fileName[index]); } } if (!acceptedFiles.isEmpty()) { Map&lt;String, Object&gt; params = ac.getParameters(); params.put(inputName, acceptedFiles.toArray(new File[acceptedFiles.size()])); params.put(contentTypeName, acceptedContentTypes.toArray(new String[acceptedContentTypes.size()])); params.put(fileNameName, acceptedFileNames.toArray(new String[acceptedFileNames.size()])); } } } else { if (LOG.isWarnEnabled()) { LOG.warn(getTextMessage(action, &quot;struts.messages.invalid.file&quot;, new Object[]{inputName}, ac.getLocale())); } } } else { if (LOG.isWarnEnabled()) { LOG.warn(getTextMessage(action, &quot;struts.messages.invalid.content.type&quot;, new Object[]{inputName}, ac.getLocale())); } } } // invoke action return invocation.invoke(); } 2.文件上传与下载实例FileUpload:文件上传Action1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;public class FileUpload extends ActionSupport { // 对应表单：&lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt; private File file1; // 文件名 private String file1FileName; // 文件的类型(MIME) private String file1ContentType; public void setFile1(File file1) { this.file1 = file1; } public void setFile1FileName(String file1FileName) { this.file1FileName = file1FileName; } public void setFile1ContentType(String file1ContentType) { this.file1ContentType = file1ContentType; } @Override public String execute() throws Exception { /****** 拿到上传的文件，进行处理 ******/ // 把文件上传到upload目录 // 获取上传的目录路径 String path = ServletActionContext.getServletContext().getRealPath( &quot;/upload&quot;); // 创建目标文件对象 File destFile = new File(path, file1FileName); // 把上传的文件，拷贝到目标文件中 FileUtils.copyFile(file1, destFile); return SUCCESS; }} DownAction:文件列表展示和下载Action1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.File;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.util.Map;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class DownAction extends ActionSupport { /*************1. 显示所有要下载文件的列表*********************/ public String list() throws Exception { //得到upload目录路径 String path = ServletActionContext.getServletContext().getRealPath(&quot;/upload&quot;); // 目录对象 File file = new File(path); // 得到所有要下载的文件的文件名 String[] fileNames = file.list(); // 保存 ActionContext ac = ActionContext.getContext(); // 得到代表request的map (第二种方式) Map&lt;String,Object&gt; request= (Map&lt;String, Object&gt;) ac.get(&quot;request&quot;); request.put(&quot;fileNames&quot;, fileNames); return &quot;list&quot;; } /*************2. 文件下载*********************/ // 1. 获取要下载的文件的文件名 private String fileName; public void setFileName(String fileName) { // 处理传入的参数中问题(get提交) try { fileName = new String(fileName.getBytes(&quot;ISO8859-1&quot;),&quot;UTF-8&quot;); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } // 把处理好的文件名，赋值 this.fileName = fileName; } //2. 下载提交的业务方法 (在struts.xml中配置返回stream) public String down() throws Exception { return &quot;download&quot;; } // 3. 返回文件流的方法 public InputStream getAttrInputStream(){ return ServletActionContext.getServletContext().getResourceAsStream(&quot;/upload/&quot; + fileName); } // 4. 下载显示的文件名（浏览器显示的文件名） public String getDownFileName() { // 需要进行中文编码 try { fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); } catch (UnsupportedEncodingException e) { throw new RuntimeException(e); } return fileName; } } 配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;upload_&quot; extends=&quot;struts-default&quot;&gt; &lt;!-- 注意： action 的名称不能用关键字&quot;fileUpload&quot; --&gt; &lt;action name=&quot;fileUploadAction&quot; class=&quot;cn.itcast.e_fileupload.FileUpload&quot;&gt; &lt;!-- 限制运行上传的文件的类型 --&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;&gt; &lt;!-- 限制运行的文件的扩展名 --&gt; &lt;param name=&quot;fileUpload.allowedExtensions&quot;&gt;txt,jpg,jar&lt;/param&gt; &lt;!-- 限制运行的类型 【与上面同时使用，取交集】 &lt;param name=&quot;fileUpload.allowedTypes&quot;&gt;text/plain&lt;/param&gt; --&gt; &lt;/interceptor-ref&gt; &lt;result name=&quot;success&quot;&gt;/e/success.jsp&lt;/result&gt; &lt;!-- 配置错误视图 --&gt; &lt;result name=&quot;input&quot;&gt;/e/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;down_*&quot; class=&quot;cn.itcast.e_fileupload.DownAction&quot; method=&quot;{1}&quot;&gt; &lt;!-- 列表展示 --&gt; &lt;result name=&quot;list&quot;&gt;/e/list.jsp&lt;/result&gt; &lt;!-- 下载操作 --&gt; &lt;result name=&quot;download&quot; type=&quot;stream&quot;&gt; &lt;!-- 运行下载的文件的类型:指定为所有的二进制文件类型 --&gt; &lt;param name=&quot;contentType&quot;&gt;application/octet-stream&lt;/param&gt; &lt;!-- 对应的是Action中属性： 返回流的属性【其实就是getAttrInputStream()】 --&gt; &lt;param name=&quot;inputName&quot;&gt;attrInputStream&lt;/param&gt; &lt;!-- 下载头，包括：浏览器显示的文件名 --&gt; &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFileName}&lt;/param&gt; &lt;!-- 缓冲区大小设置 --&gt; &lt;param name=&quot;bufferSize&quot;&gt;1024&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 上传页面表单：123456&lt;form action=&quot;${pageContext.request.contextPath }/fileUploadAction&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;&lt;br/&gt; &lt;%--name的取名file1要和上传Action里面的字段对应--%&gt; 文件:&lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; 文件列表和下载页面：123456789101112131415161718192021&lt;table border=&quot;1&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;文件名&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;c:forEach var=&quot;fileName&quot; items=&quot;${fileNames}&quot; varStatus=&quot;vs&quot;&gt; &lt;tr&gt; &lt;td&gt;${vs.count }&lt;/td&gt; &lt;td&gt;${fileName }&lt;/td&gt; &lt;td&gt; &lt;!-- 构建一个url --&gt; &lt;c:url var=&quot;url&quot; value=&quot;down_down&quot;&gt; &lt;c:param name=&quot;fileName&quot; value=&quot;${fileName}&quot;&gt;&lt;/c:param&gt; &lt;/c:url&gt; &lt;a href=&quot;${url }&quot;&gt;下载&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;","link":"/2017/06/10/struts2框架(三)文件上传与下载/"},{"title":"struts2框架(五) 数据校验,数据回显，模型驱动，防止表单重复提交","text":"1.数据校验 Struts数据效验， 通过拦截器完成 &lt;interceptor name=&quot;validation&quot; class=&quot;org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor&quot;/&gt; 1.1 Struts2进行表单验证(手工方式)a.配置表单1234567891011 &lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath }/user_register.action&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user.userName&quot;&gt; &lt;s:fielderror fieldName=&quot;user.userName&quot;&gt;&lt;/s:fielderror&gt; &lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;user.pwd&quot;&gt; &lt;s:fielderror fieldName=&quot;user.pwd&quot;&gt;&lt;/s:fielderror&gt; &lt;br/&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;user.email&quot;&gt;&lt;br/&gt; 生日：&lt;input type=&quot;text&quot; name=&quot;user.birth&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;br/&gt;&lt;/form&gt; b.UserAction.java 123456789101112131415161718192021222324252627//b.1 代码方式验证Action中所有的方法//注意：如果要想用struts的数据效验功能，必须继承ActionSupport或实现相关接口public class UserAction extends ActionSupport { // 封装请求数据 private User user = new User(); public void setUser(User user) { this.user = user; } public User getUser() { return user; } // 重写数据验证的方法 @Override public void validate() { // 用户名非空 if (user.getUserName() == null || &quot;&quot;.equals(user.getUserName())) { // 保存错误信息 super.addFieldError(&quot;userName&quot;, &quot;用户名必须填写！&quot;); } // 密码 if (user.getPwd() == null || &quot;&quot;.equals(user.getPwd())) { super.addFieldError(&quot;pwd&quot;, &quot;密码必填&quot;); } }} 123456b.2 代码方式验证Action中指定的方法写验证方法命名规则： validate + 要验证的方法名如： public void validateRegister() {} 只会验证当前action的register方法！ 总结代码方式验证： 繁琐，设计很多重复的验证逻辑！例如：非空验证、数值验证、email、日期等。 1.2 XML方式验证Action中所有的方法 Struts对于常用的验证，进行了封装，即提供了验证器， 验证指定的常用业务逻辑！ Struts提供的所有验证器路径：xwork-core-2.3.4.1.jar/com.opensymphony.xwork2.validator.validators/default.xml12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE validators PUBLIC &quot;-//Apache Struts//XWork Validator Definition 1.0//EN&quot; &quot;http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd&quot;&gt;&lt;!-- START SNIPPET: validators-default --&gt;&lt;validators&gt; &lt;validator name=&quot;required&quot; class=&quot;com.opensymphony.xwork2.validator.validators.RequiredFieldValidator&quot;/&gt; &lt;validator name=&quot;requiredstring&quot; class=&quot;com.opensymphony.xwork2.validator.validators.RequiredStringValidator&quot;/&gt; &lt;validator name=&quot;int&quot; class=&quot;com.opensymphony.xwork2.validator.validators.IntRangeFieldValidator&quot;/&gt; &lt;validator name=&quot;long&quot; class=&quot;com.opensymphony.xwork2.validator.validators.LongRangeFieldValidator&quot;/&gt; &lt;validator name=&quot;short&quot; class=&quot;com.opensymphony.xwork2.validator.validators.ShortRangeFieldValidator&quot;/&gt; &lt;validator name=&quot;double&quot; class=&quot;com.opensymphony.xwork2.validator.validators.DoubleRangeFieldValidator&quot;/&gt; &lt;validator name=&quot;date&quot; class=&quot;com.opensymphony.xwork2.validator.validators.DateRangeFieldValidator&quot;/&gt; &lt;validator name=&quot;expression&quot; class=&quot;com.opensymphony.xwork2.validator.validators.ExpressionValidator&quot;/&gt; &lt;validator name=&quot;fieldexpression&quot; class=&quot;com.opensymphony.xwork2.validator.validators.FieldExpressionValidator&quot;/&gt; &lt;validator name=&quot;email&quot; class=&quot;com.opensymphony.xwork2.validator.validators.EmailValidator&quot;/&gt; &lt;validator name=&quot;url&quot; class=&quot;com.opensymphony.xwork2.validator.validators.URLValidator&quot;/&gt; &lt;validator name=&quot;visitor&quot; class=&quot;com.opensymphony.xwork2.validator.validators.VisitorFieldValidator&quot;/&gt; &lt;validator name=&quot;conversion&quot; class=&quot;com.opensymphony.xwork2.validator.validators.ConversionErrorFieldValidator&quot;/&gt; &lt;validator name=&quot;stringlength&quot; class=&quot;com.opensymphony.xwork2.validator.validators.StringLengthFieldValidator&quot;/&gt; &lt;validator name=&quot;regex&quot; class=&quot;com.opensymphony.xwork2.validator.validators.RegexFieldValidator&quot;/&gt; &lt;validator name=&quot;conditionalvisitor&quot; class=&quot;com.opensymphony.xwork2.validator.validators.ConditionalVisitorFieldValidator&quot;/&gt;&lt;/validators&gt;&lt;!-- END SNIPPET: validators-default --&gt; 如果写xml，从而定义验证规则： 1）XML文件名称语法： ActionClassName-validation.xml 注意：此xml需要与当期要验证的action在同一个目录： 举例：UserAction-validation.xml 2） 写XML 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE validators PUBLIC &quot;-//Apache Struts//XWork Validator 1.0.3//EN&quot; &quot;http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd&quot;&gt;&lt;validators&gt; &lt;!-- 验证的每一个字段用field表示 --&gt; &lt;field name=&quot;user.userName&quot;&gt; &lt;!-- 指定使用的验证器 --&gt; &lt;field-validator type=&quot;requiredstring&quot;&gt; &lt;!-- 验证失败的错误提示信息 --&gt; &lt;message&gt;用户名不能为空！&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 验证pwd --&gt; &lt;field name=&quot;user.pwd&quot;&gt; &lt;!-- 非空 --&gt; &lt;field-validator type=&quot;requiredstring&quot;&gt; &lt;message&gt;密码不能为空！&lt;/message&gt; &lt;/field-validator&gt; &lt;!-- 长度 --&gt; &lt;field-validator type=&quot;stringlength&quot;&gt; &lt;param name=&quot;minLength&quot;&gt;6&lt;/param&gt; &lt;param name=&quot;maxLength&quot;&gt;8&lt;/param&gt; &lt;message&gt;密码必须为6-8位！&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 验证日期 --&gt; &lt;field name=&quot;user.birth&quot;&gt; &lt;field-validator type=&quot;date&quot;&gt; &lt;message&gt;日期格式不对！&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;!-- 验证Email --&gt; &lt;field name=&quot;user.email&quot;&gt; &lt;field-validator type=&quot;email&quot;&gt; &lt;message&gt;邮箱格式错误！&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt; &lt;/validators&gt; 如果验证Action中指定的方法:与上面xml验证方式大致相同： 验证xml文件内容不变；1234 文件命名：语法：ActionClassName-ActionName-validation.xml举例：UserAction-user_register-validation.xml 验证UserAction中的register方法 2.数据回显 数据回显，必须要用struts标签！ Action中：12345678910111213141516171819202122// 进入修改页面 public String viewUpdate() { // 模拟一个对象(先获取一个id，再根据id调用service查询，把查到的结果保存到域) User userInfo = new User(); userInfo.setUserName(&quot;Jack&quot;); userInfo.setEmail(&quot;yuanjie@itcast.cn&quot;); ActionContext ac = ActionContext.getContext();// Map&lt;String,Object&gt; request = (Map&lt;String, Object&gt;) ac.get(&quot;request&quot;);// request.put(&quot;userInfo&quot;, userInfo); /************* 数据回显***************/ // 获取值栈 ValueStack vs = ac.getValueStack(); vs.pop();// 移除栈顶元素 vs.push(userInfo); // 入栈 // 进入修改页面 return &quot;viewUpdate&quot;; }``` JSP页面： &lt;%@taglib uri=”/struts-tags” prefix=”s” %&gt; &lt;!-- 手动通过value设置显示的值 &lt;s:form action=&quot;#&quot;&gt; 用户名： &lt;s:textfield name=&quot;user.userName&quot; value=&quot;%{#request.userInfo.userName}&quot;&gt;&lt;/s:textfield&gt; &lt;br/&gt; 邮箱： &lt;s:textfield name=&quot;user.email&quot; value=&quot;%{#request.userInfo.email}&quot;&gt;&lt;/s:textfield&gt; &lt;br/&gt; &lt;/s:form&gt; --&gt; &lt;!-- 数据回显技术：s:textfield会自动查找根元素数据(Ognl表达式语言取值) --&gt; &lt;s:form action=&quot;#&quot;&gt; 用户名： &lt;s:textfield name=&quot;userName&quot;&gt;&lt;/s:textfield&gt; &lt;br/&gt; 邮箱： &lt;s:textfield name=&quot;email&quot;&gt;&lt;/s:textfield&gt; &lt;br/&gt; &lt;/s:form&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 12## 3. 模型驱动 Struts运行时候，会执行默认的拦截器栈，其中有一个拦截器，模型驱动拦截器，可以把请求数据自动填充的action的属性中 12实例：JSP 1234Action1. 实现ModelDriver接口2. 实现接口方法： 接口方法返回的就是要封装的对象3. 对象一定要实例化。 public class UserAction extends ActionSupport implements ModelDriven { // 封装请求数据 private User user = new User(); public void setUser(User user) { this.user = user; } public User getUser() { return user; } // 实现模型驱动接口方法 @Override public User getModel() { return user; } public String add() { // 测试： 使用了模型驱动，是否数据正常？ Ok System.out.println(user); return &quot;success&quot;; } }12345678910111213## 4.防止表单重复提交&gt; Struts提供了防止表单重复提交拦截器：&lt;interceptor name=&quot;token&quot; class=&quot;org.apache.struts2.interceptor.TokenInterceptor&quot;/&gt;用户重复提交表单在某些场合将会造成非常严重的后果。例如，在使用信用卡进行在线支付的时候，如果服务器的响应速度太慢，用户有可能会多次点击提交按钮，而这可能导致那张信用卡上的金额被消费了多次。因此，重复提交表单会对你的系统带来逻辑影响，必须采取一些措施防止这类情况的发生。用户重复提交同一个HTML表单的原因有： 一、快速多次点击了提交按钮；二、提交表单后按下浏览器的刷新按钮。 Struts 2已经内置了能够防止用户重复提交同一个HTML表单的功能。它的工作原理：让服务器生成一个唯一标记，并在服务器和表单里各保存一份这个标记的副本。此后，在用户提交表单的时候，表单里的标记将随着其他请求参数一起发送到服务器，服务器将对他收到的标记和它留存的标记进行比较。如果两者匹配，这次提交的表单被认为是有效的，服务器将对之做出必要的处理并重新设置一个新标记。随后，提交相同的表单就会失败，因为服务器上的标记已经重置。 Struts 2标签中的token标签，可以用来生成一个独一无二的标记。这个标记必须嵌套在form标签中使用，它会在表单里插入一个隐藏字段并把标记保存到HttpSession对象里。toke标签必须与Token或Token Session拦截器配合使用，两个拦截器都能对token标签进行处理。Token拦截器遇到重复提交表单的情况，会返回一个&quot;invalid.token&quot;结果并加上一个动作级别的错误。Token Session拦截器扩展了Token拦截器并提供了一种更复杂的服务，它采取的做法与Token拦截器不同，它只是阻断了后续的提交，这样用户不提交多少次，就好像只是提交了一次。 示例：使用Token拦截器预防表单重复提交### 4.1 配置struts.xml文件，声明动作 &lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;&lt;!DOCTYPE struts PUBLIC “-//Apache Software Foundation//DTD Struts Configuration 2.0//EN” “http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt; &lt;result name=&quot;invalid.token&quot;&gt;/error.jsp&lt;/result&gt; &lt;result name=&quot;input&quot;&gt;/input.jsp&lt;/result&gt; &lt;result name=&quot;success&quot;&gt;/output.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 123此时，需要在动作的声明中，为动作添加token拦截器，因为token拦截器不在defaultStack拦截器栈中，注意，需要将拦截器放在拦截器栈的第一位，这是因为判断表单是否被重复提交的逻辑应该在表单处理前。### 4.2 创建动作类 public class AvoidAction extends ActionSupport { private static final long serialVersionUID = 2676453800249807631L; private String username; private Date birthday; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String execute() { try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } return SUCCESS; } }12345这个动作逻辑处理为挂起4秒钟，让我们有机会多次点击提交按钮，测试效果。### 4.4 创建页面：input.jsp &lt;s:form action=”avoid”&gt; &lt;s:token&gt;&lt;/s:token&gt; &lt;s:textfield name=”username” label=”Enter your name”&gt;&lt;/s:textfield&gt; &lt;s:textfield name=”birthday” label=”Enter your birthday”&gt;&lt;/s:textfield&gt; &lt;s:submit value=”submit”&gt;&lt;/s:submit&gt;&lt;/s:form&gt;1234要使用Struts 2的防止表单重复提交功能，需要在form标签中使用token标签，他会产生一个唯一的标识符，与其他参数一起提交到服务器，服务器会根据token标签所产生的标识符判断表单是否为重复提交的表单，这个功能是由Token拦截器完成的。error.jsp do not duplicate submissions form!1234当表单重复提交，Token拦截器会返回一个&quot;invalid.token&quot;结果，结果将页面转到这个页面，提示用户错误信息。output.jsp Your Name : &lt;s:property value=”username”/&gt; Your Birthday : &lt;s:property value=”birthday”/&gt;` 4.5 测试在浏览器中输入：http://localhost:8080/struts04/input.jsp，输入信息得到如下界面 连续多次点击”submit”按钮，查看效果 可以看到，token拦截器的设置生效了，他阻止了表单的重复提交，并给出了错误提示这次我们只点击一次提交(请重新输入URL，或后退到输入页面后刷新一下，这是因为token的标示在提交一次后已被修改，不刷新标示符是不可能与服务器存留的标示符一致的) 可以看到，表单被正确的处理了。","link":"/2017/06/11/struts2框架(五) 数据校验,数据回显，模型驱动，防止表单重复提交/"},{"title":"struts2框架(四)拦截器，国际化，Ognl表达式","text":"Intercetor, 即为拦截器。1） 在Struts2中，把每一个功能都用一个个的拦截器实现；用户想用struts的哪个功能的时候，可以自由组装使用。2）Struts2中，为了方法用户对拦截器的引用，提供了拦截器栈的定义，里面可以包含多个拦截器。 文件夹(文件, 文件2) 拦截器栈(拦截器,拦截器2)3）Struts2中，如果用户没有指定执行哪些拦截器，struts2有一个默认执行的栈，defaultStack; 一旦如果用户有指定执行哪些拦截器，默认的拦截器栈就不会被执行拦截器的设计，就是基于组件设计的应用！ ##1.自定义拦截器 1.1 编写辅助测试用action1234567891011public class HelloAction extends ActionSupport{ public HelloAction() { System.out.println(&quot;1. Action实例创建了&quot;); } @Override public String execute() throws Exception { System.out.println(&quot;3. 执行了请求处理的方法: execute&quot;); return super.execute(); }} 1.2 编写拦截器类1234567891011121314151617181920212223242526272829303132public class HelloInterceptor implements Interceptor{ // 启动时候执行 public HelloInterceptor(){ System.out.println(&quot;创建了拦截器对象&quot;); } // 启动时候执行 @Override public void init() { System.out.println(&quot;执行了拦截器的初始化方法&quot;); } // 拦截器业务处理方法 （在访问action时候执行？ 在execute之前执行？） @Override public String intercept(ActionInvocation invocation) throws Exception { System.out.println(&quot;2. 执行Action之前&quot;); // 调用下一个拦截器或执行Action (相当于chain.doFilter(..) // 获取的是： execute方法的返回值 String resultFlag = invocation.invoke(); System.out.println(&quot;4. 拦截器，业务处理-结束&quot; + resultFlag); return resultFlag; } @Override public void destroy() { System.out.println(&quot;销毁....&quot;); }} 1.3 进行相关配置123456789101112131415161718192021222324252627282930313233343536&lt;struts&gt; &lt;package name=&quot;hello&quot; extends=&quot;struts-default&quot;&gt; &lt;!-- 【拦截器配置】 --&gt; &lt;interceptors&gt; &lt;!-- 配置用户自定义的拦截器 --&gt; &lt;interceptor name=&quot;helloInterceptor&quot; class=&quot;cn.itcast.a_interceptor.HelloInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;!-- 自定义一个栈： 要引用默认栈、自定义的拦截器 --&gt; &lt;interceptor-stack name=&quot;helloStack&quot;&gt; &lt;!-- 引用默认栈 (一定要放到第一行)--&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; &lt;!-- 引用自定义拦截器 --&gt; &lt;interceptor-ref name=&quot;helloInterceptor&quot;&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 【执行拦截器,第一种写法： 当前包下所有的acntion都执行helloStack栈】 &lt;default-interceptor-ref name=&quot;helloStack&quot;&gt;&lt;/default-interceptor-ref&gt; --&gt; &lt;!-- Action配置 --&gt; &lt;action name=&quot;hello&quot; class=&quot;cn.itcast.a_interceptor.HelloAction&quot;&gt; &lt;!--执行拦截器,第二种写法： 只是在这一个Action中执行helloStack栈 &lt;interceptor-ref name=&quot;defaultStackt&quot;&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=&quot;helloInterceptor&quot;&gt;&lt;/interceptor-ref&gt; --&gt; &lt;!--执行拦截器,第三种写法：执行用户栈(与第二种写法一样， 只在当前aciton中执行自定义栈)--&gt; &lt;interceptor-ref name=&quot;helloStack&quot;&gt;&lt;/interceptor-ref&gt; &lt;result name=&quot;success&quot;&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 当我们访问helloAction时效果如下： 可以看到，如过滤器一样，拦截器的构造方法和初始化也是在tomcat服务器启动时执行，当用户访问action时，先创建action实例，然后执行过滤器intercept方法，再执行action的execute方法，执行完后回到intercept。最扣在tomcat停止服务时会销毁拦截器对象。生命周期时序图如下： 2.国际化 对比servlet的国际化，struts里面更简单 2.1 步骤#####a). 写资源文件12基础名.properties 【默认的语言环境的配置】 基础名_语言简称_国家简称.properties #####b). 读取资源文件，再使用程序：ResourceBundle (同servlet)JSP: 1）jstl表亲啊 （同servlet） 2）struts标签获取资源文件内容 2.2 实例#####1. 写资源文件Msg.properties 默认的语言环境； 找不到配置就找它Msg_en_US.properties 美国 #####2. 加载12&lt;!-- struts.xml 通过常量加载资源文件 --&gt; &lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;cn.acamy.config.msg&quot;&gt;&lt;/constant&gt; #####3. 使用: 标签name值直接写配置文件中的key12&lt;%@taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;&lt;s:text name=&quot;title&quot;&gt;&lt;/s:text&gt; #####推荐用法：123&lt;s:i18n name=&quot;cn.acamy.config.msg&quot;&gt; &lt;s:text&gt; 标签必须放到标签体中。&lt;/s:i18n&gt; 3.Ognl表达式 OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个开源项目。 Struts2框架使用OGNL作为默认的表达式语言。 3.1 OgnlContext 的用法 OGNL 有一个上下文（Context）概念，说白了上下文就是一个MAP结构，它实现了java.utils.Map 的接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import ognl.Ognl;import ognl.OgnlContext;import ognl.OgnlException;import org.junit.Test;// OgnlContext用法public class OgnlDemo1 { /** * 1. Ognl表达式语言语言取值，取非根元素的值，必须用#号 * @throws Exception */ @Test public void testOgnl() throws Exception { // 创建一个Ognl上下文对象 OgnlContext context = new OgnlContext(); // 放入数据 User user = new User(); user.setId(100); user.setName(&quot;Jack&quot;); // 【往非根元素放入数据， 取值的时候表达式要用&quot;#&quot;】 context.put(&quot;user&quot;, user); // 获取数据(map) // 先构建一个Ognl表达式, 再解析表达式 Object ognl = Ognl.parseExpression(&quot;#user.name&quot;); Object value = Ognl.getValue(ognl, context, context.getRoot()); System.out.println(value); } /** * 2. Ognl表达式语言语言取值，取根元素的值，不用带#号 * @throws Exception */ @Test public void testOgn2() throws Exception { // 创建一个Ognl上下文对象 OgnlContext context = new OgnlContext(); // 放入数据 User user = new User(); user.setId(100); user.setName(&quot;Jack&quot;); // 【往根元素放入数据】 context.setRoot(user); // 获取数据(map) // 先构建一个Ognl表达式, 再解析表达式 Object ognl = Ognl.parseExpression(&quot;address.province&quot;); Object value = Ognl.getValue(ognl, context, context.getRoot()); System.out.println(value); } /** * 3.Ognl对 静态方法调用的支持 * @throws Exception */ @Test public void testOgn3() throws Exception { // 创建一个Ognl上下文对象 OgnlContext context = new OgnlContext(); // Ognl表单式语言，调用类的静态方法 //Object ognl = Ognl.parseExpression(&quot;@Math@floor(10.9)&quot;); // 由于Math类在开发中比较常用，所以也可以这样写 Object ognl = Ognl.parseExpression(&quot;@@floor(10.9)&quot;); Object value = Ognl.getValue(ognl, context, context.getRoot()); System.out.println(value); }} 3.2 ValueStack ValueStack实际是一个接口,在Struts2中利用OGNL时，实际上使用的是实现了该接口的OgnlValueStack类,这个类是Struts2利用OGNL的基础。ValueStack贯穿整个 Action 的生命周期(每个 Action 类的对象实例都拥有一个ValueStack 对象). 相当于一个数据的中转站. 在其中保存当前Action 对象和其他相关对象.Struts2框架把 ValueStack 对象保存在名为 “struts.valueStack” 的request请求属性中。 3.2.1 ValueStack的获取123456789101112 // 获取值栈对象的2种方式private void getVs() { // 获取值栈对象，方式1： HttpServletRequest request = ServletActionContext.getRequest(); ValueStack vs1 = (ValueStack) request.getAttribute(&quot;struts.valueStack&quot;); // 获取值栈对象，方式2： ActionContext ac = ActionContext.getContext(); ValueStack vs2 = ac.getValueStack(); System.out.println(vs1 == vs2);// true} 3.2.2 ValueStack的数据结构通过调试可以看到：struts中的ValueStack为其实现类OgnlValueStack,核心包含了作为Map栈的OgnlContext对象和继承了ArrayList的对象栈的CompoudRood对象，其中OgnlContext还封装了CompoudRood对象。 数据结构图如下： 12345678对象栈: Struts 把动作和相关对象压入 ObjectStack 中--ListMap栈: Struts 把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中 Struts 会把下面这些映射压入 ContextMap 中 parameters: 该 Map 中包含当前请求的请求参数 request: 该 Map 中包含当前 request 对象中的所有属性 session: 该 Map 中包含当前 session 对象中的所有属性 application:该 Map 中包含当前 application 对象中的所有属性 attr: 该 Map 按如下顺序来检索某个属性: request, session, application 3.3 Ognl表达式3.3.1 #的作用a) 用来区分访问的是Map栈不审List栈12345#号主要用于访问访问Map栈信息，不使用#号主要用于访问List(对象栈)信息。举例: &lt;s:property value=&quot;#request.username&quot;/&gt; &lt;s:property value=&quot;#request.userpsw&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; // 获取对象栈信息(默认从栈顶检索) Struts2的property 标签中value属性值会特意的将其中的值以OGNL表达式的方式进行运行。 b) 在JSP页面构建Map集合1234567格式：#{key:value,key:value...}举例 Struts2的radio标签主要任务是在页面中显示单选按钮 &lt;s:radio list=&quot;#{&apos;male&apos;:&apos;男&apos;,&apos;female&apos;:&apos;女&apos;}&quot; name=&quot;gender&quot;&gt;&lt;/s:radio&gt;&lt;br/&gt; 运行结果源码: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gendermale&quot; value=&quot;male&quot;/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;genderfemale&quot; value=&quot;female&quot;/&gt;女 3.3.2 $号的作用12345678910$号的作用 在国际化资源文件中,引用OGNL表达式 在Struts2配置文件中,引用OGNL表达式举例 ognl.xml配置文件 &lt;action name=&quot;ognlAction_*&quot; class=&quot;cn.itcast.ognl.OgnlAction&quot; method=&quot;{1}&quot;&gt; &lt;result name=&quot;success&quot;&gt;/ognl/ognl.jsp?username=${#request.username}&lt;/result&gt; &lt;/action&gt; 在ognl.jsp中获取携带的参数： &lt;s:property value=&quot;%{#parameters.username[0]}&quot;/&gt; 3.3.3 %号的作用123456789101112$号的作用 “%”符号的作用是在当Struts2标签的属性值为OGNL表达式时OGNL表达式却被理解为字符串类型原样输出时，用于通知执行环境%{}里的是OGNL表达式。 举例 Struts2中的textfield标签主要用于在页面中显示一个文本输入框数据。类似input &lt;s:textfield value=&quot;#request.username&quot;&gt;&lt;/s:textfield&gt; 此时#request.username被理解为一个普通的字符串，因此直接显示。因为这里脱离了 运行OGNL的环境即：&lt;s:property value=&quot;OGNL表达式&quot;/&gt;环境。 通知运行环境将#request.username以OGNL表达式运行： &lt;s:textfield value=&quot;%{#request.username}&quot;&gt;&lt;/s:textfield&gt;总结 为了方便使用%{}我们可以在任何地方都直接添加%{}来确保运行OGNL表达式： &lt;s:property value=&quot;%{#request.username}&quot;/&gt; 4.Struts2标签4.1 if/elseif/else标签 if/elseif/else 基本的流程控制.‘If’标签可单独使用也可以和‘Else If’标签和(或)一个多个‘Else’一起使用 123&lt;s:if test=&quot;#person.age&lt;24&quot;&gt;少年&lt;/s:if&gt;&lt;s:elseif test=&quot;#person.age&lt;26&quot;&gt;中年&lt;/s:elseif&gt;&lt;s:else&gt;老年&lt;/s:else&gt; 4.2 property标签 用于输出指定值： 123456789格式：&lt;s:property value=“#name&quot; default=&quot;a default value&quot; /&gt; default：可选属性， 如果需要输出的属性值为null，则显示该属性指定的值 escape：可选属性，指定是否格式化HTML代码。 value： 可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值。举例：&lt;s:property value=&quot;#user.id&quot;/&gt;&lt;s:property/&gt;:输出栈顶的值 4.3 debug标签 struts的调试标签：可以观测值栈数据 &lt;s:debug&gt;&lt;/s:debug&gt; 4.4 iterator标签 用于对集合进行迭代，这里的集合包含List、Set和数组。 1234567891011121314151617181920212223&lt;!-- list迭代 --&gt;&lt;s:iterator var=&quot;user&quot; value=&quot;#request.list&quot; status=&quot;st&quot;&gt; &lt;s:property value=&quot;#user.id&quot;/&gt; &lt;s:property value=&quot;#user.name&quot;/&gt;&lt;/s:iterator&gt;&lt;!-- map迭代 --&gt;&lt;s:iterator var=&quot;en&quot; value=&quot;#request.map&quot; status=&quot;st &lt;s:property value=&quot;#en.key&quot;/&gt; &lt;s:property value=&quot;#en.value.name&quot;/&gt;&lt;/s:iterator&gt; &lt;!-- Ognl表达式可以取值，也可以动态构建集合 --&gt; &lt;br/&gt;一、.构建 list集合&lt;/br&gt; &lt;s:iterator var=&quot;str&quot; value=&quot;{&apos;a&apos;,&apos;b&apos;}&quot;&gt; &lt;s:property value=&quot;#str&quot;/&gt; &lt;/s:iterator&gt; &lt;br/&gt;一、.构建 map集合&lt;/br&gt; &lt;s:iterator var=&quot;en&quot; value=&quot;#{&apos;cn&apos;:&apos;China&apos;,&apos;usa&apos;:&apos;America&apos;}&quot;&gt; &lt;s:property value=&quot;#en.key&quot;/&gt; &lt;s:property value=&quot;#en.value&quot;/&gt; &lt;br/&gt; &lt;/s:iterator&gt;","link":"/2017/06/11/struts2框架(四)拦截器，国际化，Ognl表达式/"},{"title":"华为OJ初级1-10","text":"1. 字符串最后一个单词的长度 计算字符串最后一个单词的长度，单词以空格隔开。知识点 字符串,循环运行时间限制 0M内存限制 0输入一行字符串，长度小于128。输出整数N，最后一个单词的长度。样例输入 hello world样例输出 5 123456789101112import ja&lt;!-- more --&gt;va.util.Scanner;public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextLine()){ String tmpStr = sc.nextLine(); String[] arr = tmpStr.split(&quot; &quot;); System.out.println(arr[arr.length - 1].length()); } sc.close(); }} 2.合唱队 计算最少出列多少位同学，使得剩下的同学排成合唱队形说明：N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足存在i（1&lt;=i&lt;=K）使得Ti&lt;T2&lt;……&lt;Ti-1Ti+1&gt;……&gt;TK。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。知识点 循环运行时间限制 0M内存限制 0输入整数N一行整数，空格隔开，N位同学身高输出最少需要几位同学出列样例输入 8 186 186 150 200 160 130 197 200样例输出 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int n = sc.nextInt(); int[] arr = new int[n]; for(int i = 0;i &lt; n;i++){ arr[i] = sc.nextInt(); } int[] inc = new int[n]; inc[0] = 1; for(int i = 1;i &lt; n;i ++){ inc[i] = 1; for(int j = 0;j &lt; i;j ++){ if(arr[j] &lt; arr[i] &amp;&amp; inc[j] + 1 &gt; inc[i]){ inc[i] = inc[j] + 1; } } } int[] des = new int[n]; des[n - 1] = 1; for(int i = n -2;i &gt;=0;i --){ des[i] = 1; for(int j = n - 1;j &gt; i;j --){ if(arr[j] &lt; arr[i] &amp;&amp; des[j] + 1 &gt; des[i]){ des[i] = des[j] + 1; } } } int max = 0; for(int i = 0;i &lt; n;i ++){ if(inc[i] + des[i] - 1&gt; max){ max = inc[i] + des[i] - 1; } } System.out.println(n - max); } sc.close(); }} 3.图片整理 Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过C语言解决。知识点 字符串运行时间限制 0M内存限制 0输入Lily使用的图片包括”A”到”Z”、”a”到”z”、”0”到”9”。输入字母或数字个数不超过1024。输出Lily的所有图片按照从小到大的顺序输出样例输入 Ihave1nose2hands10fingers样例输出 0112Iaadeeefghhinnnorsssv 12345678910111213import java.util.*;public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextLine()){ String str = sc.nextLine(); char[] chs = str.toCharArray(); Arrays.sort(chs); System.out.println(chs); } sc.close(); }} 4.名字的漂亮度 给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。给出多个名字，计算每个名字最大可能的“漂亮度”。知识点 字符串运行时间限制 0M内存限制 0输入整数N，后续N个名字N个字符串，每个表示一个名字输出每个名称可能的最大漂亮程度样例输入 2 zhangsan lisi样例输出 192 101 1234567891011121314151617181920212223242526import java.util.Scanner;import java.util.Arrays;public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNextInt()){ int cnt = Integer.parseInt(sc.nextLine()); int[] nums = new int[cnt]; for(int j= 0;j &lt; cnt;j++){ String str = sc.nextLine().toUpperCase(); int[] ints = new int[26]; for(int i = 0;i &lt; str.length();i++){ ints[str.charAt(i) - &apos;A&apos;] ++; } Arrays.sort(ints); int result = 0; for(int i = 0;i &lt; 26;i++) result += (i+1)*ints[i]; nums[j] = result; } for(int i = 0;i &lt; cnt;i++) System.out.println(nums[i]); } sc.close(); }} 5.（练习用）挑7 输出7有关数字的个数，包括7的倍数，还有包含7的数字（如17，27，37…70，71，72，73…）的个数知识点 循环运行时间限制 0M内存限制 0输入一个正整数N。(N不大于30000)输出不大于N的与7有关的数字个数，例如输入20，与7有关的数字包括7,14,17.样例输入 20样例输出 3 1234567891011121314151617import java.util.Scanner;public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); while(sc.hasNext()){ int N = sc.nextInt(); int sum = 0; for(int i = 1;i &lt;= N;i ++){ if(i % 7 == 0 || String.valueOf(i).toString().contains(&quot;7&quot;)) { sum ++; } } System.out.println(sum); } sc.close(); }} 6.字符串加解密 题目描述1、对输入的字符串进行加解密，并输出。2加密方法为：当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；其他字符不做变化。3、解密方法为加密的逆过程。接口描述： 实现接口，每个接口实现1个基本操作：void Encrypt (char aucPassword[], char aucResult[])：在该函数中实现字符串加密并输出说明：1、字符串以\\0结尾。2、字符串最长100个字符。int unEncrypt (char result[], char password[])：在该函数中实现字符串解密并输出说明：1、字符串以\\0结尾。 2、字符串最长100个字符。知识点 字符串运行时间限制 10M内存限制 128输入输入说明输入一串要加密的密码输入一串加过密的密码输出输出说明输出加密后的字符输出解密后的字符样例输入 abcdefg BCDEFGH样例输出 BCDEFGH abcdefg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String str1 = sc.next(); String str2 = sc.next(); char aucPassword[] = str1.toCharArray(); char aucResult[] = new char[aucPassword.length]; Encrypt(aucPassword, aucResult); System.out.println(aucResult); char result[] = str2.toCharArray(); char password[] = new char[result.length]; unEncrypt(result, password); System.out.println(password); } sc.close(); } public static void Encrypt(char aucPassword[], char aucResult[]) { for (int i = 0; i &lt; aucPassword.length; i++) { char c = aucPassword[i]; if (c &gt;= &apos;a&apos; &amp; c &lt;= &apos;z&apos;) { aucResult[i] = (char) ((c + 1 - &apos;a&apos;) % 26 + &apos;A&apos;); } if (c &gt;= &apos;A&apos; &amp; c &lt;= &apos;Z&apos;) { aucResult[i] = (char) ((c + 1 - &apos;A&apos;) % 26 + &apos;a&apos;); } if (c &gt;= &apos;0&apos; &amp; c &lt;= &apos;9&apos;) { aucResult[i] = (char) ((c + 1 - &apos;0&apos;) % 10 + &apos;0&apos;); } } } public static int unEncrypt(char result[], char password[]) { for (int i = 0; i &lt; result.length; i++) { char c = result[i]; if (c &gt;= &apos;a&apos; &amp; c &lt;= &apos;z&apos;) { password[i] = (char) ((26 + c - 1 - &apos;a&apos;) % 26 + &apos;A&apos;); } if (c &gt;= &apos;A&apos; &amp; c &lt;= &apos;Z&apos;) { password[i] = (char) ((26 + c - 1 - &apos;A&apos;) % 26 + &apos;a&apos;); } if (c &gt;= &apos;0&apos; &amp; c &lt;= &apos;9&apos;) { password[i] = (char) ((10 + c - 1 - &apos;0&apos;) % 10 + &apos;0&apos;); } } return 0; }} 7.蛇形矩阵 蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。样例输入5样例输出1 3 6 10 152 5 9 144 8 137 1211接口说明原型void GetResult(int Num, char pResult);输入参数： int Num：输入的正整数N输出参数： int pResult：指向存放蛇形矩阵的字符串指针 指针指向的内存区域保证有效返回值： void知识点 数组运行时间限制 10M内存限制 128输入输入正整数N（N不大于100）输出输出一个N行的蛇形矩阵。样例输入 4样例输出 1 3 6 10 2 5 9 4 8 7 123456789101112131415161718192021222324import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { int n = sc.nextInt(); int sum = n * (n + 1) / 2; int rowStart = 1; for (int i = 1; i &lt;= n; i++) { rowStart = 1 + i * (i - 1) / 2; System.out.print(rowStart); int tmp = 1 + i; rowStart += tmp; while (rowStart &lt;= sum) { System.out.print(&quot; &quot; + rowStart); tmp++; rowStart += tmp; } System.out.println(); } } }} 8.字符串加密 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词死于字母表的下面，如下所示：A B C D E F G H I J K L M N O P Q R S T U V W X Y ZT R A I L B Z E S C D F G H J K M N O P Q U V W X Y上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。请实现下述接口，通过指定的密匙和明文得到密文。详细描述：接口说明原型：voidencrypt(char key,char data,char encrypt);输入参数： char key：密匙 char data：明文输出参数： char encrypt：密文返回值： void知识点 字符串运行时间限制 10M内存限制 128输入先输入key和要加密的字符串输出返回加密后的字符串样例输入 nihao ni样例输出 le 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNextLine()) { String key = sc.nextLine(); String data = sc.nextLine(); char[] result = encrypt(key, data); System.out.println(result); } } public static char[] encrypt(String key, String data) { key = key.toUpperCase(); String keyDic = &quot;&quot;; for (int i = 0; i &lt; key.length(); i++) { char c = key.charAt(i); if (!keyDic.contains(String.valueOf(c))) keyDic += c; } for (int i = 0; i &lt; 26; i++) { char c = (char) (&apos;A&apos; + i); if (!keyDic.contains(String.valueOf(c))) keyDic += c; } char[] result = data.toCharArray(); for (int i = 0; i &lt; data.length(); i++) { char c = data.charAt(i); if (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;Z&apos;) result[i] = (char) (keyDic.charAt(c - &apos;A&apos;)); if (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;z&apos;) result[i] = (char) (keyDic.charAt(c - &apos;a&apos;) - &apos;A&apos; + &apos;a&apos;); } return result; }} 9. 公共字串计算 题目标题：计算两个字符串的最大公共字串的长度，字符不区分大小写详细描述：接口说明原型：int getCommonStrLength(char pFirstStr, char pSecondStr);输入参数： char pFirstStr //第一个字符串 char pSecondStr//第二个字符串知识点 字符串,查找运行时间限制 10M内存限制 128输入输入两个字符串输出输出一个整数样例输入 asdfas werasdfaswer样例输出 6 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { String str1 = sc.next(); String str2 = sc.next(); int len = str1.length(); int result = 0; for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt;= i; j++) { String subStr = str1.substring(j, j + len - i); if (str2.contains(subStr)) { result = len - i; break; } } if (result &gt; 0) break; } System.out.println(result); } sc.close(); }} 10. 多线程 问题描述：有4个线程和1个公共的字符数组。线程1的功能就是向数组输出A，线程2的功能就是向字符输出B，线程3的功能就是向数组输出C，线程4的功能就是向数组输出D。要求按顺序向数组赋值ABCDABCDABCD，ABCD的个数由线程函数1的参数指定。[注：C语言选手可使用WINDOWS SDK库函数]接口说明：void init(); //初始化函数void Release(); //资源释放函数unsignedint__stdcall ThreadFun1(PVOID pM) ; //线程函数1，传入一个int类型的指针[取值范围：1 – 250，测试用例保证]，用于初始化输出A次数，资源需要线程释放unsignedint__stdcall ThreadFun2(PVOID pM) ;//线程函数2，无参数传入unsignedint__stdcall ThreadFun3(PVOID pM) ;//线程函数3，无参数传入Unsigned int __stdcall ThreadFunc4(PVOID pM);//线程函数4，无参数传入char g_write[1032]; //线程1,2,3,4按顺序向该数组赋值。不用考虑数组是否越界，测试用例保证知识点 字符串,循环,链表,队列,栈,查找,搜索,排序,树,图,数组,函数,指针,枚举,位运算,结构体,联合体,文件操作,递归运行时间限制 10M内存限制 128输入输入一个int整数输出输出多个ABCD样例输入 10样例输出 ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class Main { public static void main(String[] args) throws InterruptedException { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { long start = System.currentTimeMillis(); int n = sc.nextInt(); for (int i = 0; i &lt; n; i++) { // System.out.print(&quot;ABCD&quot;); for (int j = 0; j &lt; 4; j++) { Thread t = new MyThread((char) (&apos;A&apos; + j)); t.start(); t.join(); } } System.out.println(); long end = System.currentTimeMillis(); System.out.println(end - start); } }}class MyThread extends Thread { private char c; public MyThread(char c) { this.c = c; } @Override public void run() { System.out.print(c); }}","link":"/2017/06/16/华为OJ初级1-10/"},{"title":"虚拟机下CentOS7.3配置hadoop2.7.0集群","text":"环境：123456主机配置：win7旗舰版64位，i5处理器，8G内存，500G固态 + 1T机械虚拟机软件：VMwareworkstation_full_12.1.0.2487.1453173744CentOS镜像：CentOS-7-x86_64-Everything-1611SSH工具：Se&lt;!-- more --&gt;cureCRT-v8.0.4jdk：jdk-8u131-linux-x64hadoop:hadoop-2.7.0.tar 效果图： 1.虚拟机设置 注意内存分配，由于系统只有8G内存，而需要配置一主两从，所以我将每个虚拟机的内存设置为2G. centos7.3初始化时并没有ifconfig指令，需要使用下面两个指令进行安装12yum search ifconfgyum install net-tools.x86_64 2. jdk安装a) 在/usr下创建java文件夹并进入该文件夹12mkdir /usr/javacd /usr/java b) 在SecureCRT中使用rz命令将真机中的jdk包传到虚拟机 c) 解压 1234tar zxvf jdk-8u45-linux-x64.tar.gz// 解压后可以删除掉gz文件rm jdk-8u131-linux-x64.gz d) 配置jdk环境变量1234567vi /etc/profile// 将以下数据复制到文件底部export JAVA_HOME=/usr/java/jdk1.8.0_131export JRE_HOME=/usr/java/jdk1.8.0_131/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin e) 使配置生效1source /etc/profile f) 验证安装成功 3. hadoop安装a) 创建文件夹1mkdir -p /export/server b) 同jdk中将安装包上传c) 解压12345tar zxvf hadoop-2.7.0.tar.gzmv hadoop-2.7.0 hadoop// 删除hadoop-2.7.0.tar.gz文件rm –rf hadoop-2.7.0.tar.gz d) 创建tmp文件夹12cd /export/server/hadoopmkdir tmp e) 配置环境变量1234567891011vi /etc/profile// 将以下数据加入到文件末尾export HADOOP_INSTALL=/export/server/hadoop export PATH=${HADOOP_INSTALL}/bin:${HADOOP_INSTALL}/sbin${PATH} export HADOOP_MAPRED_HOME=${HADOOP_INSTALL} export HADOOP_COMMON_HOME=${HADOOP_INSTALL} export HADOOP_HDFS_HOME=${HADOOP_INSTALL} export YARN_HOME=${HADOOP_INSTALLL} export HADOOP_COMMON_LIB_NATIVE_DIR=${HADOOP_INSTALL}/lib/natvie export HADOOP_OPTS=&quot;-Djava.library.path=${HADOOP_INSTALL}/lib:${HADOOP_INSTALL}/lib/native&quot; f) 重启”/etc/profile”使环境变量生效1source /etc/profile g)配置hadoopg1) 设置hadoop-env.sh和yarn-env.sh中的java环境变量123456cd /export/server/hadoop/etc/hadoop/vi hadoop-env.sh// 修改JAVA_HOMEexport JAVA_HOME=/usr/java/jdk1.8.0_131export HADOOP_CONF_DIR=/export/server/hadoop/etc/hadoop g2) 配置core-site.xml文件123456789101112131415&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/export/server/hadoop/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://Master.Hadoop:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; g3) 配置hdfs-site.xml文件12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///export/server/hadoop/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:///export/server/hadoop/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.nameservices&lt;/name&gt; &lt;value&gt;hadoop-cluster1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;Master.Hadoop:50090&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; g4) 配置mapred-site.xml文件123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobtracker.http.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:50030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:19888&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;http://Master.Hadoop:9001&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; g5) 配置yarn-site.xml文件123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;Master.Hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:8031&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;Master.Hadoop:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 4. 主机名配置前面三步基本已经安装好一个我们需要的模板系统，接下来就可以进行复制粘贴直接得到另外两个系统了。并对三个虚拟机的主机名作下更改。1hostnamectl set-hostname master.hadoop 配置好后就需要对三者中的hosts文件进行配置：12345vi /etc/hosts// 将以下数据复制进入各个主机中192.168.44.133 master.hadoop192.168.44.134 slave1.hadoop192.168.44.135 slave2.hadoop 使用以下指令对master主机中进行测试，可使用类似指令在slave主机测试12ping slave1.hadoopping slave2.hadoop #####5. 配置Master无密码登录所有Salve 5.1 Master中的配置a) 输入以下指令生成ssh12ssh-keygen// 会生成两个文件，放到默认的/root/.ssh/文件夹中 b) 把id_rsa.pub追加到授权的key里面去1cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys c) 修改文件”authorized_keys”权限1chmod 600 ~/.ssh/authorized_keys d) 设置SSH配置123456789vi /etc/ssh/sshd_config// 以下三项修改成以下配置RSAAuthentication yes # 启用 RSA 认证PubkeyAuthentication yes # 启用公钥私钥配对认证方式AuthorizedKeysFile .ssh/authorized_keys # 公钥文件路径（和上面生成的文件同） e) 重启ssh服务1service sshd restart f) 把公钥复制所有的Slave机器上12scp ~/.ssh/id_rsa.pub root@192.168.44.134:~/scp ~/.ssh/id_rsa.pub root@192.168.44.135:~/ 5.2 所有Slave中的配置a) 在slave主机上创建.ssh文件夹123mkdir ~/.ssh// 修改权限chmod 700 ~/.ssh b) 追加到授权文件”authorized_keys”1234cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys// 修改权限chmod 600 ~/.ssh/authorized_keys c) 删除无用.pub文件1rm –r ~/id_rsa.pub d) 在master主机下进行测试123ssh 192.168.1.125ssh 192.168.1.124// 如果能够分别无密码登陆slave1, slave2主机，则成功配置 6. 配置Hadoop的集群a) 修改Master主机上的slaves文件123456cd /usr/hadoop/etc/hadoopvi slaves// 将文件内容修改为slave1.hadoopslave2.hadoop b) 格式化HDFS文件系统12// 在Master主机上输入以下指令hadoop namenode -format c) 启动hadoop12345678910// 关闭机器防火墙service iptables stopcd /usr/hadoop/sbin./start-all.sh// 更推荐的运行方式：cd /usr/hadoop/sbin./start-dfs.sh./start-yarn.sh 效果如下： d) 验证hadoop 12// 1. 直接在Master或Slave输入指令：jps Master:(端口号只供参考) Slave:(端口号只供参考) 12// 2. 输入以下指令，效果图参考开篇贴出的hdfs dfsadmin -report e) 进入hadoop管理首页123456// CentOS7中iptables这个服务的配置文件没有了，采用了新的firewalld// 输入以下指令后，可以在真机浏览器上访问hadoop网页systemctl stop firewalld// 在真机浏览器中输入以下网页即可进入http://192.168.44.133:50070/dfshealth.html#tab-overview","link":"/2017/07/06/虚拟机下CentOS7.3配置hadoop2.7.0集群/"},{"title":"详解Java中ThreadLocal的实现与应用","text":"从这个类的名字就能大体了解到类的作用，ThreadLocal可以分解为Thread和Local，前者就不多说了，后者的意思是局部，本地的意思，整个类名可以理解为：线程局部对象或线程本地变量。程序是运行在线程中的，所以，在整个运行过程中，在任何地方都可以获得这个线程的局部对象，ThreadLocal类型的变量是和线程相绑定的。 1.ThreadLocal源码先来看一下涉及到的类图： 12345public T get() {} // 获取ThreadLocal在当前线程中保存的变量副本public void set(T value) {} //用来设置当前线程中变量的副本private T setInitialValue(){} // 设置初始值protected T initialValue(){} //得到初始值，一般是用来在使用时进行重写的void createMap(Thread t, T firstValue) {} // 在线程中对threadLocals成员变量赋值 get方法的实现如下：12345678910111213public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue();} get方法首先取得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。然后接着下面获取到&lt;key,value&gt;键值对，注意这里获取键值对传进去的是this，而不是当前线程t。如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。接下来看一下getMap方法的源码：123ThreadLocalMap getMap(Thread t) { return t.threadLocals; } 在getMap中，是调用当期线程t，返回当前线程t中的一个成员变量threadLocals。 那就看一下Thread类是的threadLocals是什么。1ThreadLocal.ThreadLocalMap threadLocals = null; 实际上就是一个ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们继续取看ThreadLocalMap的实现.123456789101112static class ThreadLocalMap { static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } }...} 这里只贴出部份源码，熟悉HashMap源码的同学很快就会反映到这和HashMap的实现非常类似，在这里我就暂且可以将ThreadLocalMap理解为一个Map，即键值对形式的数据结构。 然后看一下setInitialValue方法的具体实现：123456789101112131415161718private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } protected T initialValue() { return null; } 很容易了解，就是如果map不为空，就设置键值对。如果为空，就创建Map。在createMap方法里面以this(即ThreadLocal类型的变量)为值，以变量为键进行存储，即存储在当前线程中的threadLocals里面。同时源码中initialValue方法返回的是一个空值，所以我们在实际实用时为了防止空指针异常，在调用get方法前要么对initialValue方法进行重写，要么先调用set方法进行初始值的显示设置。下面看看set方法的源码：12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } 有了上面的分析，set方法还是很容易理解的。现在对ThreadLocal是如何为每个线程创建变量的副本的作一个小的总结： 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 2.实例2.1 实例一:在调用get前先要使用set进行设置1234567891011121314151617181920212223242526272829303132333435363738394041package com.hust.hebh.concurrency;public class ThreadLocalTest { ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(); ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(); public void set() { longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); } public long getLong() { return longLocal.get(); } public String getString() { return stringLocal.get(); } public static void main(String[] args) throws InterruptedException { final ThreadLocalTest test = new ThreadLocalTest(); test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread(){ public void run() { test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); }; }; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); }} 从这段代码的输出结果可以看出，在main线程中和thread1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次在main线程再次打印副本值是为了证明在main线程中和thread1线程中的副本值确实是不同的。 总结一下： 1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； 3）在进行get之前，必须先set，否则会报空指针异常； 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 2.2 实例二,重写initialValue方法 在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。下面看看如何对initialValue方法进行重写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hust.hebh.concurrency;public class ThreadLocalDemo { ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(){ protected Long initialValue() { return Thread.currentThread().getId(); }; }; ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(){; protected String initialValue() { return Thread.currentThread().getName(); }; }; public void set() { longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); } public long getLong() { return longLocal.get(); } public String getString() { return stringLocal.get(); } public static void main(String[] args) throws InterruptedException { final ThreadLocalDemo test = new ThreadLocalDemo(); //test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread(){ public void run() { //test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); }; }; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); }} 通过对对initialValue方法进行重写在不进行set的情况下就可以实现和实例一相同的效果。 3. ThreadLocal的应用场景 最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。 下面来看一个hibernate中典型的ThreadLocal的应用：1234567891011121314private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } 可以看到在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap（下面会讲到），而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。这个session相当于线程的私有变量，而不是public的。显然，其他线程中是取不到这个session的，他们也只能取到自己的ThreadLocalMap中的东西。要是session是多个线程共享使用的，那还不乱套了。试想如果不用ThreadLocal怎么来实现呢？可能就要在action中创建session，然后把session一个个传到service和dao中，这可够麻烦的。或者可以自己定义一个静态的map，将当前thread作为key，创建的session作为值，put到map中，应该也行，这也是一般人的想法，但事实上，ThreadLocal的实现刚好相反，它是在每个线程中有一个map，而将ThreadLocal实例作为key，这样每个map中的项数很少，而且当线程销毁时相应的东西也一起销毁了，不知道除了这些还有什么其他的好处。 总之，ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。归纳了两点：1。每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。2。将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 当然如果要把本来线程共享的对象通过ThreadLocal.set()放到线程中也可以，可以实现避免参数传递的访问方式，但是要注意get()到的是那同一个共享对象，并发访问问题要靠其他手段来解决。但一般来说线程共享的对象通过设置为某类的静态变量就可以实现方便的访问了，似乎没必要放到线程中。 ThreadLocal的应用场合，我觉得最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。","link":"/2017/07/05/详解Java中ThreadLocal的实现与应用/"},{"title":"AWS V4签名认证(Java实现)","text":"最近第三方新增的的HTTP API采用了亚马逊提供的签名算法，借此机会学习一下认证过程，并提供Java实现。该认证首先需要第三方提供的accessKey，secretKey等相关参数，然后根据官方提供的算法计算出认证字段并添加到请求的headers中，请示到达第三方服务器会对headers中的认证参数进行对比，如果一致才能请求成功，否则返回401码(未被授权)。亚马逊提供的这套认证算法最后需要往headers字段中添加Authorization标头, 具体可以查看如下示例。 如果没有认证你发送的请求是这样的话：123GET /?Param2=value2&amp;Param1=value1 HTTP/1.1Host:example.amazonaws.comX-Amz-Date:20150830T123600Z 添加认证后就应该是这样：1234GET /?Param2=value2&amp;Param1=value1 HTTP/1.1Host:example.amazonaws.comX-Amz-Date:20150830T123600ZAuthorization: AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=b97d918cfa904a5beff61c982a1b6f458b799221646efd99d3219ec94cdf2500 Authorization标头包含如下信息： 用于签名的算法 (AWS4-HMAC-SHA256) 凭证范围（包含您的访问密钥 ID） 已签名标头的列表 计算签名。该签名基于您的请求信息，由您使用 AWS 秘密访问密钥生成。该签名用于向 AWS 确认您的身份。该部分也是最关键的部分。 1. 认证流程 创建规范请求-&gt;创建待签字符串-&gt;计算签名-&gt;将签名信息添加到请求，下面以官方提供的测试套件说明文档进行列举。 首先需要知道： 凭证范围：AKIDEXAMPLE/20150830/us-east-1/service/aws4_request 私有密钥：wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY 原始请求：123GET /?Param2=value2&amp;Param1=value1 HTTP/1.1Host:example.amazonaws.comX-Amz-Date:20150830T123600Z ####1.1 创建规范请求12345678GET/Param1=value1&amp;Param2=value2host:example.amazonaws.comx-amz-date:20150830T123600Zhost;x-amz-datee3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 注意： 参数按字母顺序（依据字符代码）进行排序。 标头名称小写。 在 x-amz-date 标头与已签名标头之间有一个换行符。 负载的哈希是空字符串的哈希。 ####1.2 创建待签字符串规范请求的哈希值返回以下值：816cd5b414d056048ba4f7c5386d6e0533120fb1fcfa93762cf0fc39e2cf19e0添加算法、请求日期、凭证范围和规范请求哈希以创建待签字符串：1234AWS4-HMAC-SHA25620150830T123600Z20150830/us-east-1/service/aws4_request816cd5b414d056048ba4f7c5386d6e0533120fb1fcfa93762cf0fc39e2cf19e0 注意： 第二行的日期与 x-amz-date 标头以及凭证范围的第一个元素匹配。 最后一行为规范请求的十六进制编码哈希值。 1.3 计算签名用签名密钥和待签名字符串创建签名AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=b97d918cfa904a5beff61c982a1b6f458b799221646efd99d3219ec94cdf2500 ####1.4 将签名信息添加到请求1234GET /?Param2=value2&amp;Param1=value1 HTTP/1.1Host:example.amazonaws.comX-Amz-Date:20150830T123600ZAuthorization: AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=b97d918cfa904a5beff61c982a1b6f458b799221646efd99d3219ec94cdf2500 上述的示例将用下面实现的算法来进行举例说明。 2. Java实现2.1 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Map;import java.util.TimeZone;import java.util.TreeMap;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;/** * AWS V4 签名处理工具 * * 参考链接：https://docs.aws.amazon.com/zh_cn/general/latest/gr/sigv4_signing.html */public class AWSV4Auth { private AWSV4Auth() { } public static class Builder { private String accessKeyID; private String secretAccessKey; private String regionName; private String serviceName; private String httpMethodName; private String canonicalURI; private TreeMap&lt;String, String&gt; queryParametes; private TreeMap&lt;String, String&gt; awsHeaders; private String payload; private boolean debug = false; public Builder(String accessKeyID, String secretAccessKey) { this.accessKeyID = accessKeyID; this.secretAccessKey = secretAccessKey; } public Builder regionName(String regionName) { this.regionName = regionName; return this; } public Builder serviceName(String serviceName) { this.serviceName = serviceName; return this; } public Builder httpMethodName(String httpMethodName) { this.httpMethodName = httpMethodName; return this; } public Builder canonicalURI(String canonicalURI) { this.canonicalURI = canonicalURI; return this; } public Builder queryParametes(TreeMap&lt;String, String&gt; queryParametes) { this.queryParametes = queryParametes; return this; } public Builder awsHeaders(TreeMap&lt;String, String&gt; awsHeaders) { this.awsHeaders = awsHeaders; return this; } public Builder payload(String payload) { this.payload = payload; return this; } public Builder debug() { this.debug = true; return this; } public AWSV4Auth build() { return new AWSV4Auth(this); } } private String accessKeyID; private String secretAccessKey; private String regionName; private String serviceName; private String httpMethodName; private String canonicalURI; private TreeMap&lt;String, String&gt; queryParametes; private TreeMap&lt;String, String&gt; awsHeaders; private String payload; private boolean debug = false; /* Other variables */ private final String HMACAlgorithm = &quot;AWS4-HMAC-SHA256&quot;; private final String aws4Request = &quot;aws4_request&quot;; private String strSignedHeader; private String xAmzDate; private String currentDate; private AWSV4Auth(Builder builder) { accessKeyID = builder.accessKeyID; secretAccessKey = builder.secretAccessKey; regionName = builder.regionName; serviceName = builder.serviceName; httpMethodName = builder.httpMethodName; canonicalURI = builder.canonicalURI; queryParametes = builder.queryParametes; awsHeaders = builder.awsHeaders; payload = builder.payload; debug = builder.debug; /* Get current timestamp value.(UTC) */ xAmzDate = getTimeStamp(); currentDate = getDate(); } /** * 任务 1：针对签名版本 4 创建规范请求 * * @return */ private String prepareCanonicalRequest() { StringBuilder canonicalURL = new StringBuilder(&quot;&quot;); /* Step 1.1 以HTTP方法(GET, PUT, POST, etc.)开头, 然后换行. */ canonicalURL.append(httpMethodName).append(&quot;\\n&quot;); /* Step 1.2 添加URI参数，换行. */ canonicalURI = canonicalURI == null || canonicalURI.trim().isEmpty() ? &quot;/&quot; : canonicalURI; canonicalURL.append(canonicalURI).append(&quot;\\n&quot;); /* Step 1.3 添加查询参数，换行. */ StringBuilder queryString = new StringBuilder(&quot;&quot;); if (queryParametes != null &amp;&amp; !queryParametes.isEmpty()) { for (Map.Entry&lt;String, String&gt; entrySet : queryParametes.entrySet()) { String key = entrySet.getKey(); String value = entrySet.getValue(); queryString.append(key).append(&quot;=&quot;).append(encodeParameter(value)).append(&quot;&amp;&quot;); } queryString.deleteCharAt(queryString.lastIndexOf(&quot;&amp;&quot;)); queryString.append(&quot;\\n&quot;); } else { queryString.append(&quot;\\n&quot;); } canonicalURL.append(queryString); /* Step 1.4 添加headers, 每个header都需要换行. */ StringBuilder signedHeaders = new StringBuilder(&quot;&quot;); if (awsHeaders != null &amp;&amp; !awsHeaders.isEmpty()) { for (Map.Entry&lt;String, String&gt; entrySet : awsHeaders.entrySet()) { String key = entrySet.getKey(); String value = entrySet.getValue(); signedHeaders.append(key).append(&quot;;&quot;); canonicalURL.append(key).append(&quot;:&quot;).append(value).append(&quot;\\n&quot;); } canonicalURL.append(&quot;\\n&quot;); } else { canonicalURL.append(&quot;\\n&quot;); } /* Step 1.5 添加签名的headers并换行. */ strSignedHeader = signedHeaders.substring(0, signedHeaders.length() - 1); // 删掉最后的 &quot;;&quot; canonicalURL.append(strSignedHeader).append(&quot;\\n&quot;); /* Step 1.6 对HTTP或HTTPS的body进行SHA256处理. */ payload = payload == null ? &quot;&quot; : payload; canonicalURL.append(generateHex(payload)); if (debug) { System.out.println(&quot;##Canonical Request:\\n&quot; + canonicalURL.toString()); } return canonicalURL.toString(); } /** * 任务 2：创建签名版本 4 的待签字符串 * * @param canonicalURL * @return */ private String prepareStringToSign(String canonicalURL) { String stringToSign = &quot;&quot;; /* Step 2.1 以算法名称开头，并换行. */ stringToSign = HMACAlgorithm + &quot;\\n&quot;; /* Step 2.2 添加日期，并换行. */ stringToSign += xAmzDate + &quot;\\n&quot;; /* Step 2.3 添加认证范围，并换行. */ stringToSign += currentDate + &quot;/&quot; + regionName + &quot;/&quot; + serviceName + &quot;/&quot; + aws4Request + &quot;\\n&quot;; /* Step 2.4 添加任务1返回的规范URL哈希处理结果，然后换行. */ stringToSign += generateHex(canonicalURL); if (debug) { System.out.println(&quot;##String to sign:\\n&quot; + stringToSign); } return stringToSign; } /** * 任务 3：为 AWS Signature 版本 4 计算签名 * * @param stringToSign * @return */ private String calculateSignature(String stringToSign) { try { /* Step 3.1 生成签名的key */ byte[] signatureKey = getSignatureKey(secretAccessKey, currentDate, regionName, serviceName); /* Step 3.2 计算签名. */ byte[] signature = HmacSHA256(signatureKey, stringToSign); /* Step 3.2.1 对签名编码处理 */ String strHexSignature = bytesToHex(signature); return strHexSignature; } catch (Exception ex) { ex.printStackTrace(); } return null; } /** *任务 4：将签名信息添加到请求并返回headers * * @return */ public Map&lt;String, String&gt; getHeaders() { awsHeaders.put(&quot;x-amz-date&quot;, xAmzDate); /* 执行任务 1: 创建aws v4签名的规范请求字符串. */ String canonicalURL = prepareCanonicalRequest(); /* 执行任务 2: 创建用来认证的字符串 4. */ String stringToSign = prepareStringToSign(canonicalURL); /* 执行任务 3: 计算签名. */ String signature = calculateSignature(stringToSign); if (signature != null) { Map&lt;String, String&gt; header = new HashMap&lt;String, String&gt;(0); header.put(&quot;x-amz-date&quot;, xAmzDate); header.put(&quot;Authorization&quot;, buildAuthorizationString(signature)); if (debug) { System.out.println(&quot;##Signature:\\n&quot; + signature); System.out.println(&quot;##Header:&quot;); for (Map.Entry&lt;String, String&gt; entrySet : header.entrySet()) { System.out.println(entrySet.getKey() + &quot; = &quot; + entrySet.getValue()); } System.out.println(&quot;================================&quot;); } return header; } else { if (debug) { System.out.println(&quot;##Signature:\\n&quot; + signature); } return null; } } /** * 连接前几步处理的字符串生成Authorization header值. * * @param strSignature * @return */ private String buildAuthorizationString(String strSignature) { return HMACAlgorithm + &quot; &quot; + &quot;Credential=&quot; + accessKeyID + &quot;/&quot; + getDate() + &quot;/&quot; + regionName + &quot;/&quot; + serviceName + &quot;/&quot; + aws4Request + &quot;, &quot; + &quot;SignedHeaders=&quot; + strSignedHeader + &quot;, &quot; + &quot;Signature=&quot; + strSignature; } /** * 将字符串16进制化. * * @param data * @return */ private String generateHex(String data) { MessageDigest messageDigest; try { messageDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); messageDigest.update(data.getBytes(&quot;UTF-8&quot;)); byte[] digest = messageDigest.digest(); return String.format(&quot;%064x&quot;, new java.math.BigInteger(1, digest)); } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) { e.printStackTrace(); } return null; } /** * 以给定的key应用HmacSHA256算法处理数据. * * @param data * @param key * @return * @throws Exception * @reference: * http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-java */ private byte[] HmacSHA256(byte[] key, String data) throws Exception { String algorithm = &quot;HmacSHA256&quot;; Mac mac = Mac.getInstance(algorithm); mac.init(new SecretKeySpec(key, algorithm)); return mac.doFinal(data.getBytes(&quot;UTF8&quot;)); } /** * 生成AWS 签名 * * @param key * @param date * @param regionName * @param serviceName * @return * @throws Exception * @reference * http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-java */ private byte[] getSignatureKey(String key, String date, String regionName, String serviceName) throws Exception { byte[] kSecret = (&quot;AWS4&quot; + key).getBytes(&quot;UTF8&quot;); byte[] kDate = HmacSHA256(kSecret, date); byte[] kRegion = HmacSHA256(kDate, regionName); byte[] kService = HmacSHA256(kRegion, serviceName); byte[] kSigning = HmacSHA256(kService, aws4Request); return kSigning; } final protected static char[] hexArray = &quot;0123456789ABCDEF&quot;.toCharArray(); /** * 将字节数组转换为16进制字符串 * * @param bytes * @return */ private String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j &lt; bytes.length; j++) { int v = bytes[j] &amp; 0xFF; hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4]; hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F]; } return new String(hexChars).toLowerCase(); } /** * 获取yyyyMMdd&apos;T&apos;HHmmss&apos;Z&apos;格式的当前时间 * * @return */ private String getTimeStamp() { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&apos;T&apos;HHmmss&apos;Z&apos;&quot;); dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));//server timezone return dateFormat.format(new Date()); } /** * 获取yyyyMMdd格式的当前日期 * * @return */ private String getDate() { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));//server timezone return dateFormat.format(new Date()); } /** * UTF-8编码 * @param param * @return */ private String encodeParameter(String param){ try { return URLEncoder.encode(param, &quot;UTF-8&quot;); } catch (Exception e) { return URLEncoder.encode(param); } }} 2.2 Example首先要有一点小改造，为了验证算法的准确信，必须保证参数的一致。因此可以对工具类中的getDate方法和getTimeStamp进行直接返回，实际中不必这么做。 123456789101112private String getTimeStamp() { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&apos;T&apos;HHmmss&apos;Z&apos;&quot;); dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));//server timezone //return dateFormat.format(new Date()); return &quot;20150830T123600Z&quot;;}private String getDate() { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); dateFormat.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;));//server timezone //return dateFormat.format(new Date()); return &quot;20150830&quot;;} 测试类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.example.aws4vauth.AWSV4Auth;import org.junit.Test;import java.util.Map;import java.util.TreeMap;public class AWSV4AuthTest { private static final String host = &quot;example.amazonaws.com&quot;; private static final String accessKey = &quot;AKIDEXAMPLE&quot;; private static final String secretKey = &quot;wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY&quot;; private static final String region = &quot;us-east-1&quot;; private static final String service = &quot;service&quot;; public Map&lt;String, String&gt; auth(String uri, String method, TreeMap&lt;String, String&gt; params, String data){ TreeMap&lt;String, String&gt; awsHeaders = new TreeMap&lt;String, String&gt;(); awsHeaders.put(&quot;host&quot;, host); return new AWSV4Auth.Builder(accessKey, secretKey) .regionName(region) .serviceName(service) .httpMethodName(method) .canonicalURI(uri) .queryParametes(params) .awsHeaders(awsHeaders) .payload(data) .debug() .build() .getHeaders(); } @Test public void Test(){ String uri = &quot;/&quot;; TreeMap&lt;String, String&gt; awsHeaders = new TreeMap&lt;String, String&gt;(); awsHeaders.put(&quot;host&quot;, host); TreeMap&lt;String, String&gt; params = new TreeMap&lt;String, String&gt;(); params.put(&quot;Param1&quot;,&quot;value1&quot;); params.put(&quot;Param2&quot;,&quot;value2&quot;); Map&lt;String, String&gt; header = auth(uri, &quot;GET&quot;, params, null); for (Map.Entry&lt;String, String&gt; entrySet : header.entrySet()) { String key = entrySet.getKey(); String value = entrySet.getValue(); } }} 输出：1234567891011121314151617181920##Canonical Request:GET/Param1=value1&amp;Param2=value2host:example.amazonaws.comx-amz-date:20150830T123600Zhost;x-amz-datee3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855##String to sign:AWS4-HMAC-SHA25620150830T123600Z20150830/us-east-1/service/aws4_request816cd5b414d056048ba4f7c5386d6e0533120fb1fcfa93762cf0fc39e2cf19e0##Signature:b97d918cfa904a5beff61c982a1b6f458b799221646efd99d3219ec94cdf2500##Header:x-amz-date = 20150830T123600ZAuthorization = AWS4-HMAC-SHA256 Credential=AKIDEXAMPLE/20150830/us-east-1/service/aws4_request, SignedHeaders=host;x-amz-date, Signature=b97d918cfa904a5beff61c982a1b6f458b799221646efd99d3219ec94cdf2500================================ 可以看到生成的签名与官方地完全一致，验证了算法实现的准确性。另也支持POST, DELETE, PATCH等请求，这里就不一一列举了，需要注意的如果有body话传入的paykload字符串应该为json格式。 参考链接：https://docs.aws.amazon.com/zh_cn/general/latest/gr/sigv4_signing.htmlhttps://docs.aws.amazon.com/zh_cn/general/latest/gr/signature-v4-test-suite.html#signature-v4-test-suite-derived-creds","link":"/2018/10/14/AWS V4签名认证(Java实现)/"},{"title":"Hibernate构架( 二） 映射","text":"1.集合映射 Hibernate集合映射里面有set,list,map，具体的用法可以参见如下例 需求：一个用户对应多个地址User.java1234567891011// javabean设计public class User { private int userId; private&lt;!-- more --&gt; String userName; // 一个用户，对应的多个地址 private Set&lt;String&gt; address; private List&lt;String&gt; addressList = new ArrayList&lt;String&gt;(); //private String[] addressArray; // 映射方式和list一样 &lt;array name=&quot;&quot;&gt;&lt;/array&gt; private Map&lt;String,String&gt; addressMap = new HashMap&lt;String, String&gt;();// get,set省略...} User.hbm.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.a_collection&quot;&gt; &lt;class name=&quot;User&quot; table=&quot;t_user&quot;&gt; &lt;id name=&quot;userId&quot; column=&quot;id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;userName&quot;&gt;&lt;/property&gt; &lt;!-- set集合属性的映射 name 指定要映射的set集合的属性 table 集合属性要映射到的表 key 指定集合表(t_address)的外键字段 element 指定集合表的其他字段 type 元素类型，一定要指定 --&gt; &lt;set name=&quot;address&quot; table=&quot;t_address&quot;&gt; &lt;key column=&quot;uid&quot;&gt;&lt;/key&gt; &lt;element column=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/set&gt; &lt;!-- list集合映射 list-index 指定的是排序列的名称 (因为要保证list集合的有序) --&gt; &lt;list name=&quot;addressList&quot; table=&quot;t_addressList&quot;&gt; &lt;key column=&quot;uid&quot;&gt;&lt;/key&gt; &lt;list-index column=&quot;idx&quot;&gt;&lt;/list-index&gt; &lt;element column=&quot;address&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/list&gt; &lt;!-- map集合的映射 key 指定外键字段 map-key 指定map的key element 指定map的value --&gt; &lt;map name=&quot;addressMap&quot; table=&quot;t_addressMap&quot;&gt; &lt;key column=&quot;uid&quot;&gt;&lt;/key&gt; &lt;map-key column=&quot;shortName&quot; type=&quot;string&quot; &gt;&lt;/map-key&gt; &lt;element column=&quot;address&quot; type=&quot;string&quot; &gt;&lt;/element&gt; &lt;/map&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; set测试1234567891011121314151617181920212223242526272829private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(User.class) // 测试时候使用 .buildSessionFactory(); } // 保存set @Test public void testSaveSet() throws Exception { Session session = sf.openSession(); session.beginTransaction(); //-- 保存 Set&lt;String&gt; addressSet = new HashSet&lt;String&gt;(); addressSet.add(&quot;广州&quot;); addressSet.add(&quot;深圳&quot;); // 用户对象 User user = new User(); user.setUserName(&quot;Jack&quot;); user.setAddress(addressSet); // 保存 session.save(user); session.getTransaction().commit(); session.close(); } 效果如下：123Hibernate: insert into t_user (userName) values (?)Hibernate: insert into t_address (uid, address) values (?, ?)Hibernate: insert into t_address (uid, address) values (?, ?) list测试12345678910111213141516// 保存list/map @Test public void testSaveList() throws Exception { Session session = sf.openSession(); session.beginTransaction(); User user = new User(); user.setUserName(&quot;Tom&quot;); // 用户对象 -- list user.getAddressList().add(&quot;广州&quot;); user.getAddressList().add(&quot;深圳&quot;); // 保存 session.save(user); session.getTransaction().commit(); session.close(); } 效果如下： 123Hibernate: insert into t_user (userName) values (?)Hibernate: insert into t_addressList (uid, idx, address) values (?, ?, ?)Hibernate: insert into t_addressList (uid, idx, address) values (?, ?, ?) map测试1234567891011121314151617@Test public void testSaveMap() throws Exception { Session session = sf.openSession(); session.beginTransaction(); User user = new User(); user.setUserName(&quot;Tom&quot;); // 用户对象 -- Map user.getAddressMap().put(&quot;A0001&quot;, &quot;广州&quot;); user.getAddressMap().put(&quot;A0002&quot;, &quot;深圳&quot;); // 保存 session.save(user); session.getTransaction().commit(); session.close(); } 效果如下：123Hibernate: insert into t_user (userName) values (?)Hibernate: insert into t_addressMap (uid, shortName, address) values (?, ?, ?)Hibernate: insert into t_addressMap (uid, shortName, address) values (?, ?, ?) 获取数据测试1234567891011121314151617 @Testpublic void testGet() throws Exception { Session session = sf.openSession(); session.beginTransaction(); // 获取 User user = (User) session.get(User.class, 3); // 及时加载 System.out.println(user.getUserId()); System.out.println(user.getUserName()); // 当查询用户，同时可以获取用户关联的list集合的数据 (因为有正确映射) // 当使用到集合数据的使用，才向数据库发送执行的sql语句 (懒加载) System.out.println(user.getAddressList()); session.getTransaction().commit(); session.close();} 效果如下：12345Hibernate: select user0_.id as id0_0_, user0_.userName as userName0_0_ from t_user user0_ where user0_.id=?3TomHibernate: select addresslis0_.uid as uid0_0_, addresslis0_.address as address0_, addresslis0_.idx as idx0_ from t_addressList addresslis0_ where addresslis0_.uid=?[广州, 深圳] 2.关联映射2.1 一对多与多对一 需求1：部门与员工 一个部门有多个员工; 【一对多】 多个员工，属于一个部门 【多对一】 Employee.java1234567public class Employee { private int empId; private String empName; private double salary; // 【多对一】员工与部门 private Dept dept;} Employee.hbm.xml123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.b_one2Many&quot;&gt; &lt;class name=&quot;Employee&quot; table=&quot;t_employee&quot;&gt; &lt;id name=&quot;empId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;empName&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;salary&quot; type=&quot;double&quot;&gt;&lt;/property&gt; &lt;!-- 多对一映射配置 Employee 映射关键点： 1. 映射的部门属性 ： dept 2. 映射的部门属性，对应的外键字段: dept_id 3. 部门的类型 --&gt; &lt;many-to-one name=&quot;dept&quot; column=&quot;dept_id&quot; class=&quot;Dept&quot;&gt;&lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; Dept.java123456public class Dept { private int deptId; private String deptName; // 【一对多】 部门对应的多个员工 private Set&lt;Employee&gt; emps = new HashSet&lt;Employee&gt;();} Dept.hbm.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.b_one2Many&quot;&gt; &lt;class name=&quot;Dept&quot; table=&quot;t_dept&quot;&gt; &lt;id name=&quot;deptId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;deptName&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;!-- 一对多关联映射配置 （通过部门管理到员工） Dept 映射关键点： 1. 指定 映射的集合属性： &quot;emps&quot; 2. 集合属性对应的集合表： &quot;t_employee&quot; 3. 集合表的外键字段 &quot;t_employee. dept_id&quot; 4. 集合元素的类型 inverse=false set集合映射的默认值； 表示有控制权 --&gt; &lt;set name=&quot;emps&quot; cascade=&quot;save-update,delete&quot; table=&quot;t_employee&quot; inverse=&quot;true&quot;&gt; &lt;!-- table=&quot;t_employee&quot; --&gt; &lt;key column=&quot;dept_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;Employee&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 测试保存：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class App1_save { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } // 保存， 部门方 【一的一方法操作】 @Test public void save() { Session session = sf.openSession(); session.beginTransaction(); // 部门对象 Dept dept = new Dept(); dept.setDeptName(&quot;应用开发部&quot;); // 员工对象 Employee emp_zs = new Employee(); emp_zs.setEmpName(&quot;张三&quot;); Employee emp_ls = new Employee(); emp_ls.setEmpName(&quot;李四&quot;); // 关系 dept.getEmps().add(emp_zs); dept.getEmps().add(emp_ls); // 保存 session.save(emp_zs); session.save(emp_ls); session.save(dept); // 保存部门，部门下所有的员工 session.getTransaction().commit(); session.close(); /* * 结果 当Dept.hbm.xml里的inverse属性为false时 * Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?) Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?) Hibernate: insert into t_dept (deptName) values (?) Hibernate: update t_employee set deptId=? where empId=? 维护员工引用的部门的id Hibernate: update t_employee set deptId=? where empId=? */ } // 【推荐】 保存， 部员方 【多的一方法操作】 @Test public void save2() { Session session = sf.openSession(); session.beginTransaction(); // 部门对象 Dept dept = new Dept(); dept.setDeptName(&quot;综合部&quot;); // 员工对象 Employee emp_zs = new Employee(); emp_zs.setEmpName(&quot;张三&quot;); Employee emp_ls = new Employee(); emp_ls.setEmpName(&quot;李四&quot;); // 关系 emp_zs.setDept(dept); emp_ls.setDept(dept); // 保存 session.save(dept); // 先保存一的方法 session.save(emp_zs); session.save(emp_ls);// 再保存多的一方，关系回自动维护(映射配置完) session.getTransaction().commit(); session.close(); /* * 结果 当Dept.hbm.xml里的inverse属性为true时此方式和上面无差别 * Hibernate: insert into t_dept (deptName) values (?) Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?) Hibernate: insert into t_employee (empName, salary, dept_id) values (?, ?, ?) 少生成2条update sql */ } } 获取：123456789101112131415161718192021@Test public void get() { Session session = sf.openSession(); session.beginTransaction(); // 通过部门方，获取另外一方// Dept dept = (Dept) session.get(Dept.class, 1);// System.out.println(dept.getDeptName());// System.out.println(dept.getEmps());// 懒加载 // 通过员工房，获取另外一方 Employee emp = (Employee) session.get(Employee.class, 1); System.out.println(emp.getEmpName()); System.out.println(emp.getDept().getDeptName()); session.getTransaction().commit(); session.close(); } 控制反转：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package cn.itcast.b_one2Many;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;import org.hibernate.classic.Session;import org.junit.Test;import cn.itcast.a_collection.User;public class App3_inverse { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } // 1. 保存数据 @Test public void save() { Session session = sf.openSession(); session.beginTransaction(); // 部门对象 Dept dept = new Dept(); dept.setDeptName(&quot;应用开发部&quot;); // 员工对象 Employee emp_zs = new Employee(); emp_zs.setEmpName(&quot;张三&quot;); Employee emp_ls = new Employee(); emp_ls.setEmpName(&quot;李四&quot;); // 关系 dept.getEmps().add(emp_zs); dept.getEmps().add(emp_ls); // inverse=true, 不会设置关联。 // 此时的关联应该通过员工方维护。 // 保存 session.save(emp_zs); session.save(emp_ls); session.save(dept); // 保存部门，部门下所有的员工 session.getTransaction().commit(); session.close(); } //2. 是否设置inverse，对获取数据的影响？ 无. @Test public void get() { Session session = sf.openSession(); session.beginTransaction(); Dept dept = (Dept) session.get(Dept.class, 1); System.out.println(dept.getDeptName()); System.out.println(dept.getEmps()); session.getTransaction().commit(); session.close(); } // 3. 是否设置inverse，对解除关联关系影响？ // inverse=false， 可以解除关联 // inverse=true， 当前方(部门)没有控制权，不能解除关联关系(不会生成update语句,也不会报错) // @Test public void removeRelation() { Session session = sf.openSession(); session.beginTransaction(); // 获取部门 Dept dept = (Dept) session.get(Dept.class, 2); // 解除关系 dept.getEmps().clear(); session.getTransaction().commit(); session.close(); } //3. 是否设置inverse属性，在删除数据中对关联关系的影响? // inverse=false, 有控制权， 可以删除。先清空外键引用，再删除数据。 // inverse=true, 没有控制权: 如果删除的记录有被外键引用，会报错，违反主外键引用约束！ // 如果删除的记录没有被引用，可以直接删除。 @Test public void deleteData() { Session session = sf.openSession(); session.beginTransaction(); // 查询部门 Dept dept = (Dept) session.get(Dept.class, 8); session.delete(dept); session.getTransaction().commit(); session.close(); }} 级联删除：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class App4_cascade { private static SessionFactory sf; static { sf = new Configuration() .configure() .addClass(Dept.class) .addClass(Employee.class) // 测试时候使用 .buildSessionFactory(); } // 级联保存 @Test public void save() { Session session = sf.openSession(); session.beginTransaction(); // 部门对象 Dept dept = new Dept(); dept.setDeptName(&quot;财务部&quot;); // 员工对象 Employee emp_zs = new Employee(); emp_zs.setEmpName(&quot;张三&quot;); Employee emp_ls = new Employee(); emp_ls.setEmpName(&quot;李四&quot;); // 关系 dept.getEmps().add(emp_zs); dept.getEmps().add(emp_ls); // 保存// session.save(emp_zs);// session.save(emp_ls); session.save(dept); // 需要设置级联保存； 保存部门，部门下所有的员工 session.getTransaction().commit(); session.close(); } // 级联删除 @Test public void delete() { Session session = sf.openSession(); session.beginTransaction(); Dept dept = (Dept) session.get(Dept.class,7); session.delete(dept); // 级联删除 session.getTransaction().commit(); session.close(); } } 123456789101112131415161718192021222324252627282930313233343536373839404142总结： 在一对多与多对一的关联关系中，保存数据最好的通过多的一方来维护关系，这样可以减少update语句的生成，从而提高hibernate的执行效率！ 配置一对多与多对一，这种叫“双向关联”只配置一对多， 叫“单项一对多”只配置多对一， 叫“单项多对一”注意： 配置了哪一方，哪一方才有维护关联关系的权限！Inverse属性Inverse属性，是在维护关联关系的时候起作用的。 表示控制权是否转移。(在一的一方起作用)Inverse , 控制反转。Inverse = false 不反转； 当前方有控制权 True 控制反转； 当前方没有控制权维护关联关系中，是否设置inverse属性： 1. 保存数据 有影响。 如果设置控制反转,即inverse=true, 然后通过部门方维护关联关系。在保存部门的时候，同时保存员工， 数据会保存，但关联关系不会维护。即外键字段为NULL 2. 获取数据 无。 3. 解除关联关系？ 有影响。 inverse=false， 可以解除关联inverse=true， 当前方(部门)没有控制权，不能解除关联关系(不会生成update语句,也不会报错) 4. 删除数据对关联关系的影响？ 有影响。 inverse=false, 有控制权， 可以删除。先清空外键引用，再删除数据。 inverse=true, 没有控制权: 如果删除的记录有被外键引用，会报错，违反主外键引用约束！ 如果删除的记录没有被引用，可以直接删除。cascade 属性cascade 表示级联操作 【可以设置到一的一方或多的一方】 none 不级联操作， 默认值 save-update 级联保存或更新 delete 级联删除 save-update,delete 级联保存、更新、删除 all 注意：inverse表示的是对象和关系之间的联系，面cascade表示的是对象与对象之间的关系，二者区别参考链接：一对多（多对一）关系中的inverse和cascade属性 2.2 多对多 项目与开发员工一个项目，有多个开发人员！一个开发人员，参与多个项目！ 【多对多】 Developer.java123456public class Developer { private int d_id; private String d_name; // 开发人员，参数的多个项目 private Set&lt;Project&gt; projects = new HashSet&lt;Project&gt;();} Developer.hbm.xml12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.c_many2many&quot;&gt; &lt;class name=&quot;Developer&quot; table=&quot;t_developer&quot;&gt; &lt;id name=&quot;d_id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;d_name&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;!-- 多对多映射配置： 员工方 name 指定映射的集合属性 table 集合属性对应的中间表 key 指定中间表的外键字段(引用当前表t_developer主键的外键字段) many-to-many column 指定外键字段对应的项目字段 class 集合元素的类型 --&gt; &lt;set name=&quot;projects&quot; table=&quot;t_relation&quot;&gt; &lt;key column=&quot;did&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;prjId&quot; class=&quot;Project&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; Project .java123456public class Project { private int prj_id; private String prj_name; // 项目下的多个员工 private Set&lt;Developer&gt; developers = new HashSet&lt;Developer&gt;();} Project.hbm.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;cn.itcast.c_many2many&quot;&gt; &lt;class name=&quot;Project&quot; table=&quot;t_project&quot;&gt; &lt;id name=&quot;prj_id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;prj_name&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;!-- 多对多映射: 1. 映射的集合属性： “developers” 2. 集合属性，对应的中间表： “t_relation” 3. 外键字段: prjId 4. 外键字段，对应的中间表字段: did 5. 集合属性元素的类型 --&gt; &lt;set name=&quot;developers&quot; table=&quot;t_relation&quot; cascade=&quot;save-update&quot; inverse=&quot;false&quot;&gt; &lt;key column=&quot;prjId&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;did&quot; class=&quot;Developer&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 测试12345678910111213141516171819202122Project prj_ds = new Project(); prj_ds.setPrj_name(&quot;电商系统&quot;); Project prj_oa = new Project(); prj_oa.setPrj_name(&quot;OA系统&quot;); // 创建员工对象 Developer dev_cj = new Developer(); dev_cj.setD_name(&quot;曹吉&quot;); Developer dev_wc = new Developer(); dev_wc.setD_name(&quot;王春&quot;); Developer dev_lz = new Developer(); dev_lz.setD_name(&quot;老张&quot;); // 关系 【项目方】 prj_ds.getDevelopers().add(dev_cj); prj_ds.getDevelopers().add(dev_wc); // 电商系统（曹吉，王春） prj_oa.getDevelopers().add(dev_wc); prj_oa.getDevelopers().add(dev_lz); // OA系统（王春，老张） // 保存 session.save(prj_ds); session.save(prj_oa); // 必须要设置级联保存 ,且Project.hbm.xml 里的inverse属性为false 效果如下：插入了两个项目，三个开发者，四条记录123456789Hibernate: insert into t_project (prj_name) values (?)Hibernate: insert into t_developer (d_name) values (?)Hibernate: insert into t_developer (d_name) values (?)Hibernate: insert into t_project (prj_name) values (?)Hibernate: insert into t_developer (d_name) values (?)Hibernate: insert into t_relation (prjId, did) values (?, ?)Hibernate: insert into t_relation (prjId, did) values (?, ?)Hibernate: insert into t_relation (prjId, did) values (?, ?)Hibernate: insert into t_relation (prjId, did) values (?, ?)","link":"/2017/06/12/Hibernate构架( 二） 映射/"},{"title":"JAVA基础系列（五） 集合","text":"面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，Java就提供了集合类. 集合和数组的区别: 1. Collection 集合的顶层接口 功能概述 添加功能 boolean add(Object obj):添加一个元素 boolean addAll(Collection c):添加一个集合的元素 删除功能 void clear():移除所有元素 boolean remove(Object o):移除一个元素 boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有) 判断功能 boolean contains(Object o)：判断集合中是否包含指定的元素 boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有); boolean isEmpty()：判断集合是否为空 获取功能 Iterator iterator()(重点) 长度功能 int size():元素的个数 交集功能 boolean retainAll(Collection c); 把集合转换为数组 Object[] toArray() 2. Iterator 对 collection 进行迭代的迭代器,依赖于集合而存在 接口成员方法1234567public interface Iterator&lt;E&gt; { // 如果仍有元素可以迭代，则返回 true。 boolean hasNext(); // 获取元素,并移动到下一个位置。 E next(); void remove();} Demo: 12345678910111213public class IteratorDemo { public static void main(String[] args) { Collection c = new ArrayList(); c.add(&quot;hello&quot;); c.add(&quot;world&quot;); c.add(&quot;java&quot;); Iterator it = c.iterator(); while (it.hasNext()) { String s = (String) it.next(); System.out.println(s); } }} 3. List 有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 List集合的特有功能： A:添加功能 void add(int index,Object element):在指定位置添加元素 B:获取功能 Object get(int index):获取指定位置的元素 C:列表迭代器 ListIterator listIterator()：List集合特有的迭代器 D:删除功能 Object remove(int index)：根据索引删除元素,返回被删除的元素 E:修改功能 Object set(int index,Object element):根据索引修改元素，返回被修饰的元素 4. ListIterator List集合特有的迭代器 特有功能A.Object previous():获取上一个元素B.boolean hasPrevious():判断是否有元素注意：ListIterator可以实现逆向遍历，但是必须先正向遍历，才能逆向遍历，所以一般无意义，不使用。 Demo:1234567891011121314151617181920212223242526272829303132333435363738public class ListIteratorDemo { public static void main(String[] args) { // 创建List集合对象 List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); // ListIterator listIterator() ListIterator lit = list.listIterator(); // 子类对象 // while (lit.hasNext()) { // String s = (String) lit.next(); // System.out.println(s); // } // System.out.println(&quot;-----------------&quot;); // System.out.println(lit.previous()); // System.out.println(lit.previous()); // System.out.println(lit.previous()); // NoSuchElementException // System.out.println(lit.previous()); while (lit.hasPrevious()) { String s = (String) lit.previous(); System.out.println(s); } System.out.println(&quot;-----------------&quot;); // 迭代器 Iterator it = list.iterator(); while (it.hasNext()) { String s = (String) it.next(); System.out.println(s); } System.out.println(&quot;-----------------&quot;); }} 5. ArrayList Demo:12345678910111213141516171819202122232425public class ArrayListDemo { public static void main(String[] args) { // 创建集合对象 ArrayList array = new ArrayList(); // 创建元素对象，并添加元素 array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); // 遍历 Iterator it = array.iterator(); while (it.hasNext()) { String s = (String) it.next(); System.out.println(s); } System.out.println(&quot;-----------&quot;); for (int x = 0; x &lt; array.size(); x++) { String s = (String) array.get(x); System.out.println(s); } }} 6. Vector特有功能：1234567//1. 添加功能 public void addElement(Object obj) -- add() //2. 获取功能public Object elementAt(int index) -- get()public Enumeration elements() -- Iterator iterator()boolean hasMoreElements() hasNext()Object nextElement() next() Demo:12345678910111213141516171819202122232425public class VectorDemo { public static void main(String[] args) { // 创建集合对象 Vector v = new Vector(); // 添加功能 v.addElement(&quot;hello&quot;); v.addElement(&quot;world&quot;); v.addElement(&quot;java&quot;); // 遍历 for (int x = 0; x &lt; v.size(); x++) { String s = (String) v.elementAt(x); System.out.println(s); } System.out.println(&quot;------------------&quot;); Enumeration en = v.elements(); // 返回的是实现类的对象 while (en.hasMoreElements()) { String s = (String) en.nextElement(); System.out.println(s); } }} 7. LinkedList特有功能123456789A:添加功能 public void addFirst(Object e) public void addLast(Object e)B:获取功能 public Object getFirst() public Obejct getLast()C:删除功能 public Object removeFirst() public Object removeLast() Demo: 1234567891011121314151617181920212223242526272829public class LinkedListDemo { public static void main(String[] args) { // 创建集合对象 LinkedList link = new LinkedList(); // 添加元素 link.add(&quot;hello&quot;); link.add(&quot;world&quot;); link.add(&quot;java&quot;); // public void addFirst(Object e) // link.addFirst(&quot;javaee&quot;); // public void addLast(Object e) // link.addLast(&quot;android&quot;); // public Object getFirst() // System.out.println(&quot;getFirst:&quot; + link.getFirst()); // public Obejct getLast() // System.out.println(&quot;getLast:&quot; + link.getLast()); // public Object removeFirst() System.out.println(&quot;removeFirst:&quot; + link.removeFirst()); // public Object removeLast() System.out.println(&quot;removeLast:&quot; + link.removeLast()); // 输出对象名 System.out.println(&quot;link:&quot; + link); }} List的子类比较 8. Set 一个不包含重复元素的 collection Demo:123456789101112131415161718public class SetDemo { public static void main(String[] args) { // 创建集合对象 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // 创建并添加元素 set.add(&quot;hello&quot;); set.add(&quot;java&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); set.add(&quot;world&quot;); // 增强for for (String s : set) { System.out.println(s); } }} 9. HashSet 不保证 set 的迭代顺序,特别是它不保证该顺序恒久不变。 Demo:12345678910111213141516171819202122232425262728293031323334/* * HashSet:存储字符串并遍历 * 问题：为什么存储字符串的时候，字符串内容相同的只存储了一个呢? * 通过查看add方法的源码，我们知道这个方法底层依赖 两个方法：hashCode()和equals()。 * 步骤： * 首先比较哈希值 * 如果相同，继续走，比较地址值或者走equals() * 如果不同,就直接添加到集合中 * 按照方法的步骤来说： * 先看hashCode()值是否相同 * 相同:继续走equals()方法 * 返回true： 说明元素重复，就不添加 * 返回false：说明元素不重复，就添加到集合 * 不同：就直接把元素添加到集合 * 如果类没有重写这两个方法，默认使用的Object()。一般来说不同相同。 * 而String类重写了hashCode()和equals()方法，所以，它就可以把内容相同的字符串去掉。只留下一个。 */public class HashSetDemo { public static void main(String[] args) { // 创建集合对象 HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;(); // 创建并添加元素 hs.add(&quot;hello&quot;); hs.add(&quot;world&quot;); hs.add(&quot;java&quot;); hs.add(&quot;world&quot;); // 遍历集合 for (String s : hs) { System.out.println(s); } }} LinkedHashSet 底层数据结构由哈希表和链表组成。哈希表保证元素的唯一性, 链表保证元素有素。(存储和取出是一致) Demo:123456789101112131415161718public class LinkedHashSetDemo { public static void main(String[] args) { // 创建集合对象 LinkedHashSet&lt;String&gt; hs = new LinkedHashSet&lt;String&gt;(); // 创建并添加元素 hs.add(&quot;hello&quot;); hs.add(&quot;world&quot;); hs.add(&quot;java&quot;); hs.add(&quot;world&quot;); hs.add(&quot;java&quot;); // 遍历 for (String s : hs) { System.out.println(s); } }} 10. TreeSet 能够对元素按照某种规则进行排序。TreeSet集合的特点：排序和唯一 排序有两种方式 A:自然排序B:比较器排序Demo1:1234567891011121314151617181920212223242526public class TreeSetDemo { public static void main(String[] args) { // 创建集合对象 //A:自然排序(元素具备比较性) //让元素所属的类实现自然排序接口 Comparable TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); // 创建元素并添加 // 20,18,23,22,17,24,19,18,24 ts.add(20); ts.add(18); ts.add(23); ts.add(22); ts.add(17); ts.add(24); ts.add(19); ts.add(18); ts.add(24); // 遍历 for (Integer i : ts) { System.out.println(i); } }} Demo2: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.Comparator;import java.util.TreeSet;/* * 需求：请按照姓名的长度排序 * * TreeSet集合保证元素排序和唯一性的原理 * 唯一性：是根据比较的返回是否是0来决定。 * */public class TreeSetDemo { //比较器排序(集合具备比较性) //让集合的构造方法接收一个比较器接口的子类对象 Comparator public static void main(String[] args) { // 创建集合对象 // TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(); //自然排序 // public TreeSet(Comparator comparator) //比较器排序 // TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new MyComparator()); // 如果一个方法的参数是接口，那么真正要的是接口的实现类的对象 // 而匿名内部类就可以实现这个东西 TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() { @Override public int compare(Student s1, Student s2) { // 姓名长度 int num = s1.getName().length() - s2.getName().length(); // 姓名内容 int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num; // 年龄 int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2; return num3; } }); // 创建元素 Student s1 = new Student(&quot;linqingxia&quot;, 27); Student s2 = new Student(&quot;zhangguorong&quot;, 29); Student s3 = new Student(&quot;wanglihong&quot;, 23); Student s4 = new Student(&quot;linqingxia&quot;, 27); Student s5 = new Student(&quot;liushishi&quot;, 22); Student s6 = new Student(&quot;wuqilong&quot;, 40); Student s7 = new Student(&quot;fengqingy&quot;, 22); Student s8 = new Student(&quot;linqingxia&quot;, 29); // 添加元素 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); ts.add(s7); ts.add(s8); // 遍历 for (Student s : ts) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } }}class Student { private String name; private int age; public Student() { super(); } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 11. Map 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map集合和Collection集合的区别? Map集合存储元素是成对出现的，Map集合的键是唯一的，值是可重复的。可以把这个理解为：夫妻对 Collection集合存储元素是单独出现的，Collection的儿子Set是唯一的，List是可重复的。 功能概述 添加功能 V put(K key,V value):添加元素。这个其实还有另一个功能?先不告诉你，等会讲如果键是第一次存储，就直接存储元素，返回null如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 删除功能 void clear():移除所有的键值对元素V remove(Object key)：根据键删除键值对元素，并把值返回 判断功能 boolean containsKey(Object key)：判断集合是否包含指定的键boolean containsValue(Object value):判断集合是否包含指定的值boolean isEmpty()：判断集合是否为空 获取功能 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():???V get(Object key):根据键获取值Set keySet():获取集合中所有键的集合Collection values():获取集合中所有值的集合 长度功能 int size()：返回集合中的键值对的对数 Demo: 12345678910111213141516171819202122public class MapDemo3 { public static void main(String[] args) { // 创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 创建元素并添加到集合 map.put(&quot;杨过&quot;, &quot;小龙女&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨康&quot;, &quot;穆念慈&quot;); map.put(&quot;陈玄风&quot;, &quot;梅超风&quot;); // 遍历 // 获取所有的键 Set&lt;String&gt; set = map.keySet(); // 遍历键的集合，获取得到每一个键 for (String key : set) { // 根据键去找值 String value = map.get(key); System.out.println(key + &quot;---&quot; + value); } }} HashMap 是基于哈希表的Map接口实现,哈希表的作用是用来保证键的唯一性的。 Demo:12345678910111213141516171819202122232425public class HashMapDemo { public static void main(String[] args) { // 创建集合对象 HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); // 创建元素并添加元素 // String key1 = &quot;it001&quot;; // String value1 = &quot;马云&quot;; // hm.put(key1, value1); hm.put(&quot;it001&quot;, &quot;马云&quot;); hm.put(&quot;it003&quot;, &quot;马化腾&quot;); hm.put(&quot;it004&quot;, &quot;乔布斯&quot;); hm.put(&quot;it005&quot;, &quot;张朝阳&quot;); hm.put(&quot;it002&quot;, &quot;裘伯君&quot;); // wps hm.put(&quot;it001&quot;, &quot;比尔盖茨&quot;); // 遍历 Set&lt;String&gt; set = hm.keySet(); for (String key : set) { String value = hm.get(key); System.out.println(key + &quot;---&quot; + value); } }} LinkedHashMap 是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。 Demo: 1234567891011121314151617181920public class LinkedHashMapDemo { public static void main(String[] args) { // 创建集合对象 LinkedHashMap&lt;String, String&gt; hm = new LinkedHashMap&lt;String, String&gt;(); // 创建并添加元素 hm.put(&quot;2345&quot;, &quot;hello&quot;); hm.put(&quot;1234&quot;, &quot;world&quot;); hm.put(&quot;3456&quot;, &quot;java&quot;); hm.put(&quot;1234&quot;, &quot;javaee&quot;); hm.put(&quot;3456&quot;, &quot;android&quot;); // 遍历 Set&lt;String&gt; set = hm.keySet(); for (String key : set) { String value = hm.get(key); System.out.println(key + &quot;---&quot; + value); } }} 13. TreeMap 是基于红黑树的Map接口的实现,可以保证键的排序和唯一性 Demo: 1234567891011121314151617181920public class TreeMapDemo { public static void main(String[] args) { // 创建集合对象 TreeMap&lt;String, String&gt; tm = new TreeMap&lt;String, String&gt;(); // 创建元素并添加元素 tm.put(&quot;hello&quot;, &quot;你好&quot;); tm.put(&quot;world&quot;, &quot;世界&quot;); tm.put(&quot;java&quot;, &quot;爪哇&quot;); tm.put(&quot;world&quot;, &quot;世界2&quot;); tm.put(&quot;javaee&quot;, &quot;爪哇EE&quot;); // 遍历集合 Set&lt;String&gt; set = tm.keySet(); for (String key : set) { String value = tm.get(key); System.out.println(key + &quot;---&quot; + value); } }} 14. HashtableHashtable和HashMap的区别? Hashtable:线程安全，效率低。不允许null键和null值 HashMap:线程不安全，效率高。允许null键和null值 Demo: 123456789101112public class HashtableDemo { public static void main(String[] args) { // HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); Hashtable&lt;String, String&gt; hm = new Hashtable&lt;String, String&gt;(); hm.put(&quot;it001&quot;, &quot;hello&quot;); // hm.put(null, &quot;world&quot;); //NullPointerException // hm.put(&quot;java&quot;, null); // NullPointerException System.out.println(hm); }} 15. Collections 是针对集合进行操作的工具类，都是静态方法。 Collection和Collections的区别? Collection:是单列集合的顶层接口，有子接口List和Set。 Collections:是针对集合操作的工具类，有对集合进行排序和二分查找的方法 成员方法12345public static &lt;T&gt; void sort(List&lt;T&gt; list)：排序 默认情况下是自然顺序。public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key):二分查找public static &lt;T&gt; T max(Collection&lt;?&gt; coll):最大值public static void reverse(List&lt;?&gt; list):反转public static void shuffle(List&lt;?&gt; list):随机置换 Demo:12345678910111213141516171819202122232425262728293031323334353637public class CollectionsDemo { public static void main(String[] args) { // 创建集合对象 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 添加元素 list.add(30); list.add(20); list.add(50); list.add(10); list.add(40); System.out.println(&quot;list:&quot; + list); // public static &lt;T&gt; void sort(List&lt;T&gt; list)：排序 默认情况下是自然顺序。 // Collections.sort(list); // System.out.println(&quot;list:&quot; + list); // [10, 20, 30, 40, 50] // public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key):二分查找 // System.out // .println(&quot;binarySearch:&quot; + Collections.binarySearch(list, 30)); // System.out.println(&quot;binarySearch:&quot; // + Collections.binarySearch(list, 300)); // public static &lt;T&gt; T max(Collection&lt;?&gt; coll):最大值 // System.out.println(&quot;max:&quot;+Collections.max(list)); // public static void reverse(List&lt;?&gt; list):反转 // Collections.reverse(list); // System.out.println(&quot;list:&quot; + list); // public static void shuffle(List&lt;?&gt; list):随机置换 Collections.shuffle(list); System.out.println(&quot;list:&quot; + list); }}","link":"/2017/06/02/JAVA基础系列（五） 集合/"},{"title":"JavaWeb基础之Servlet全解析","text":"Servlet 是在服务器上运行的小程序,其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类。 本文内容： 1.Servlet开发步骤 学习Servlet，我们先看一下Servlet程序怎么开发，大体上可以分为五步，如下所示： 1）编写java类，继承HttpServlet类，重写doGet和doPost方法12345678public class FirstServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException { //向浏览器输出内容 response.getWriter().write(&quot;this is first servlet！&quot;); }} 2）在web.xml文件中进行配置1234567891011121314151617&lt;!-- 配置一个servlet --&gt; &lt;!-- servlet的配置 --&gt; &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;cn.acamy.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3）部署，servlet程序的class码拷贝到WEB-INF/classes目录4）启动tomcat服务器5）通过URL访问http://localhost:8080/demo/first http:// :http协议localhost: :到本地的hosts文件中查找是否存在该域名对应的IP地址(127.0.0.1)8080 : 找到tomcat服务器/demo : 在tomcat的webapps目录下找 demo的目录/first: 资源名称。1）在demo的web.xml中查找是否有匹配的url-pattern的内容（/first）2）如果找到匹配的url-pattern,则使用当前servlet-name的名称到web.xml文件中查询是否相同名称的servlet配置3）如果找到，则取出对应的servlet配置信息中的servlet-class内容： 字符串： cn.acamy.FirstServlet通过反射： a）构造FirstServlet的对象 b）然后调用FirstServlet里面的方法 2.本文涉及到的相关类2.1 HttpServlet继承体系 我们写的Servlet程序都是要直接继续HttpServlet,由下面的类图可以看出该类有service方法的重写和重载，以及doGet,doPost…方法，继承于抽象类GenericServlet，GenericServlet实现了接口Servlet和ServletConfig，Servlet接口里面定义了init，service,destroy,getServletConfig,getServletInfo方法，ServletConfig里面定义了获取配置信息的相关方法。 2.2 HttpServletRequest与HttpServletResponse HttpServletRequest继承于ServletRequest,封装了Servlet程序的请求信息，HttpServletResponse继承于ServletResponse，封装了Servlet程序的响应信息。 2.3 ServletContext ServletContext是Servlet上下文对象，封装了当前的web应用环境。 3. Servlet的生命周期 Servlet程序的生命周期是由tomcat服务器控制的！ 我们先来看一个Demo:12345678910111213141516171819202122232425262728293031323334public class LifeDemo extends HttpServlet { /** * 1.构造方法 */ public LifeDemo(){ System.out.println(&quot;1.servlet对象被创建了。&quot;); } /** * 2.init方法 */ @Override public void init(ServletConfig config) throws ServletException { System.out.println(&quot;2.init方法被调用&quot;); } /** * 3.service方法 */ @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println(&quot;3.service方法被调用&quot;); } /** * 4.destroy方法 */ @Override public void destroy() { System.out.println(&quot;4.servlet对象销毁了&quot;); }} 效果如下： 1. 构造方法： 创建servlet对象的时候调用。默认情况下，第一次访问servlet的时候创建servlet对象。只调用1次。证明servlet对象在tomcat是单实例的。2. init方法： 创建完servlet对象的时候调用。只调用1次。3. service方法： 每次发出请求时调用。调用n次。4. destroy方法： 销毁servlet对象的时候调用。停止服务器或者重新部署web应用时销毁servlet对象。 只调用1次。 Servlet生命周期如下图所示： 4.HttpServlet的service方法源码 从上面的生命周期可以看出，service方法在浏览器每发送一次请求就被调用一次。但我如果要调用doGet,doPost,doHead等方法时，又该怎么实现呢？先看一下HttpServlet里面与该方法相关的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private static final String METHOD_DELETE = &quot;DELETE&quot;;private static final String METHOD_HEAD = &quot;HEAD&quot;;private static final String METHOD_GET = &quot;GET&quot;; private static final String METHOD_OPTIONS = &quot;OPTIONS&quot;; private static final String METHOD_POST = &quot;POST&quot;; private static final String METHOD_PUT = &quot;PUT&quot;; private static final String METHOD_TRACE = &quot;TRACE&quot;; //该方法是重写Servlet接口中的方法，可以看到先把ServletRequest和 //ServletResponse转化为其子类HttpServletRequest，HttpServletResponse //然后调用重载的service(HttpServletRequest req, HttpServletResponse resp) @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; try { request = (HttpServletRequest) req; response = (HttpServletResponse) res; } catch (ClassCastException e) { throw new ServletException(&quot;non-HTTP request or response&quot;); } service(request, response); } //注意这个方法是上面service方法的重载，并且是protected面不是public修饰符修 //饰,说明该方法只能被自身或子类来调用。 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //首先得到方法名 String method = req.getMethod(); // 然后看该方法名与实现的哪个方法相对应，就执行哪个方法 // 如得到的方法名为POST,则对应到METHOD_POST， // 执行doPost(req, resp); if (method.equals(METHOD_GET)) { long lastModified = getLastModified(req); if (lastModified == -1) { // servlet doesn&apos;t support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); } else { long ifModifiedSince; try { ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); } catch (IllegalArgumentException iae) { // Invalid date header - proceed as if none was set ifModifiedSince = -1; } if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) { // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); } else { resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); } } } else if (method.equals(METHOD_HEAD)) { long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); } else if (method.equals(METHOD_POST)) { doPost(req, resp); } else if (method.equals(METHOD_PUT)) { doPut(req, resp); } else if (method.equals(METHOD_DELETE)) { doDelete(req, resp); } else if (method.equals(METHOD_OPTIONS)) { doOptions(req,resp); } else if (method.equals(METHOD_TRACE)) { doTrace(req,resp); } else { // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // //如果没有找到则说明没有该方法的实现，给出错误提示 String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); } } 结论：无论我们需要调用的是GET，POST还是其它方法，我们首先通过调用service(ServletRequest req, ServletResponse res)，然后指向service(HttpServletRequest req, HttpServletResponse resp)，最终通过方法名来进行匹配，实现转向，调用想doGET或POST或其它的方法。 ##5.Servlet的路径问题与自动加载 ###5.1 Servlet 的映射路径123456&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet的映射路径分为精确匹配和模糊匹配 注意：123451）url-pattern要么以 / 开头，要么以*开头。 例如， itcast是非法路径。2）不能同时使用两种模糊匹配，例如 /demo/*.do是非法路径3）当有输入的URL有多个servlet同时被匹配的情况下：3.1 精确匹配优先。（长的最像优先被匹配）3.2 以后缀名结尾的模糊url-pattern优先级最低！！！ ###5.2 Servlet 的缺省路径 servlet的缺省路径（/）是在tomcat服务器内置的一个路径。该路径对应的是一个DefaultServlet（缺省Servlet）。这个缺省的Servlet的作用是用于解析web应用的静态资源文件。 问题： URL输入http://localhost:8080/demo/index.html 如何读取文件？1）到当前demo应用下的web.xml文件查找是否有匹配的url-pattern。2）如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理3）DefaultServlet程序到demo应用的根目录下查找是存在一个名称为index.html的静态文件。4）如果找到该文件，则读取该文件内容，返回给浏览器。5）如果找不到该文件，则返回404错误页面。结论： 先找动态资源，再找静态资源。 ###5.3 Servlet 的自动加载 默认情况下，第一次访问servlet的时候创建servlet对象。如果servlet的构造方法或init方法中执行了比较多的逻辑代码，那么导致用户第一次访问sevrlet的时候比较慢。改变servlet创建对象的时机： 提前到加载web应用的时候！在servlet的配置信息中，加上一个即可！ 123456&lt;servlet&gt; &lt;servlet-name&gt;LifeDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.c_life.LifeDemo&lt;/servlet-class&gt; &lt;!-- 让servlet对象自动加载 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 注意： 整数值越大，创建优先级越低！！&lt;/servlet&gt; 自动加载效果如下图所示，可以看到Servlet在Tomcat服务器启动时就执行了构造方法和init方法： 6. Servlet的有参和无参init方法 有参数的init方法是servlet的生命周期方法，一定会被tomcat服务器调用。如果要编写初始代码，不需要覆盖。无参数的init方法是servlet的编写初始化代码的方法。是Sun公司设计出来专门给开发者进行覆盖，然后在里面编写servlet的初始逻辑代码的方法。 12345678910111213public class InitDemo extends HttpServlet { /* * @Override public void init(ServletConfig config) throws ServletException * { System.out.println(&quot;有参数的init方法&quot;); } */ @Override public void init() throws ServletException { // System.out.println(&quot;无参数的init方法&quot;); }} 7.Servlet的多线程并发问题 servlet对象在tomcat服务器是单实例多线程的。因为servlet是多线程的，所以当多个servlet的线程同时访问了servlet的共享数据，如成员变量，可能会引发线程安全问题。 解决办法：1）把使用到共享数据的代码块进行同步（使用synchronized关键字进行同步）2）建议在servlet类中尽量不要使用成员变量。如果确实要使用成员，必须同步。而且尽量缩小同步代码块的范围。（哪里使用到了成员变量，就同步哪里！！），以避免因为同步而导致并发效率降低。 12345678910111213141516171819202122public class TheradDemo extends HttpServlet { int count = 1; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(&quot;text/html;charset=utf-8&quot;); synchronized (TheradDemo.class) {//锁对象必须唯一。建议使用类对象 response.getWriter().write(&quot;你现在是当前网站的第&quot;+count+&quot;个访客&quot;); //线程1执行完 ， 线程2执行 //线程1还没有执行count++ /*try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); }*/ count++; } }} ##8.ServletConfig对象 ServletConfig对象: 主要是用于加载servlet的初始化参数。在一个web应用可以存在多个ServletConfig对象（一个Servlet对应一个ServletConfig对象） ###8.1 对象创建和得到创建时机： 在创建完servlet对象之后，在调用init方法之前创建。得到对象： 直接从有参数的init方法中得到！！！ ###8.2 servlet的初始化参数配置123456789&lt;servlet&gt; &lt;servlet-name&gt;ConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.f_config.ConfigDemo&lt;/servlet-class&gt; &lt;!-- 初始参数： 这些参数会在加载web应用的时候，封装到ServletConfig对象中 --&gt; &lt;init-param&gt; &lt;param-name&gt;path&lt;/param-name&gt; &lt;param-value&gt;e:/b.txt&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ConfigDemo extends HttpServlet { /** * 以下两段代码GenericServlet已经写了，我们无需编写！！ */ /*private ServletConfig config;*/ /** * 1）tomcat服务器把这些参数会在加载web应用的时候，封装到ServletConfig对象中 * 2）tomcat服务器调用init方法传入ServletConfig对象 */ /*@Override public void init(ServletConfig config) throws ServletException { this.config = config; }*/ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /** * 读取servlet的初始参数 */ String path = this.getServletConfig().getInitParameter(&quot;path&quot;); File file = new File(path); //读取内容 BufferedReader br = new BufferedReader(new FileReader(file)); String str = null; while( (str=br.readLine())!=null ){ System.out.println(str); } //查询当前servlet的所有初始化参数 Enumeration&lt;String&gt; enums = this.getServletConfig().getInitParameterNames(); while(enums.hasMoreElements()){ String paramName = enums.nextElement(); String paramValue = this.getServletConfig().getInitParameter(paramName); System.out.println(paramName+&quot;=&quot;+paramValue); } //得到servlet的名称 String servletName = this.getServletConfig().getServletName(); System.out.println(servletName); }} 9.ServletContext对象 Servlet的上下文对象。表示一个当前的web应用环境。一个web应用中只有一个ServletContext对象。 9.1 对象创建和得到创建时机：加载web应用时创建ServletContext对象。得到对象： 从当前Servlet或者ServletConfig对象的getServletContext方法得到 Demo:123456789101112131415161718192021222324252627282930313233343536373839404142public class ContextDemo extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1.得到ServletContext对象 // ServletContext context = this.getServletConfig().getServletContext(); ServletContext context = this.getServletContext(); // （推荐使用） // 2.得到web应用路径 /** * web应用路径：部署到tomcat服务器上运行的web应用名称 */ String contextPath = context.getContextPath(); System.out.println(contextPath); System.out.println(&quot;参数&quot; + context.getInitParameter(&quot;AAA&quot;)); Enumeration&lt;String&gt; enums = context.getInitParameterNames(); while (enums.hasMoreElements()) { String paramName = enums.nextElement(); String paramValue = context.getInitParameter(paramName); System.out.println(paramName + &quot;=&quot; + paramValue); } // 尝试得到ConfigDemo中的servlet参数 String path = this.getServletConfig().getInitParameter(&quot;path&quot;); System.out.println(&quot;path=&quot; + path); // 2.把数据保存到域对象中 context.setAttribute(&quot;name&quot;, &quot;eric&quot;); // 2.从域对象中取出数据 // String name = (String) context.getAttribute(&quot;name&quot;); /** * 案例：应用到请求重定向 */ response.sendRedirect(contextPath + &quot;/index.html&quot;); }} 9.2 转发与重定向 转发与重定向都能实现页面的跳转，但在实际应用中大不相同，比较如下; 注意： 如果要使用request域对象进行数据共享，只能用转发技术！！！","link":"/2017/06/05/JavaWeb基础之Servlet全解析/"},{"title":"flowable流程引擎初体验，完成一个请假流程","text":"flowable是一个用Java写的轻量级商业流程引擎，用它可以部署BPMN2.0(在工业界被广泛接受的XML标准)流程定义， 并且可以创建流程实例，驱动节点流转，存储相关的历史数据等等。可能更多人先是听说过activiti, 但是flowable实际上是activiti的主要成员在activiti上fork一个新的分支，添加了许多新的特性，也更加稳定实用，感兴趣的可以去了解一下这段历史。本文主要基于flowable官方文档演示如何去用flowable来走通如下的一个请假流程。 1. 创建项目首先我们创建一个maven项目，引入以下依赖： 采用最新版本的flowable流程引擎， flowable存储数据默认采用h2内存数据库，但我这里还是用熟悉的mysql flowable内部采用SLF4J作为其日志框架 在这里我们用log4j日志实现 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-engine&lt;/artifactId&gt; &lt;version&gt;6.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt;&lt;/dependency&gt; Log4j需要一个属性文件来进行相关配置，因此需要在src/main/resources添加具有以下内容的log4j.properties文件:12345log4j.rootLogger=DEBUG, CAlog4j.appender.CA=org.apache.log4j.ConsoleAppenderlog4j.appender.CA.layout=org.apache.log4j.PatternLayoutlog4j.appender.CA.layout.ConversionPattern= %d{hh:mm:ss,SSS} [%t] %-5p %c %x - %m%n ####2. 创建流程引擎首先，我们需要做的是初始化一个流程引擎（ProcessEngine）实例。它是一个线程安全的对象在一个应用中也只需要初始化一次， 而它又由流程引擎配置（ProceeEngineConfiguration）创建，在ProcessEngineconfiguration中可以配置和调整省流程引擎。通常情况下ProcessEngineConfiguration是通过配置文件来配置的，但是也可以在程序中创建。当然，最少情况下的流程引擎配置也需要一个JDBC连接到数据库。12345678910111213public class HolidayRequest { public static void main(String[] args) { ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration() .setJdbcUrl(&quot;jdbc:mysql://localhost:3306/flowable?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&quot;) .setJdbcUsername(&quot;root&quot;) .setJdbcPassword(&quot;123456&quot;) .setJdbcDriver(&quot;com.mysql.jdbc.Driver&quot;) .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); ProcessEngine processEngine = cfg.buildProcessEngine(); }} 在上面的代码中，创建了一个独立的配置对象，这里的‘独立’是指引擎只由它自己创建和使用（如果是在Spring环境中，则要用SpringProcessEngineConfiguration来替代).该对象先配置了一个数据库连接(注意先要创建flowable数据库)，最后的配置表示数据库不存在的话就要去创建它。运行该段代码后我们就可以看到数据库中新增了许多表格，如下所示： act_ru_: 表示的是一些流程实例运行(runtime)时的数据act_hi_: 表示存储的是一些历史(history)数据act_id_: 表示存储的是一些与用户身份(identity)相关的数据act_re_: 表示的是一些流程定义(repository)相关的数据act_ge_: 表示的是一些一般(general)数据act_evt_log表示事件日志，act_prodef_info表示的是流程定义的一些信息。flowable还有一些其它模块中的表，到后面介绍。 3. 部署流程定义如开篇那张图所示，我们需要实现的是一个很简单的请假流程， 表示员工的请假首先需要经理审批，经理拒绝则发邮件通知到申请人并结束该该流程，经理同意的话先注册到外部系统，然后通知给申请人进行销假，然后结束。该流程定义可以作为一个模板，每个需要请假的员工可以创建一个流程实例。当员工提供一些信息(如姓名， 请假天数和描述)就可以开始该流程。下面解释一下图中每类元素的意思： 开始事件：图中用细线圆圈来表示，是流程实例的开始点 箭头：表示节点之间的流转指向。 用户任务： 在图中用左上角有人的圆角矩形表示，这些是需要用户来操作的节点。图中有两个，第一个表示需要经理进行审批来同意或拒绝， 第二个表示用户来确认销假。 排它网关： 用叉形符号填充的菱形表示，从该图中出来的箭头往往有多个，但只有一个满足条件，流程会沿着满足条件的方向流转。 自动化任务 ： 左上角有齿轮形状的的圆角矩形，表示自动执行的节点。图中上面的表示请假被经理同意后自动注册通知到外部系统，下面的表示请假被经理拒绝后自动发邮件通知给申请人。 结束事件： 图中用粗线圆圈表示，表示流程的结束。图中上面的结束事件表示请假成功结束，下面的表示请假失败结束。 Flowable引擎需要的是一个遵循BPMN2.0标准的XML文档。BPMN2.0标准在工业界被广泛认可, 它对流程中每个节点以及节点与节点之间的流转定义了一套简单清晰易用的标准，并且节点即可以是个人任务也可以是自动化任务等， 因此大家可以用都能理解的方式进行商业化的流程门交流。通常我们可以用一些工具来画出流程图然后生成BPMN2.0文档，但是在这里我们为了熟悉该标准的格式不审采用手动定义的方式。在src/main/resources文件夹下添加名称为holiday-request.bpmn20.xml内容如下的文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; xmlns:flowable=&quot;http://flowable.org/bpmn&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; targetNamespace=&quot;http://www.flowable.org/processdef&quot;&gt; &lt;process id=&quot;holidayRequest&quot; name=&quot;Holiday Request&quot; isExecutable=&quot;true&quot;&gt; &lt;startEvent id=&quot;startEvent&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;startEvent&quot; targetRef=&quot;approveTask&quot;/&gt; &lt;userTask id=&quot;approveTask&quot; name=&quot;Approve or reject request&quot; flowable:candidateGroups=&quot;managers&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;approveTask&quot; targetRef=&quot;decision&quot;/&gt; &lt;exclusiveGateway id=&quot;decision&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;decision&quot; targetRef=&quot;externalSystemCall&quot;&gt; &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt; &lt;![CDATA[ ${approved} ]]&gt; &lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow sourceRef=&quot;decision&quot; targetRef=&quot;sendRejectionMail&quot;&gt; &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt; &lt;![CDATA[ ${!approved} ]]&gt; &lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;serviceTask id=&quot;externalSystemCall&quot; name=&quot;Enter holidays in external system&quot; flowable:class=&quot;com.hebaohua.workflow.delegate.CallExternalSystemDelegate&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;externalSystemCall&quot; targetRef=&quot;holidayApprovedTask&quot;/&gt; &lt;userTask id=&quot;holidayApprovedTask&quot; name=&quot;Holiday approved&quot; flowable:assignee=&quot;${employee}&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;holidayApprovedTask&quot; targetRef=&quot;approveEnd&quot;/&gt; &lt;serviceTask id=&quot;sendRejectionMail&quot; name=&quot;Send out rejection email&quot; flowable:class=&quot;com.hebaohua.workflow.delegate.CallExternalSystemDelegate&quot;/&gt; &lt;sequenceFlow sourceRef=&quot;sendRejectionMail&quot; targetRef=&quot;rejectEnd&quot;/&gt; &lt;endEvent id=&quot;approveEnd&quot;/&gt; &lt;endEvent id=&quot;rejectEnd&quot;/&gt; &lt;/process&gt;&lt;/definitions&gt; XML文件中最开始几行是一些兼容BPMN2.0标准的约束，每个流程定义都一样。每一个activity都有一个id属性作为唯一性标识， name属性是为了增加可读性的可选项。连接activitys的有向箭头称之为sequence flow，有一个起始点和目标点。从排它网关出来的箭头比较特别，这两个都有一个条件标签，表示只有满足里面条件时才会走这条路线。条件表达式${approved}实际上是${approved == true}的缩写，approved被称之为流程变量。流程变量会随着流程实例进行持久化存储并且在整个流程实例的生命周期中都可以被用到， 因此我们必须在用到它之前的某个点对其进行赋值(本例中是当经理的用户任务完成时对approved进行true或false赋值)，而不是在流程实例一开始就对其赋值。现在我们有了流程定义的BPMN2.0 XML文件，下一步就是要把它部署到引擎中。部署流程引擎也就意味着： 流程引擎会把XML文件存储在数据库中，因此可以需要的时候查询到它 流程定义被解析为一个内部可执行的对象模型，所以我们可以以它为模板启动一个流程实例部署流程定义到Flowable引擎需要用RepositoryService，可以在ProcessEngine对象中得到它。通过RepositoryService， 指定XML文件位置并调用deploy()方法后即可执行部署这个过程。 1234RepositoryService repositoryService = processEngine.getRepositoryService();Deployment deployment = repositoryService.createDeployment() .addClasspathResource(&quot;holiday-request.bpmn20.xml&quot;) .deploy(); 通过如下打印的日志可知，在部署的过程中分别在ACT_RE_PROCDEF, ACT_RE_DEPLOYMENT, ACT_GE_BYTEARRAY中插入了相关的记录。 现在我们就可以通过RepositoryService创建的ProcessDefinitionQuery查询到相关的流程定义信息了，如下代码：1234ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() .deploymentId(deployment.getId()) .singleResult();System.out.println(&quot;Found process definition : &quot; + processDefinition.getName()); 4. 启动流程实例现在我们有了流程定义，以它为模板就可启动一个流程实例了。在启动流程实之前，我们需要提供一些流程变量作为输入。通常通过表单或REST API让用户来填写这些信息，这里为了方便直接定定义相关变量放在Map中。下一步就需要通过RuntimeService(同样由processEngine产生)启动流程了。如下代码所示，通过key来启动流程实例，这里的key对应BPMN2.0 XML文件中的process id属性，本例中也就是holidayRequest。 12345678RuntimeService runtimeService = processEngine.getRuntimeService();Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();variables.put(&quot;employee&quot;, &quot;jack&quot;);variables.put(&quot;nrOfHolidays&quot;, 3);variables.put(&quot;description&quot;, &quot;回家看看&quot;);ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;holidayRequest&quot;, variables); 如下日志，可以看到插入了15条记录，分别是ProcessInstance, Execution, IdentityLInk, Variable, Task相关的运行和历史数据，Execution和Task是运行时的核心表。注意在这一步流程通过启动事件已经到达manager审批结点了，因此会插入两条HistoryActivityInstanceEntity记录。 5. 编写JavaDelegate实现自动化任务现在虽然任务到了第一个用户任务节点，但该任务节点执行后就会走自动化任务，在XML文件中我们定义对应的类为com.hebaohua.flowable.delegate.CallExternalSystemDelegate, 如果找不到该类程序流程引擎就会报异常，所以我们先看看如何编写这样的一个自动化执行类。很简单，实现org.flowable.engine.delegate.JavaDelegate接口及其execute方法。通过得到的DelegateExecution对象我们可以得到流程中所有变量及相关信息，因此想要做什么就在这个方法里来实现。如下代码只是一个简单演示:1234567public class CallExternalSystemDelegate implements JavaDelegate { @Override public void execute(DelegateExecution execution) { System.out.println(&quot;Calling the external system for employee &quot; + execution.getVariable(&quot;employee&quot;)); }} 6. 查询并完成任务在一个实际的应用中，用户通过登录系统可以以界面的方式查看他们的任务列表，并且可以看到流程实例的数据(流程运行状态，流程变量等)， 以此来对该任务作相应处理。在本例中，我们通过API调用来模拟这个过程。现在流程运行到了第一个用户任务， 在上面的XML文件中我们指定的完成该用户的为”managers”这个分组，首先我们可以通过TaskService创建TaskQuery对象来查询managers分组下的任务。如下：1234567891011TaskService taskService = processEngine.getTaskService();List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&quot;managers&quot;).list();System.out.println(&quot;You have &quot; + tasks.size() + &quot; tasks:&quot;);for (int i=0; i&lt;tasks.size(); i++) { System.out.println((i+1) + &quot;) &quot; + tasks.get(i).getName());}Task task = tasks.get(0);Map&lt;String, Object&gt; processVariables = taskService.getVariables(task.getId());System.out.println(processVariables.get(&quot;employee&quot;) + &quot; wants &quot; + processVariables.get(&quot;nrOfHolidays&quot;) + &quot; of holidays. Do you approve this?&quot;); 返回：123You have 1 tasks:1) Approve or reject requestjack wants 3 of holidays. Do you approve this? 现在managers可以完成这个任务了。同样的在完成任务时，虽然现实中是通过用户界面的表单来完成，在这里通过传递包含approved变量(这个变量很重要，决定后面流程的路线， 这里我们赋值为true)的map来进行。variables = new HashMap&lt;String, Object&gt;(); variables.put(&quot;approved&quot;, true); taskService.complete(task.getId(), variables);通过执行上面的代码managers完成了该任务，细心的你肯定在打印出的日志中发现了如下红框中的内容。对，没错，这就是自动化任务节点中打印出来的。也就是说，现在自动化任务节点已经完成，流程已经到达第二个用户任务了。同样的，根据XML中的定义， 我们知道第二个用户应该由jack自己(${employee}对就流程变量的值)来完成，通过以下代码即可查出jack需要完成的任务。1List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateOrAssigned(&quot;jack&quot;).list(); 用和managers同样的方法，jack就可以完成任务。至此，流程已经到达结束事件，整个流程也就走完了。 7. 查询历史数据Flowable为我们存储了丰富的流程实例执行的历史数据。例如我们想看到流程实例每个节点耗时情况，首先通过ProcessEngine获得HistoryService对象并且创建一个查询作如下限制： 查询待定流程实例的节点情况 只查看已完成的节点结果会按照结束时间排序，也就是执行顺序：123456789101112HistoryService historyService = processEngine.getHistoryService();List&lt;HistoricActivityInstance&gt; activities = historyService.createHistoricActivityInstanceQuery() .processInstanceId(processInstance.getId()) .finished() .orderByHistoricActivityInstanceEndTime().asc() .list();for (HistoricActivityInstance activity : activities) { System.out.println(activity.getActivityId() + &quot; took &quot; + activity.getDurationInMillis() + &quot; milliseconds&quot;);} 输出：123456startEvent took 3 millisecondsapproveTask took 3234 millisecondsdecision took 16 millisecondsexternalSystemCall took 4 millisecondsholidayApprovedTask took 5888 millisecondsapproveEnd took 2 milliseconds 也就是对应数据库表act_hi_actinst中的如下记录： 全文完。。。","link":"/2018/08/25/flowable流程引擎初体验，完成一个请假流程/"},{"title":"详解Java中ThreadPool的使用","text":"线程池就是限制系统中执行线程的数量。我们可以根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 为什么要用线程池: 1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 1.线程池继承体系如下图所示，Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 2.Executors 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 2.1 newSingleThreadExecutor 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 源码：123456public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } 实例：123456public classMyThread extends Thread { @Override publicvoid run() { System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;); }} 1234567891011121314151617181920publicclassTestSingleThreadExecutor { publicstaticvoid main(String[] args) { //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors. newSingleThreadExecutor(); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread t1 = new MyThread(); Thread t2 = new MyThread(); Thread t3 = new MyThread(); Thread t4 = new MyThread(); Thread t5 = new MyThread(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); }} 运行结果：12345pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。 2.2 newFixedThreadPool 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 源码：12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } 实例：1234567891011121314151617181920publicclass TestFixedThreadPool { publicstaticvoid main(String[] args) { //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread t1 = new MyThread(); Thread t2 = new MyThread(); Thread t3 = new MyThread(); Thread t4 = new MyThread(); Thread t5 = new MyThread(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); }} 运行结果：12345pool-1-thread-1正在执行。。。pool-1-thread-2正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-2正在执行。。。pool-1-thread-1正在执行。。。 2.3 newCachedThreadPool 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 源码：12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 实例：1234567891011121314151617181920publicclass TestCachedThreadPool { publicstaticvoid main(String[] args) { //创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newCachedThreadPool(); //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread t1 = new MyThread(); Thread t2 = new MyThread(); Thread t3 = new MyThread(); Thread t4 = new MyThread(); Thread t5 = new MyThread(); //将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); //关闭线程池 pool.shutdown(); }} 运行结果：123456pool-1-thread-2正在执行。。。pool-1-thread-4正在执行。。。pool-1-thread-3正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-5正在执行。。。 2.4 newScheduledThreadPool 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 源码：123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);} 实例：123456789101112131415161718publicclass TestScheduledThreadPoolExecutor { publicstaticvoid main(String[] args) { ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1); exec.scheduleAtFixedRate(new Runnable() {//每隔一段时间就触发异常 @Override publicvoid run() { //throw new RuntimeException(); System.out.println(&quot;================&quot;); } }, 1000, 5000, TimeUnit.MILLISECONDS); exec.scheduleAtFixedRate(new Runnable() {//每隔一段时间打印系统时间，证明两者是互不影响的 @Override publicvoid run() { System.out.println(System.nanoTime()); } }, 1000, 2000, TimeUnit.MILLISECONDS); }} 运行结果：12345678================838464454951683866438290348388643830710================839064385138383926438793198400643939383 3.ThreadPoolExecutor 从上面Executors类创建几种线程池的源码中可以发现，底层调用了ThreadPoolExecutor类的构造方法。下面就具体的看一看这个类的相关源码。 3.1 构造方法1234567891011121314151617181920212223242526272829303132/** * 用给定的参数创建一个线程池 * * @param corePoolSize 池中所保存的线程数，包括空闲线程。 * @param maximumPoolSize 池中允许的最大线程数。 * @param keepAliveTime 当线程数大于核心时，此为终止前多余的空闲线 程等待新任务的最长时间。 * @param unit 参数的时间单位。 * @param workQueue 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的Runnable任务。 * @param threadFactory 执行程序创建新线程时使用的工厂。 * @param handler 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } 3.2.execute方法 execute方法里面的代码逻辑对应着用户提交一个线程时的执行流程，如下流程图。 源码：12345678910111213141516171819public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) reject(command); } 3.3 BlockingQueue 参数 线程池的实现，队列起着至关重要的作用。它也是ThreadPoolExecutor构造方法里面的参数之间。从上面的excute执行逻辑知道当核心线程已满，如果等待队列未满，我们就可以把线程任务放到队列中去，当线程池中有空闲线程就会执行该任务。 3.3.1 类图：1234567ArrayBlockingQueue－－声明时就确定大小的队列，fifo方式。（方法基本和接口一致，没有特别要说明的内容）LinkedBlockingQueue－－链表实现的queue－remove效率会高一些PriorityBlockingQueue－－优先级队列SynchronousQueue--阻塞队列，必须拿走一个才能放进来一个，也就是最多只有一个～DelayQuque－－就是放进去的内容，延迟时间到了后才可以获得LinkedBlockDeque－－双端队列 ：offerFirst／offerLast，pollFirst/pollLastLinkedTransferQueue--类似LinkedUnBlockedQueue，其实就是transfer方法有人再等待队列内容就直接给他这个元素，没人在等就放在队列里面。也就是效率会更高。 3.3.2 排队的三种通用策略： 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 3.3.3 BlockingQueue的选择。 例子一：使用直接提交策略，也即SynchronousQueue。首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。 12345new ThreadPoolExecutor( 2, 3, 30, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new RecorderThreadFactory(&quot;CookieRecorderPool&quot;), new ThreadPoolExecutor.CallerRunsPolicy()); 当核心线程已经有2个正在运行.此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。什么意思？如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中。 例子二：使用无界队列策略，即LinkedBlockingQueue这个就拿newFixedThreadPool来说，根据前文提到的规则：如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。那么当任务继续增加，会发生什么呢？如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，不一会儿就爆了。 例子三：有界队列，使用ArrayBlockingQueue。这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。举例来说，请看如下构造方法：12345new ThreadPoolExecutor( 2, 4, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2), new RecorderThreadFactory(&quot;CookieRecorderPool&quot;), new ThreadPoolExecutor.CallerRunsPolicy()); 假设，所有的任务都永远无法执行完。对于首先来的A,B来说直接运行，接下来，如果来了C,D，他们会被放到queue中，如果接下来再来E,F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。 3.4 keepAliveTime 参数 由上可知，ThreadPoolExecutor中额定的“工人”数量由corePoolSize决定，当任务数量超过额定工人数量时，将任务缓存在BlockingQueue之中，当发现如果连queue中也放不下时（可能是因为使用有界queue，也可能是使用SynchronousQueue），ThreadPoolExecutor会请求“老板”再派几个“工人”过来。 接下来发生的事情有两种情况： 任务不再过来了 - keepAliveTime 任务仍然继续过来 - RejectedExecutionHandler 对于keepAliveTime参数，jdk中的解释是：当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 有点拗口，其实这个不难理解，在使用了“池”的应用中，大多都有类似的参数需要配置。比如数据库连接池，DBCP中的maxIdle，minIdle参数。 什么意思？接着上面的解释，后来向老板派来的工人始终是“借来的”，俗话说“有借就有还”，但这里的问题就是什么时候还了，如果借来的工人刚完成一个任务就还回去，后来发现任务还有，那岂不是又要去借？这一来一往，老板肯定头也大死了。 合理的策略：既然借了，那就多借一会儿。直到“某一段”时间后，发现再也用不到这些工人时，便可以还回去了。这里的某一段时间便是keepAliveTime的含义，TimeUnit为keepAliveTime值的度量。 总结： keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系。如果BlockingQueue是无界的，那么永远不会触发maximumPoolSize，自然keepAliveTime也就没有了意义。 反之，如果核心数较小，有界BlockingQueue数值又较小，同时keepAliveTime又设的很小，如果任务频繁，那么系统就会频繁的申请回收线程。 3.5 RejectedExecutionHandler 即拒绝策略，当即使向老板借了工人，但是任务还是继续过来，还是忙不过来，这时整个队伍只好拒绝接受了。RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会。在ThreadPoolExecutor中已经默认包含了4中策略，因为源码非常简单，这里直接贴出来。 3.5 .1 CallerRunsPolicy 线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 12345678910111213141516171819public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a {@code CallerRunsPolicy}. */ public CallerRunsPolicy() { } /** * Executes task r in the caller&apos;s thread, unless the executor * has been shut down, in which case the task is discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } } } 这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。 3.5 .2 AbortPolicy 处理程序遭到拒绝将抛出运行时 RejectedExecutionException 12345678910111213141516171819public static class AbortPolicy implements RejectedExecutionHandler { /** * Creates an {@code AbortPolicy}. */ public AbortPolicy() { } /** * Always throws RejectedExecutionException. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task * @throws RejectedExecutionException always */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); } } 这种策略直接抛出异常，丢弃任务。 3.5 .3 DiscardPolicy 不能执行的任务将被删除 123456789101112131415public static class DiscardPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardPolicy}. */ public DiscardPolicy() { } /** * Does nothing, which has the effect of discarding task r. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { } } 这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。 3.5 .4 DiscardOldestPolicy 如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程） 12345678910111213141516171819202122public static class DiscardOldestPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardOldestPolicy} for the given executor. */ public DiscardOldestPolicy() { } /** * Obtains and ignores the next task that the executor * would otherwise execute, if one is immediately available, * and then retries execution of task r, unless the executor * is shut down, in which case task r is instead discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } } } 该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。这个策略需要适当小心。设想:如果其他线程都还在运行，那么新来任务踢掉旧任务，缓存在queue中，再来一个任务又会踢掉queue中最老任务。","link":"/2017/07/05/详解Java中ThreadPool的使用/"},{"title":"JAVA基础系列（八） 多线程","text":"假如一个程序有多条执行流程，那么，该程序就是多线程程序。 1.多线程概述1.1 进程与线程 进程：正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。线程：是进程中的单个顺序控制流，是一条执行路径一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。 1.2 线程调度 CPU分配使用权的机制 线程有两种调度模型：分时调度模型： 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片抢占式调度模型 ： 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。Java使用的是抢占式调度模型。 1.3 Java程序运行原理 java 命令会启动 java 虚拟机，启动 JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。在此之前的所有程序都是单线程的。 思考题：jvm虚拟机的启动是单线程的还是多线程的?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答：多线程的。原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。 2.Thread类 public class Thread extends Object implements Runnable继承了Object类实现了Runnable接口 2.1 构造方法123456public Thread();public Thread(String name);public Thread(Runnable target);public Thread(Runnable target, String name);public Thread(ThreadGroup group, Runnable target);... 2.2 成员方法即线程控制12345678910111213141516171819202122//线程休眠public static void sleep(long millis)//线程加入,等待该线程终止。 public final void join()//线程礼让,暂停当前正在执行的线程对象，并执行其他线程。public static void yield()//后台线程,将该线程标记为守护线程或用户线程。//当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用public final void setDaemon(boolean on)//中断线程//让线程停止，过时了，但是还可以使用。public final void stop()中断线程。 把线程的状态终止，并抛出一个InterruptedException。public void interrupt()// 设置线程优先级，范围为1-10，默认为5// 线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。public final void setPriority(int newPriority) 注意：run与Start 的区别:1.start方法 用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。2.run方法 run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。 2.3 Thread.State 枚举类，表示线程运行周期中的几种状态。 NEW 状态是指线程刚创建, 尚未启动 RUNNABLE 状态是线程正在正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等 BLOCKED 这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法, 也就是这里是线程在等待进入临界区 WAITING 这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在临界点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束 TIMED_WAITING 这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态 TERMINATED 这个状态下表示该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收) 几种状态之间的关系图解如下： 注意：在JDK8的API中 Thread.State 并没有RUNNING这个状态，这里是为了便于理解画在图中。 3.多线程实现的几种方式JAVA多线程实现方式主要有三种： 3.1、继承Thread类，并重写run()方法 Demo:123456789101112131415161718192021222324252627282930313233public class SellTicketDemo { public static void main(String[] args) { // 创建三个线程对象 SellTicket st1 = new SellTicket(); SellTicket st2 = new SellTicket(); SellTicket st3 = new SellTicket(); // 给线程对象起名字 st1.setName(&quot;窗口1&quot;); st2.setName(&quot;窗口2&quot;); st3.setName(&quot;窗口3&quot;); // 启动线程 st1.start(); st2.start(); st3.start(); }}class SellTicket extends Thread { // 定义100张票 // 为了让多个线程对象共享这100张票，我们其实应该用静态修饰 private static int tickets = 100; @Override public void run() { // 是为了模拟一直有票 while (tickets &gt; 0) { System.out.println(getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票&quot;); } }} 3.2、 实现Runnable接口，实现run()方法 Demo:123456789101112131415161718192021222324252627282930313233/* * 实现Runnable接口的方式实现 */public class SellTicketDemo { public static void main(String[] args) { // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, &quot;窗口1&quot;); Thread t2 = new Thread(st, &quot;窗口2&quot;); Thread t3 = new Thread(st, &quot;窗口3&quot;); // 启动线程 t1.start(); t2.start(); t3.start(); }}class SellTicket implements Runnable { // 定义100张票 private int tickets = 100; @Override public void run() { while (tickets &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票&quot;); } System.out.println(Thread.currentThread().getName() + &quot;:没票了哦!&quot;); }} 3.3、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。 Demo:12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableDemo { public static void main(String[] args) throws InterruptedException, ExecutionException { FutureTask&lt;Integer&gt; f1 = new FutureTask&lt;Integer&gt;(new MyCallable(100)); FutureTask&lt;Integer&gt; f2 = new FutureTask&lt;Integer&gt;(new MyCallable(200)); // FutureTask实现了两个接口，Runnable和Future new Thread(f1).start(); new Thread(f2).start(); Integer i1 = f1.get(); Integer i2 = f2.get(); System.out.println(i1); System.out.println(i2); }}class MyCallable implements Callable&lt;Integer&gt; { private int number; public MyCallable(int number) { this.number = number; } @Override public Integer call() throws Exception { int sum = 0; for (int x = 1; x &lt;= number; x++) { sum += x; } return sum; }} Demo:使用线程池12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class CallableDemo { public static void main(String[] args) throws InterruptedException, ExecutionException { // 创建线程池对象 ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100)); Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200)); // V get() Integer i1 = f1.get(); Integer i2 = f2.get(); System.out.println(i1); System.out.println(i2); // 结束 pool.shutdown(); }}class MyCallable implements Callable&lt;Integer&gt; { private int number; public MyCallable(int number) { this.number = number; } @Override public Integer call() throws Exception { int sum = 0; for (int x = 1; x &lt;= number; x++) { sum += x; } return sum; }} 3.4 匿名内部类方式使用多线程 new Thread(){代码…}.start();New Thread(new Runnable(){代码…}).start(); Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * 匿名内部类的格式： * new 类名或者接口名() { * 重写方法; * }; * 本质：是该类或者接口的子类对象。 */public class ThreadDemo { public static void main(String[] args) { // 继承Thread类来实现多线程 new Thread() { public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); } } }.start(); // 实现Runnable接口来实现多线程 new Thread(new Runnable() { @Override public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); } } }) .start(); // 更有难度的 new Thread(new Runnable() { @Override public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(&quot;hello&quot; + &quot;:&quot; + x); } } }) { public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(&quot;world&quot; + &quot;:&quot; + x); } } }.start(); }} 4.线程同步4.1 同步代码块 Demo:123456789101112131415161718192021222324252627282930313233343536373839404142public class SellTicketDemo { public static void main(String[] args) { // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, &quot;窗口1&quot;); Thread t2 = new Thread(st, &quot;窗口2&quot;); Thread t3 = new Thread(st, &quot;窗口3&quot;); // 启动线程 t1.start(); t2.start(); t3.start(); }}class SellTicket implements Runnable { // 定义100张票 private int tickets = 100; // 创建锁对象 private Object obj = new Object(); @Override public void run() { while (tickets &gt; 0) { synchronized (obj) { if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票&quot;); } } } System.out.println(Thread.currentThread().getName() + &quot;:没票了哦!&quot;); }} 4.2 同步方法 Demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SellTicketDemo { public static void main(String[] args) { // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个线程对象 Thread t1 = new Thread(st, &quot;窗口1&quot;); Thread t2 = new Thread(st, &quot;窗口2&quot;); Thread t3 = new Thread(st, &quot;窗口3&quot;); // 启动线程 t1.start(); t2.start(); t3.start(); }}class SellTicket implements Runnable { // 定义100张票 private static int tickets = 100; private int x = 0; @Override public void run() { while (tickets &gt; 0) { if (x % 2 == 0) { // 当同步方法为静态时锁对象应该为SellTicket.class synchronized (this) { if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票 &quot;); } } } else { sellTicket(); } x++; } System.out.println(Thread.currentThread().getName() + &quot;:没票了哦!&quot;); } // 当同步方法为静态时锁对象应该为SellTicket.class private synchronized void sellTicket() { if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票 &quot;); } }} 注意：1.同步代码块的锁对象是任意对象。2.同步方法的锁对象是this。3.静态同步方法的锁对象是类的字节码文件对象。 4.3 Lock锁的使用 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * Lock： * void lock()： 获取锁。 * void unlock():释放锁。 * ReentrantLock是Lock的实现类. */import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SellTicketDemo { public static void main(String[] args) { // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个窗口 Thread t1 = new Thread(st, &quot;窗口1&quot;); Thread t2 = new Thread(st, &quot;窗口2&quot;); Thread t3 = new Thread(st, &quot;窗口3&quot;); // 启动线程 t1.start(); t2.start(); t3.start(); }}class SellTicket implements Runnable { // 定义票 private int tickets = 100; // 定义锁对象 private Lock lock = new ReentrantLock(); @Override public void run() { while (tickets &gt; 0) { try { // 加锁 lock.lock(); if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (tickets--) + &quot;张票&quot;); } } finally { // 释放锁 lock.unlock(); } } System.out.println(Thread.currentThread().getName() + &quot;:没票了哦!&quot;); }} 4.4 死锁 是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象.如果出现了同步嵌套，就容易产生死锁问题 Demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 同步的弊端： * A:效率低 * B:容易产生死锁 * * * 举例： * 中国人，美国人吃饭案例。 * 正常情况： * 中国人:筷子两支 * 美国人:刀和叉 * 现在： * 中国人：筷子1支，刀一把 * 美国人：筷子1支，叉一把 */public class DieLockDemo { public static void main(String[] args) { DieLock dl1 = new DieLock(true); DieLock dl2 = new DieLock(false); dl1.start(); dl2.start(); }}class DieLock extends Thread { private boolean flag; public DieLock(boolean flag) { this.flag = flag; } @Override public void run() { if (flag) { synchronized (MyLock.objA) { System.out.println(&quot;if objA&quot;); synchronized (MyLock.objB) { System.out.println(&quot;if objB&quot;); } } } else { synchronized (MyLock.objB) { System.out.println(&quot;else objB&quot;); synchronized (MyLock.objA) { System.out.println(&quot;else objA&quot;); } } } }}class MyLock { // 创建两把锁对象 public static final Object objA = new Object(); public static final Object objB = new Object();} 5. 线程通信 针对同一个资源的操作有不同种类的线程 Demo:生产者消费者模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Vector;/* * 篮子容量为5，生产者每1秒钟生产一个产品，消费者每2秒钟消费一个产品 * 当篮子为空时消费者会等待生产者生产，当篮子装满时生产者等消费者消费 */public class ProcucerAndConsumerDemo { public static void main(String[] args) { // 用Vector来模拟篮子 Vector obj = new Vector(); // 通过构造函数来共享一个对象 Thread consumer = new Thread(new Consumer(obj)); Thread producter = new Thread(new Producer(obj)); consumer.start(); producter.start(); }}class Producer implements Runnable { private Vector obj; public Producer(Vector v) { this.obj = v; } public void run() { while (true) { synchronized (this.obj) { try { if (this.obj.size() &gt; 4) { System.out.println(&quot;Producter:the basked has full!&quot;); this.obj.wait(); } this.obj.add(new String(&quot;apples&quot;)); System.out.println(&quot;Producter:I have produced one&quot;); this.obj.notify(); Thread.sleep(1000); } catch (Exception e) { e.printStackTrace(); } } } }}class Consumer implements Runnable { private Vector obj; public Consumer(Vector v) { this.obj = v; } public void run() { while (true) { synchronized (this.obj) { try { if (this.obj.size() == 0) { System.out.println(&quot;Consumer:the basked is null!&quot;); this.obj.wait(); } this.obj.remove(0); System.out.println(&quot;Consumer:I have taken one&quot;); System.out.println(&quot;obj size: &quot; + this.obj.size()); this.obj.notify(); Thread.sleep(2000); } catch (Exception e) { e.printStackTrace(); } } } }} Result: Consumer:the basked is null!Producter:I have produced oneProducter:I have produced oneConsumer:I have taken oneobj size: 1Consumer:I have taken oneobj size: 0Consumer:the basked is null!Producter:I have produced oneProducter:I have produced oneProducter:I have produced oneProducter:I have produced oneProducter:I have produced oneConsumer:I have taken oneobj size: 4Consumer:I have taken oneobj size: 3Consumer:I have taken oneobj size: 2Consumer:I have taken oneobj size: 1Consumer:I have taken oneobj size: 0Consumer:the basked is null!Producter:I have produced oneProducter:I have produced one 6.线程组 把多个线程组合到一起。它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 构造方法123private ThreadGroup();public ThreadGroup(String name);public ThreadGroup(ThreadGroup parent, String name); 成员方法1234public final void setDaemon(boolean daemon) ;public final void interrupt();void add(Thread t);... Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class ThreadGroupDemo { public static void main(String[] args) { method1(); // method2(); } private static void method2() { // ThreadGroup(String name) ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;); MyRunnable my = new MyRunnable(); // Thread(ThreadGroup group, Runnable target, String name) Thread t1 = new Thread(tg, my, &quot;林青霞&quot;); Thread t2 = new Thread(tg, my, &quot;刘意&quot;); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); t1.start(); t2.start(); // 通过组名称设置后台线程，表示该组的线程都是后台线程 tg.setDaemon(true); } private static void method1() { MyRunnable my = new MyRunnable(); Thread t1 = new Thread(my, &quot;林青霞&quot;); Thread t2 = new Thread(my, &quot;刘意&quot;); // 我不知道他们属于那个线程组,我想知道，怎么办 // 线程类里面的方法：public final ThreadGroup getThreadGroup() ThreadGroup tg1 = t1.getThreadGroup(); ThreadGroup tg2 = t2.getThreadGroup(); // 线程组里面的方法：public final String getName() String name1 = tg1.getName(); String name2 = tg2.getName(); System.out.println(name1); System.out.println(name2); // 通过结果我们知道了：线程默认情况下属于main线程组 // 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组 System.out.println(Thread.currentThread().getThreadGroup().getName()); t1.start(); t2.start(); // 通过组名称设置后台线程，表示该组的线程都是后台线程 Thread.currentThread().getThreadGroup().setDaemon(true); }}class MyRunnable implements Runnable { @Override public void run() { for (int x = 0; x &lt; 100; x++) { try { Thread.sleep(100); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); } }} 7.线程池 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法123public static ExecutorService newCachedThreadPool()public static ExecutorService newFixedThreadPool(int nThreads)public static ExecutorService newSingleThreadExecutor() 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。 Demo:123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/* * * 如何实现线程池的代码呢? * A:创建一个线程池对象，控制要创建几个线程对象。 * public static ExecutorService newFixedThreadPool(int nThreads) * B:这种线程池的线程可以执行： * 可以执行Runnable对象或者Callable对象代表的线程 * 做一个类实现Runnable接口。 * C:调用如下方法即可 * Future&lt;?&gt; submit(Runnable task) * &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) * D:我就要结束，可以吗? * 可以。 */public class ExecutorsDemo { public static void main(String[] args) { // 创建一个线程池对象，控制要创建几个线程对象。 // public static ExecutorService newFixedThreadPool(int nThreads) ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); // 结束线程池 pool.shutdown(); }}class MyRunnable implements Runnable { @Override public void run() { for (int x = 0; x &lt; 100; x++) { System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); } }} 8.定时器 定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。 在Java中，可以通过Timer和TimerTask类来实现定义调度的功能1234567891011121314151617//Timerpublic Timer()//在指定延迟(delay)后执行任务public void schedule(TimerTask task, long delay)//在指定延迟(delay)后间隔(period)执行任务public void schedule(TimerTask task,long delay,long period)//在指定时间(time)执行任务public void schedule(TimerTask task, Date time)//在指定时间( firstTime)开始间隔(period)执行任务public void schedule(TimerTask task, Date firstTime, long period)//TimerTaskpublic abstract void run()public boolean cancel() Demo1:12345678910111213141516171819import java.util.Timer;import java.util.TimerTask;public class TimerDemo2 { public static void main(String[] args) { // 创建定时器对象 Timer t = new Timer(); // 3秒后执行爆炸任务第一次，如果不成功，每隔2秒再继续炸 t.schedule(new MyTask2(), 3000, 2000); }}// 做一个任务class MyTask2 extends TimerTask { @Override public void run() { System.out.println(&quot;beng,爆炸了&quot;); }} Demo2:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;/* * 需求：在指定的时间删除我们的指定目录(你可以指定c盘，但是我不建议，我使用项目路径下的demo) */public class TimerTest { public static void main(String[] args) throws ParseException { Timer t = new Timer(); String s = &quot;2014-11-27 15:45:00&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date d = sdf.parse(s); t.schedule(new DeleteFolder(), d); }}class DeleteFolder extends TimerTask { @Override public void run() { File srcFolder = new File(&quot;demo&quot;); deleteFolder(srcFolder); } // 递归删除目录 public void deleteFolder(File srcFolder) { File[] fileArray = srcFolder.listFiles(); if (fileArray != null) { for (File file : fileArray) { if (file.isDirectory()) { deleteFolder(file); } else { System.out.println(file.getName() + &quot;:&quot; + file.delete()); } } System.out.println(srcFolder.getName() + &quot;:&quot; + srcFolder.delete()); } }}","link":"/2017/06/03/JAVA基础系列（八） 多线程/"},{"title":"JAVA基础系列（四） 几种常用的类","text":"1.Object Class Object is the root of the class hierarchy. Every class has Object as a superclass. All objects, including arrays, implement the methods of this class. 常用的成员方法 123456789101112131415161718//Returns a hash code value for the object.public native int hashCode();//Returns the runtime class of this Object.public final Class getClass();//Returns a string representation of the object.public String toString();//Indicates whether some other object is &quot;equal to&quot; this one.public boolean equals(Object obj);//Called by the garbage collector on an object when garbage collection determines //that there are no more references to the object.protected void finalize();//Creates and returns a copy of this object.protected Object clone(); 2. Scanner 用于获取键盘的输入;A simple text scanner which can parse primitive types and strings using regular expressions.A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods. 构造方法 1234567891011/** * Constructs a new &lt;code&gt;Scanner&lt;/code&gt; that produces values scanned * from the specified input stream. Bytes from the stream are converted * into characters using the underlying platform&apos;s * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}. * * @param source An input stream to be scanned */ public Scanner(InputStream source) { this(new InputStreamReader(source), WHITESPACE_PATTERN); } 常用成员方法 1234567891011121314151617181920212223242526272829303132333435/** * Returns true if there is another line in the input of this scanner. * This method may block while waiting for input. The scanner does not * advance past any input. * * @return true if and only if this scanner has another line of input * @throws IllegalStateException if this scanner is closed */ public boolean hasNextLine();/** * Returns true if the next token in this scanner&apos;s input can be * interpreted as an int value in the default radix using the * {@link #nextInt} method. The scanner does not advance past any input. * * @return true if and only if this scanner&apos;s next token is a valid * int value * @throws IllegalStateException if this scanner is closed */ public boolean hasNextInt();/** * Advances this scanner past the current line and returns the input * that was skipped. * * This method returns the rest of the current line, excluding any line * separator at the end. The position is set to the beginning of the next * line. */ public String nextLine(); /** * Scans the next token of the input as an int; */ public int nextInt(); Demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Scanner;/* * 常用的两个方法： * public int nextInt():获取一个int类型的值 * public String nextLine():获取一个String类型的值 * * 出现问题了： * 先获取一个数值，在获取一个字符串，会出现问题。 * 主要原因：就是那个换行符号的问题。 * 如何解决呢? * A:先获取一个数值后，在创建一个新的键盘录入对象获取字符串。 * B:把所有的数据都先按照字符串获取，然后要什么，你就对应的转换为什么。 */public class ScannerDemo { public static void main(String[] args) { // 创建对象 Scanner sc = new Scanner(System.in); // 获取两个int类型的值 // int a = sc.nextInt(); // int b = sc.nextInt(); // System.out.println(&quot;a:&quot; + a + &quot;,b:&quot; + b); // System.out.println(&quot;-------------------&quot;); // 获取两个String类型的值 // String s1 = sc.nextLine(); // String s2 = sc.nextLine(); // System.out.println(&quot;s1:&quot; + s1 + &quot;,s2:&quot; + s2); // System.out.println(&quot;-------------------&quot;); // 先获取一个字符串，在获取一个int值 // String s1 = sc.nextLine(); // int b = sc.nextInt(); // System.out.println(&quot;s1:&quot; + s1 + &quot;,b:&quot; + b); // System.out.println(&quot;-------------------&quot;); // 先获取一个int值，在获取一个字符串 // int a = sc.nextInt(); // String s2 = sc.nextLine(); // System.out.println(&quot;a:&quot; + a + &quot;,s2:&quot; + s2); // System.out.println(&quot;-------------------&quot;); int a = sc.nextInt(); Scanner sc2 = new Scanner(System.in); String s = sc2.nextLine(); System.out.println(&quot;a:&quot; + a + &quot;,s:&quot; + s); }} 3. String 就是由多个字符组成的一串数据。也可以看成是一个字符数组。 构造方法 123456public String()public String(byte[] bytes)public String(byte[] bytes,int offset,int length)public String(char[] value)public String(char[] value,int offset,int count)public String(String original) 常用成员方法 1234567891011121314151617181920212223242526272829303132//判断功能boolean equals(Object obj)boolean equalsIgnoreCase(String str)boolean contains(String str)boolean startsWith(String str)boolean endsWith(String str)boolean isEmpty()// 获取功能int length()char charAt(int index)int indexOf(int ch)int indexOf(String str)int indexOf(int ch,int fromIndex)int indexOf(String str,int fromIndex)String substring(int start)String substring(int start,int end)// 转换功能byte[] getBytes()char[] toCharArray()static String valueOf(char[] chs)static String valueOf(int i)String toLowerCase()String toUpperCase()String concat(String str)//替换功能String replace(char old,char new)String replace(String old,String new)//去除字符串两空格 String trim()//按字典顺序比较两个字符串 int compareTo(String str)int compareToIgnoreCase(String str) 关于字符串的不变性 1.字符串如果是变量相加，先开空间，再拼接2.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建Demo:12345678910111213141516171819202122232425262728293031323334353637package com.hust.acamy;public class StringDemo1 { public static void main(String[] args) { String s1 = new String(&quot;hello&quot;); String s2 = new String(&quot;hello&quot;); System.out.println(s1 == s2);// false System.out.println(s1.equals(s2));// true String s3 = new String(&quot;hello&quot;); String s4 = &quot;hello&quot;; System.out.println(s3 == s4);// false System.out.println(s3.equals(s4));// true String s5 = &quot;hello&quot;; String s6 = &quot;hello&quot;; System.out.println(s5 == s6);// true System.out.println(s5.equals(s6));// true }}package com.hust.acamy;public class StringDemo2 { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + s2;// 变量相加，在堆中创建了一个新的对象 System.out.println(s3 == s1 + s2);// false s3指向常量池，s1 + s2 指向堆 System.out.println(s4 == s1 + s2);// false s4和s1 + s2 是堆中两个不同的对象 System.out.println(s3.equals((s1 + s2)));// true 值相等 System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// true 常量相加，先拼接 System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true 值相等 }} 4. StringBuffer 线程安全的可变字符序列 构造方法 123public StringBuffer() public StringBuffer(int capacity)public StringBuffer(String str) 成员方法 12345678910111213//添加功能public StringBuffer append(String str)public StringBuffer insert(int offset,String str)//删除功能public StringBuffer deleteCharAt(int index)public StringBuffer delete(int start,int end)//替换功能public StringBuffer replace(int start,int end,String str)//反转功能 public StringBuffer reverse()//截取功能public String substring(int start)public String substring(int start,int end) 注意：截取功能和前面几个功能的不同,返回值类型是String类型，本身没有发生改变。 String,StringBuffer,StringBuilder的区别 (1) String是内容不可变的，而StringBuffer,StringBuilder都是内容可变的。(2) StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高 值传递和引用传递 值传递：方法调用时，实际参数把它的值传递给对应的形式参数，方法执行中形式参数值的改变不影响实际参 数的值。引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，在方法执行中，对形式参数的操作实际上就是对实际参数的操作，方法执行中形式参数值的改变将会影响实际参数的值。 Java参数，不管是原始类型还是引用类型，传递的都是副本(有另外一种说法是传值，但是说传副本更好理解吧，传值通常是相对传址而言)。 传递值的数据类型：八种基本数据类型和String(这样理解可以，但是事实上String也是传递的地址,只是string对象和其他对象是不同的，string对象是不能被改变的，内容改变就会产生新对象。那么StringBuffer就可以了，但只是改变其内容。不能改变外部变量所指向的内存地址)。 传递地址值的数据类型：除String以外的所有复合数据类型，包括数组、类和接口 Demo1:1234567891011121314151617181920212223242526public class StringBufferDemo { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; System.out.println(s1 + &quot;---&quot; + s2);// hello---world change(s1, s2); System.out.println(s1 + &quot;---&quot; + s2);// hello---world StringBuffer sb1 = new StringBuffer(&quot;hello&quot;); StringBuffer sb2 = new StringBuffer(&quot;world&quot;); System.out.println(sb1 + &quot;---&quot; + sb2);// hello---world change(sb1, sb2); System.out.println(sb1 + &quot;---&quot; + sb2);// hello---worldworld } public static void change(StringBuffer sb1, StringBuffer sb2) { sb1 = sb2; sb2.append(sb1); } public static void change(String s1, String s2) { s1 = s2; s2 = s1 + s2; }} Demo2:12345678910111213141516public class Test { String str = new String(&quot;old&quot;); char[] ch = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; }; public static void main(String args[]) { Test ex = new Test(); ex.change(ex.str, ex.ch); System.out.print(ex.str + &quot; and &quot;); System.out.println(ex.ch); } public void change(String str, char ch[]) { str = &quot;new&quot;; ch[0] = &apos;d&apos;; } } String 比较特别，看过String 代码的都知道， String 是 final的。所以值是不变的。 函数中String对象引用的副本指向了另外一个新String对象,而数组对象引用的副本没有改变,而是改变对象中数据的内容. 对于对象类型，也就是Object的子类，如果你在方法中修改了它的成员的值，那个修改是生效的，方法调用结束后，它的成员是新的值，但是如果你把它指向一个其它的对象，方法调用结束后，原来对它的引用并没用指向新的对象。 如果参数类型是原始类型，那么传过来的就是这个参数的一个副本，也就是这个原始参数的值，这个跟之前所谈的传值是一样的。如果在函数中改变了副本的值不会改变原始的值. 如果参数类型是引用类型，那么传过来的就是这个引用参数的副本，这个副本存放的是参数的地址。如果在函数中没有改变这个副本的地址，而是改变了地址中的值，那么在函数内的改变会影响到传入的参数。如果在函数中改变了副本的地址，如new一个，那么副本就指向了一个新的地址，此时传入的参数还是指向原来的地址，所以不会改变参数的值。 5. Arrays 针对数组进行操作的工具类。提供了排序，查找等功能。 成员方法 12345678910111213141516171819202122232425262728293031323334353637public static String toString(int[] a) { if (a == null) return &quot;null&quot;; //说明数组对象不存在 int iMax = a.length - 1; //iMax=4; if (iMax == -1) return &quot;[]&quot;; //说明数组存在,但是没有元素。 StringBuilder b = new StringBuilder(); b.append(&apos;[&apos;); //&quot;[&quot; for (int i = 0; ; i++) { b.append(a[i]); //&quot;[24, 69, 80, 57, 13&quot; if (i == iMax) //&quot;[24, 69, 80, 57, 13]&quot; return b.append(&apos;]&apos;).toString(); b.append(&quot;, &quot;); //&quot;[24, 69, 80, 57, &quot; }}//底层是快速排序public static void sort(int[] a);private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; //low=0 int high = toIndex - 1; //high=4 while (low &lt;= high) { int mid = (low + high) &gt;&gt;&gt; 1; //mid=2,mid=3,mid=4 int midVal = a[mid]; //midVal=57,midVal=69,midVal=80 if (midVal &lt; key) low = mid + 1; //low=3,low=4,low=5 else if (midVal &gt; key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found.} 6. Integer 为了对基本数据类型进行更多的操作，更方便的操作，Java就针对每一种基本数据类型提供了对应的类类型。包装类类型。用于基本数据类型与字符串之间的转换。基本类型和包装类的对应Byte,Short,Integer,Long,Float,Double,Character,Boolean 构造方法 123public Integer(int value)//注意：这个字符串必须是由数字字符组成public Integer(String s) 成员方法 12345678910111213141516//int类型和String类型的相互转换//int – String//String – intpublic int intValue()public static int parseInt(String s)public static String toString(int i)public static Integer valueOf(int i)public static Integer valueOf(String s)//常用的基本进制转换public static String toBinaryString(int i)public static String toOctalString(int i)public static String toHexString(int i)//十进制到其他进制public static String toString(int i,int radix)//其他进制到十进制public static int parseInt(String s,int radix) 自动装箱与自动拆箱 JDK5的新特性 自动装箱：把基本类型转换为包装类类型 自动拆箱：把包装类类型转换为基本类型Integer x = new Integer(4);可以直接写成Integer x = 4;//自动装箱。x = x + 5;//自动拆箱。通过intValue方法。需要注意：在使用时，Integer x = null;上面的代码就会出现NullPointerException。建议先判断是否为null，然后再使用。 Demo:123456789101112131415161718192021public class IntegerDemo { public static void main(String[] args) { // 定义了一个int类型的包装类类型变量i // Integer i = new Integer(100); Integer ii = 100; ii += 200; System.out.println(&quot;ii:&quot; + ii); // 通过反编译后的代码 // Integer ii = Integer.valueOf(100); //自动装箱 // ii = Integer.valueOf(ii.intValue() + 200); //自动拆箱，再自动装箱 // System.out.println((new StringBuilder(&quot;ii:&quot;)).append(ii).toString()); Integer iii = null; // NullPointerException if (iii != null) { iii += 1000; System.out.println(iii); } }} 7. Character Character 类在对象中包装一个基本类型 char 的值此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然 构造方法 public Character(char value) 成员方法 12345public static boolean isUpperCase(char ch)public static boolean isLowerCase(char ch)public static boolean isDigit(char ch)public static char toUpperCase(char ch)public static char toLowerCase(char ch) Test:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;/* * 统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) * * 分析： * A:定义三个统计变量。 * int bigCont=0; * int smalCount=0; * int numberCount=0; * B:键盘录入一个字符串。 * C:把字符串转换为字符数组。 * D:遍历字符数组获取到每一个字符 * E:判断该字符是 * 大写 bigCount++; * 小写 smalCount++; * 数字 numberCount++; * F:输出结果即可 */public class CharacterTest { public static void main(String[] args) { // 定义三个统计变量。 int bigCount = 0; int smallCount = 0; int numberCount = 0; // 键盘录入一个字符串。 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String line = sc.nextLine(); // 把字符串转换为字符数组。 char[] chs = line.toCharArray(); // 历字符数组获取到每一个字符 for (int x = 0; x &lt; chs.length; x++) { char ch = chs[x]; // 判断该字符 if (Character.isUpperCase(ch)) { bigCount++; } else if (Character.isLowerCase(ch)) { smallCount++; } else if (Character.isDigit(ch)) { numberCount++; } } // 输出结果即可 System.out.println(&quot;大写字母：&quot; + bigCount + &quot;个&quot;); System.out.println(&quot;小写字母：&quot; + smallCount + &quot;个&quot;); System.out.println(&quot;数字字符：&quot; + numberCount + &quot;个&quot;); }} 8. 正则表达式 是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。 正则表达式的应用 12345678判断功能public boolean matches(String regex)分割功能public String[] split(String regex)替换功能public String replaceAll(String regex,String replacement)获取功能Pattern和Matcher类的使用 Demo1:1234567891011121314151617181920212223242526272829303132333435363738/* * 判断功能 * String类的public boolean matches(String regex) * * 需求： * 判断手机号码是否满足要求? * * 分析： * A:键盘录入手机号码 * B:定义手机号码的规则 * 13436975980 * 13688886868 * 13866668888 * 13456789012 * 13123456789 * 18912345678 * 18886867878 * 18638833883 * C:调用功能，判断即可 * D:输出结果 */public class RegexDemo { public static void main(String[] args) { // 键盘录入手机号码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的手机号码：&quot;); String phone = sc.nextLine(); // 定义手机号码的规则 String regex = &quot;1[38]\\\\d{9}&quot;; // 调用功能，判断即可 boolean flag = phone.matches(regex); // 输出结果 System.out.println(&quot;flag:&quot; + flag); }} Demo2:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.regex.Matcher;import java.util.regex.Pattern;/* * 获取功能： * 获取下面这个字符串中由三个字符组成的单词 * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu? */public class RegexDemo2 { public static void main(String[] args) { // 定义字符串 String s = &quot;da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?&quot;; // 规则 String regex = &quot;\\\\b\\\\w{3}\\\\b&quot;; // 把规则编译成模式对象 Pattern p = Pattern.compile(regex); // 通过模式对象得到匹配器对象 Matcher m = p.matcher(s); // 调用匹配器对象的功能 // 通过find方法就是查找有没有满足条件的子串 // public boolean find() // boolean flag = m.find(); // System.out.println(flag); // // 如何得到值呢? // // public String group() // String ss = m.group(); // System.out.println(ss); // // // 再来一次 // flag = m.find(); // System.out.println(flag); // ss = m.group(); // System.out.println(ss); while (m.find()) { System.out.println(m.group()); } // 注意：一定要先find()，然后才能group() // IllegalStateException: No match found // String ss = m.group(); // System.out.println(ss); }} 9. Math Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 成员方法 12345678public static int abs(int a)public static double ceil(double a)public static double floor(double a)public static int max(int a,int b) public static double pow(double a,double b)public static double random()public static int round(float a) public static double sqrt(double a) 10. Random 此类用于产生随机数 构造方法 123public Random(); //没有给种子，用的是默认种子，是当前时间的毫秒值public Random(long seed); //给出指定的种子//给定种子后，每次得到的随机数是相同的。 成员方法 123public int nextInt(); //返回的是int范围内的随机数public int nextInt(int n); //返回的是[0,n)范围的内随机数 Demo:12345678910111213public class RandomDemo { public static void main(String[] args) { // 创建对象 // Random r = new Random(); Random r = new Random(1111); for (int x = 0; x &lt; 10; x++) { // int num = r.nextInt(); int num = r.nextInt(100) + 1; System.out.println(num); } }} 11. System System 类包含一些有用的类字段和方法。它不能被实例化。 成员方法 1234public static void gc()public static void exit(int status)public static long currentTimeMillis()public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length); 注意：System.gc()可用于垃圾回收。当使用System.gc()回收某个对象所占用的内存之前，通过要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，Java提高了默认机制来清理该对象的资源，就是调用Object类的finalize()方法。finalize()方法的作用是释放一个对象占用的内存空间时，会被JVM调用。而子类重写该方法，就可以清理对象占用的资源，该方法有没有链式调用，所以必须手动实现。从程序的运行结果可以发现，执行System.gc()前，系统会自动调用finalize()方法清除对象占有的资源，通过super.finalize()方式可以实现从下到上的finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，jvm都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的Java程序运行争抢资源，只有在执行大量的对象的释放，才调用垃圾回收最好 12. Date 表示特定的瞬间，精确到毫秒。 构造方法 12public Date() // 根据当前的默认毫秒值创建日期对象public Date(long date) // 根据给定的毫秒值创建日期对象 成员方法 12public long getTime() //获取时间，以毫秒为单位public void setTime(long time) //设置时间 13 . DateFormat DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat SimpleDateFormat构造方法 12public SimpleDateFormat()public SimpleDateFormat(String pattern) 成员方法 12public final String format(Date date)public Date parse(String source) Demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* * Date -- String(格式化) * public final String format(Date date) * * String -- Date(解析) * public Date parse(String source) * * DateForamt:可以进行日期和字符串的格式化和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat。 * * SimpleDateFormat的构造方法： * SimpleDateFormat():默认模式 * SimpleDateFormat(String pattern):给定的模式 * 这个模式字符串该如何写呢? * 通过查看API，我们就找到了对应的模式 * 年 y * 月 M * 日 d * 时 H * 分 m * 秒 s * * 2014年12月12日 12:12:12 */public class DateFormatDemo { public static void main(String[] args) throws ParseException { // Date -- String // 创建日期对象 Date d = new Date(); // 创建格式化对象 // SimpleDateFormat sdf = new SimpleDateFormat(); // 给定模式 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); // public final String format(Date date) String s = sdf.format(d); System.out.println(s); // String -- Date String str = &quot;2008-08-08 12:12:12&quot;; // 在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配 SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date dd = sdf2.parse(str); System.out.println(dd); }} 14 . Calendar Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 成员方法 1234567public static Calendar getInstance()//返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。public int get(int field)//根据给定的日历字段和对应的时间，来对当前的日历进行操作。public void add(int field,int amount)//设置日历对象的年月日public final void set(int year,int month,int date) Demo:1234567891011121314151617181920212223242526272829303132import java.util.Calendar;import java.util.Scanner;/* * 获取任意一年的二月有多少天 * * 分析： * A:键盘录入任意的年份 * B:设置日历对象的年月日 * 年就是A输入的数据 * 月是2 * 日是1 * C:把时间往前推一天，就是2月的最后一天 * D:获取这一天输出即可 */public class CalendarTest { public static void main(String[] args) { // 键盘录入任意的年份 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入年份：&quot;); int year = sc.nextInt(); // 设置日历对象的年月日 Calendar c = Calendar.getInstance(); c.set(year, 2, 1); // 其实是这一年的3月1日 // 把时间往前推一天，就是2月的最后一天 c.add(Calendar.DATE, -1); // 获取这一天输出即可 System.out.println(c.get(Calendar.DATE)); }}","link":"/2017/05/31/JAVA基础系列（四） 几种常用的类/"},{"title":"JAVA基础系列（七） IO流","text":"IO流体系分字节流和字符流，里面又都分为输入输出流。下图展示了IO体系的框架图。粗体部分为本文涉及到的IO流。 本文主要是采用输入输出配对方式进行IO流的讲解，同时附带有相关的类的介绍，本文内容构架如下图： 1. File 文件和目录路径名的抽象表示形式 1.1 构造方法123public File(String pathname)public File(String parent,String child)public File(File parent,String child) 1.2 成员方法12345678910111213141516171819202122232425262728293031323334创建功能：public boolean createNewFile()//创建文件 如果存在这样的文件，就不创建了public boolean mkdir()//创建文件夹 如果存在这样的文件夹，就不创建了public boolean mkdirs()//创建文件夹,如果父文件夹不存在，会帮你创建出来删除功能:public boolean delete()注意：A:如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。B:Java中的删除不走回收站。C:要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹重命名功能:public boolean renameTo(File dest)注意：如果路径名相同，就是改名。如果路径名不同，就是改名并剪切。判断功能:public boolean isDirectory()//判断是否是目录public boolean isFile()//判断是否是文件public boolean exists()//判断是否存在public boolean canRead()//判断是否可读public boolean canWrite()//判断是否可写public boolean isHidden()//判断是否隐藏获取功能：public String getAbsolutePath()：获取绝对路径public String getPath():获取相对路径public String getName():获取名称public long length():获取长度。字节数public long lastModified():获取最后一次的修改时间，毫秒值public String[] list():获取指定目录下的所有文件或者文件夹的名称数组public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 Demo:123456789101112131415161718192021public class FileDemo { public static void main(String[] args) { // 封装e判断目录 File file = new File(&quot;e:\\\\&quot;); // 获取该目录下所有文件或者文件夹的File数组 File[] fileArray = file.listFiles(); // 遍历该File数组，得到每一个File对象，然后判断 for (File f : fileArray) { // 是否是文件 if (f.isFile()) { // 继续判断是否以.jpg结尾 if (f.getName().endsWith(&quot;.jpg&quot;)) { // 就输出该文件名称 System.out.println(f.getName()); } } } }} 2.字节流2.1 字节流写数据：FileOutputStream 字节输出流操作步骤： A:创建字节输出流对象 B:调用write()方法 C:释放资源 构造方法123FileOutputStream(File file) FileOutputStream(String name)FileOutputStream(String name, boolean append) 写数据的方式123public void write(int b):写一个字节public void write(byte[] b):写一个字节数组public void write(byte[] b,int off,int len):写一个字节数组的一部分 Demo:1234567891011121314151617181920212223242526public class FileOutputStreamDemo { public static void main(String[] args) throws IOException { // 创建字节输出流对象 // FileOutputStream(File file) // File file = new File(&quot;fos.txt&quot;); // FileOutputStream fos = new FileOutputStream(file); // FileOutputStream(String name) FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); /* * 创建字节输出流对象了做了几件事情： A:调用系统功能去创建文件 B:创建fos对象 C:把fos对象指向这个文件 */ // 写数据 fos.write(&quot;hello,IO&quot;.getBytes()); fos.write(&quot;java&quot;.getBytes()); // 释放资源 // 关闭此文件输出流并释放与此流有关的所有系统资源。 fos.close(); /* * 为什么一定要close()呢? A:让流对象变成垃圾，这样就可以被垃圾回收器回收了 B:通知系统去释放跟该文件相关的资源 */ // java.io.IOException: Stream Closed // fos.write(&quot;java&quot;.getBytes()); }} 2.2 字节流读数据：FileInputStream字节输入流操作步骤： A:创建字节输入流对象 B:调用read()方法读取数据，并把数据显示在控制台 C:释放资源 构造方法：12FileInputStream(File file)FileInputStream(String name) 读取数据的方式12A:int read():一次读取一个字节B:int read(byte[] b):一次读取一个字节数组 Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class FileInputStreamDemo2 { public static void main(String[] args) throws IOException { // 创建字节输入流对象 // FileInputStream fis = new FileInputStream(&quot;fis2.txt&quot;); FileInputStream fis = new FileInputStream(&quot;FileOutputStreamDemo.java&quot;); // 读取数据 // 定义一个字节数组 // 第一次读取 // byte[] bys = new byte[5]; // int len = fis.read(bys); // // System.out.println(len); // // System.out.println(new String(bys)); // // System.out.println(new String(bys, 0, len)); // System.out.print(new String(bys, 0, len)); // // // 第二次读取 // len = fis.read(bys); // // System.out.println(len); // // System.out.println(new String(bys)); // // System.out.println(new String(bys, 0, len)); // System.out.print(new String(bys, 0, len)); // // // 第三次读取 // len = fis.read(bys); // // System.out.println(len); // // System.out.println(new String(bys)); // // System.out.println(new String(bys, 0, len)); // System.out.print(new String(bys, 0, len)); // // // 第四次读取 // len = fis.read(bys); // // System.out.println(len); // // System.out.println(new String(bys, 0, len)); // System.out.print(new String(bys, 0, len)); // // 代码重复了，用循环改进 // // 但是，我不知道结束条件 // // len = fis.read(bys); // // System.out.println(len); // // len = fis.read(bys); // // System.out.println(len); // // 如果读取到的实际长度是-1，就说明没有数据了 // byte[] bys = new byte[115]; // 0 // int len = 0; // while ((len = fis.read(bys)) != -1) { // System.out.print(new String(bys, 0, len)); // // System.out.print(new String(bys)); //千万要带上len的使用 // } // 最终版代码 // 数组的长度一般是1024或者1024的整数倍 byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) { System.out.print(new String(bys, 0, len)); } // 释放资源 fis.close(); }} 3. 缓冲区流(高效流)3.1 写数据：BufferedOutputStream Demo:12345678910111213141516public class BufferedOutputStreamDemo { public static void main(String[] args) throws IOException { // BufferedOutputStream(OutputStream out) // FileOutputStream fos = new FileOutputStream(&quot;bos.txt&quot;); // BufferedOutputStream bos = new BufferedOutputStream(fos); // 简单写法 BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;bos.txt&quot;)); // 写数据 bos.write(&quot;hello&quot;.getBytes()); // 释放资源 bos.close(); }} 3.2 读数据：BufferedInputStream Demo:1234567891011121314151617181920212223public class BufferedInputStreamDemo { public static void main(String[] args) throws IOException { // BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream( &quot;bos.txt&quot;)); // 读取数据 // int by = 0; // while ((by = bis.read()) != -1) { // System.out.print((char) by); // } // System.out.println(&quot;---------&quot;); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) { System.out.print(new String(bys, 0, len)); } // 释放资源 bis.close(); }} 字节流和缓冲流复制文件的对比Demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 需求：把e:\\\\哥有老婆.mp4复制到当前项目目录下的copy.mp4中 * * 字节流四种方式复制文件： * 基本字节流一次读写一个字节： 共耗时：117235毫秒 * 基本字节流一次读写一个字节数组： 共耗时：156毫秒 * 高效字节流一次读写一个字节： 共耗时：1141毫秒 * 高效字节流一次读写一个字节数组： 共耗时：47毫秒 */public class CopyMp4Demo { public static void main(String[] args) throws IOException { long start = System.currentTimeMillis(); method4(&quot;e:\\\\哥有老婆.mp4&quot;, &quot;copy4.mp4&quot;); long end = System.currentTimeMillis(); System.out.println(&quot;共耗时：&quot; + (end - start) + &quot;毫秒&quot;); } // 高效字节流一次读写一个字节数组： public static void method4(String srcString, String destString) throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) { bos.write(bys, 0, len); } bos.close(); bis.close(); } // 高效字节流一次读写一个字节： public static void method3(String srcString, String destString) throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); int by = 0; while ((by = bis.read()) != -1) { bos.write(by); } bos.close(); bis.close(); } // 基本字节流一次读写一个字节数组 public static void method2(String srcString, String destString) throws IOException { FileInputStream fis = new FileInputStream(srcString); FileOutputStream fos = new FileOutputStream(destString); byte[] bys = new byte[1024]; int len = 0; while ((len = fis.read(bys)) != -1) { fos.write(bys, 0, len); } fos.close(); fis.close(); } // 基本字节流一次读写一个字节 public static void method1(String srcString, String destString) throws IOException { FileInputStream fis = new FileInputStream(srcString); FileOutputStream fos = new FileOutputStream(destString); int by = 0; while ((by = fis.read()) != -1) { fos.write(by); } fos.close(); fis.close(); }} 4. 转换流4.1 OutputStreamWriter构造方法1234//根据默认编码把字节流的数据转换为字符流OutputStreamWriter(OutputStream out);//根据指定编码把字节流数据转换为字符流OutputStreamWriter(OutputStream out,String charsetName) 写数据方法12345public void write(int c)public void write(char[] cbuf)public void write(char[] cbuf,int off,int len)public void write(String str)public void write(String str,int off,int len) Demo: 12345678910111213141516public class OutputStreamWriterDemo { public static void main(String[] args) throws IOException { // 创建对象 // OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( // &quot;osw.txt&quot;)); // 默认GBK // OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( // &quot;osw.txt&quot;), &quot;GBK&quot;); // 指定GBK OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream( &quot;osw.txt&quot;), &quot;UTF-8&quot;); // 指定UTF-8 // 写数据 osw.write(&quot;中国&quot;); // 释放资源 osw.close(); }} 4.2 InputStreamReader构造方法1234//用默认的编码读取数据InputStreamReader(InputStream is);//用指定的编码读取数据InputStreamReader(InputStream is,String charsetName); 读数据方法12public int read()public int read(char[] cbuf) Demo:123456789101112131415161718192021222324public class InputStreamReaderDemo { public static void main(String[] args) throws IOException { // 创建对象 // InputStreamReader isr = new InputStreamReader(new FileInputStream( // &quot;osw.txt&quot;)); // InputStreamReader isr = new InputStreamReader(new FileInputStream( // &quot;osw.txt&quot;), &quot;GBK&quot;); InputStreamReader isr = new InputStreamReader(new FileInputStream( &quot;osw.txt&quot;), &quot;UTF-8&quot;); // 读取数据 // 一次读取一个字符 int ch = 0; while ((ch = isr.read()) != -1) { System.out.print((char) ch); } // 释放资源 isr.close(); }} 4.3 FileWriter &amp; FileReader 转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化我们的书写，转换流提供了对应的子类。FileWriterFileReader Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/* * 由于我们常见的操作都是使用本地默认编码，所以，不用指定编码。 * 而转换流的名称有点长，所以，Java就提供了其子类供我们使用。 * OutputStreamWriter = FileOutputStream + 编码表(GBK) * FileWriter = FileOutputStream + 编码表(GBK) * * InputStreamReader = FileInputStream + 编码表(GBK) * FileReader = FileInputStream + 编码表(GBK) * /* * 需求：把当前项目目录下的a.txt内容复制到当前项目目录下的b.txt中 * * 数据源： * a.txt -- 读取数据 -- 字符转换流 -- InputStreamReader -- FileReader * 目的地： * b.txt -- 写出数据 -- 字符转换流 -- OutputStreamWriter -- FileWriter */public class CopyFileDemo2 { public static void main(String[] args) throws IOException { // 封装数据源 FileReader fr = new FileReader(&quot;a.txt&quot;); // 封装目的地 FileWriter fw = new FileWriter(&quot;b.txt&quot;); // 一次一个字符 // int ch = 0; // while ((ch = fr.read()) != -1) { // fw.write(ch); // } // 一次一个字符数组 char[] chs = new char[1024]; int len = 0; while ((len = fr.read(chs)) != -1) { fw.write(chs, 0, len); fw.flush(); } // 释放资源 fw.close(); fr.close(); }} 5.字符缓冲流5.1 字符缓冲输出流：BufferedWriter 字符流为了高效读写，也提供了对应的字符缓冲流。将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。 特殊方法public void newLine():根据系统来决定换行符 Demo:1234567891011121314151617181920import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class BufferedWriterDemo { public static void main(String[] args) throws IOException { // BufferedWriter(Writer out) // BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( // new FileOutputStream(&quot;bw.txt&quot;))); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); bw.write(&quot;hello&quot;); bw.write(&quot;world&quot;); bw.write(&quot;java&quot;); bw.flush(); bw.close(); }} 5.2 字符缓冲输入流：BufferedReader 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 特殊方法12public String readLine()：一次读取一行数据//包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null Demo:1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderDemo { public static void main(String[] args) throws IOException { // 创建字符缓冲输入流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;bw.txt&quot;)); // 方式1 // int ch = 0; // while ((ch = br.read()) != -1) { // System.out.print((char) ch); // } // 方式2 char[] chs = new char[1024]; int len = 0; while ((len = br.read(chs)) != -1) { System.out.print(new String(chs, 0, len)); } // 释放资源 br.close(); }} 6.操作基本数据类型的流Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 可以读写基本数据类型的数据 * 数据输入流：DataInputStream * DataInputStream(InputStream in) * 数据输出流：DataOutputStream * DataOutputStream(OutputStream out) */public class DataStreamDemo { public static void main(String[] args) throws IOException { // 写 // write(); // 读 read(); } private static void read() throws IOException { // DataInputStream(InputStream in) // 创建数据输入流对象 DataInputStream dis = new DataInputStream( new FileInputStream(&quot;dos.txt&quot;)); // 读数据 byte b = dis.readByte(); short s = dis.readShort(); int i = dis.readInt(); long l = dis.readLong(); float f = dis.readFloat(); double d = dis.readDouble(); char c = dis.readChar(); boolean bb = dis.readBoolean(); // 释放资源 dis.close(); System.out.println(b); System.out.println(s); System.out.println(i); System.out.println(l); System.out.println(f); System.out.println(d); System.out.println(c); System.out.println(bb); } private static void write() throws IOException { // DataOutputStream(OutputStream out) // 创建数据输出流对象 DataOutputStream dos = new DataOutputStream(new FileOutputStream( &quot;dos.txt&quot;)); // 写数据了 dos.writeByte(10); dos.writeShort(100); dos.writeInt(1000); dos.writeLong(10000); dos.writeFloat(12.34F); dos.writeDouble(12.56); dos.writeChar(&apos;a&apos;); dos.writeBoolean(true); // 释放资源 dos.close(); }} 7.内存操作流Demo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;/* * 内存操作流：用于处理临时存储信息的，程序结束，数据就从内存中消失。 * 字节数组： * ByteArrayInputStream * ByteArrayOutputStream * 字符数组： * CharArrayReader * CharArrayWriter * 字符串： * StringReader * StringWriter */public class ByteArrayStreamDemo { public static void main(String[] args) throws IOException { // 写数据 // ByteArrayOutputStream() ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 写数据 for (int x = 0; x &lt; 10; x++) { baos.write((&quot;hello&quot; + x).getBytes()); } // 释放资源 // 通过查看源码我们知道这里什么都没做，所以根本需要close() // baos.close(); // public byte[] toByteArray() byte[] bys = baos.toByteArray(); // 读数据 // ByteArrayInputStream(byte[] buf) ByteArrayInputStream bais = new ByteArrayInputStream(bys); int by = 0; while ((by = bais.read()) != -1) { System.out.print((char) by); } // bais.close(); }} 8.打印流Demo:1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.PrintWriter;/* * 打印流 * 字节流打印流 PrintStream * 字符打印流 PrintWriter * * 打印流的特点： * A:只有写数据的，没有读取数据。只能操作目的地，不能操作数据源。 * B:可以操作任意类型的数据。 * C:如果启动了自动刷新，能够自动刷新。 * D:该流是可以直接操作文本文件的。 * 哪些流对象是可以直接操作文本文件的呢? * FileInputStream * FileOutputStream * FileReader * FileWriter * PrintStream * PrintWriter * 看API,查流对象的构造方法，如果同时有File类型和String类型的参数，一般来说就是可以直接操作文件的。 * * 流： * 基本流：就是能够直接读写文件的 * 高级流：在基本流基础上提供了一些其他的功能 */public class PrintWriterDemo { public static void main(String[] args) throws IOException { // 作为Writer的子类使用 PrintWriter pw = new PrintWriter(&quot;pw.txt&quot;); pw.write(&quot;hello&quot;); pw.write(&quot;world&quot;); pw.write(&quot;java&quot;); pw.close(); }} 9.标准输入输出流9.1 “标准”输入流:InputStreamDemo:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/* * System.in 标准输入流。是从键盘获取数据的 * * 键盘录入数据： * A:main方法的args接收参数。 * java HelloWorld hello world java * B:Scanner(JDK5以后的) * Scanner sc = new Scanner(System.in); * String s = sc.nextLine(); * int x = sc.nextInt() * C:通过字符缓冲流包装标准输入流实现 * BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); */public class SystemInDemo { public static void main(String[] args) throws IOException { // //获取标准输入流 // InputStream is = System.in; // //我要一次获取一行行不行呢? // //行。 // //怎么实现呢? // //要想实现，首先你得知道一次读取一行数据的方法是哪个呢? // //readLine() // //而这个方法在哪个类中呢? // //BufferedReader // //所以，你这次应该创建BufferedReader的对象，但是底层还是的使用标准输入流 // // BufferedReader br = new BufferedReader(is); // //按照我们的推想，现在应该可以了，但是却报错了 // //原因是：字符缓冲流只能针对字符流操作，而你现在是字节流，所以不能是用? // //那么，我还就想使用了，请大家给我一个解决方案? // //把字节流转换为字符流，然后在通过字符缓冲流操作 // InputStreamReader isr = new InputStreamReader(is); // BufferedReader br= new BufferedReader(isr); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(&quot;请输入一个字符串：&quot;); String line = br.readLine(); System.out.println(&quot;你输入的字符串是：&quot; + line); System.out.println(&quot;请输入一个整数：&quot;); // int i = Integer.parseInt(br.readLine()); line = br.readLine(); int i = Integer.parseInt(line); System.out.println(&quot;你输入的整数是：&quot; + i); }} 9.2 “标准”输出流:PrintStreamDemo:123456789101112131415161718192021222324252627import java.io.PrintStream;/* * 标准输入输出流 * System类中的两个成员变量： * public static final InputStream in “标准”输入流。 * public static final PrintStream out “标准”输出流。 * * InputStream is = System.in; * PrintStream ps = System.out; */public class SystemOutDemo { public static void main(String[] args) { // 有这里的讲解我们就知道了，这个输出语句其本质是IO流操作，把数据输出到控制台。 System.out.println(&quot;helloworld&quot;); // 获取标准输出流对象 PrintStream ps = System.out; ps.println(&quot;helloworld&quot;); ps.println(); // ps.print();//这个方法不存在 // System.out.println(); // System.out.print(); }} 10.随机访问流:RandomAccessFile RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。支持对文件的随机访问读取和写入。 构造方法1234public RandomAccessFile(String name,String mode)：第一个参数是文件路径;第二个参数是操作文件的模式。模式有四种，我们最常用的一种叫&quot;rw&quot;,这种方式表示我既可以写数据，也可以读取数据 Demo:1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileDemo { public static void main(String[] args) throws IOException { // write(); read(); } private static void read() throws IOException { // 创建随机访问流对象 RandomAccessFile raf = new RandomAccessFile(&quot;raf.txt&quot;, &quot;rw&quot;); int i = raf.readInt(); System.out.println(i); // 该文件指针可以通过 getFilePointer方法读取，并通过 seek 方法设置。 System.out.println(&quot;当前文件的指针位置是：&quot; + raf.getFilePointer()); char ch = raf.readChar(); System.out.println(ch); System.out.println(&quot;当前文件的指针位置是：&quot; + raf.getFilePointer()); String s = raf.readUTF(); System.out.println(s); System.out.println(&quot;当前文件的指针位置是：&quot; + raf.getFilePointer()); // 我不想重头开始了，我就要读取a，怎么办呢? raf.seek(4); ch = raf.readChar(); System.out.println(ch); } private static void write() throws IOException { // 创建随机访问流对象 RandomAccessFile raf = new RandomAccessFile(&quot;raf.txt&quot;, &quot;rw&quot;); // 怎么玩呢? raf.writeInt(100); raf.writeChar(&apos;a&apos;); raf.writeUTF(&quot;中国&quot;); raf.close(); }} 11.合并流:SequenceInputStream SequenceInputStream类可以将多个输入流串流在一起，合并为一个输入流，因此，该流也被称为合并流。 构造方法12SequenceInputStream(InputStream s1, InputStream s2) ;SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e); Demo1:123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.SequenceInputStream;/* * 以前的操作： * a.txt -- b.txt * c.txt -- d.txt * * 现在想要： * a.txt+b.txt -- c.txt */public class SequenceInputStreamDemo { public static void main(String[] args) throws IOException { // SequenceInputStream(InputStream s1, InputStream s2) // 需求：把ByteArrayStreamDemo.java和DataStreamDemo.java的内容复制到Copy.java中 InputStream s1 = new FileInputStream(&quot;ByteArrayStreamDemo.java&quot;); InputStream s2 = new FileInputStream(&quot;DataStreamDemo.java&quot;); SequenceInputStream sis = new SequenceInputStream(s1, s2); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;Copy.java&quot;)); // 如何写读写呢，其实很简单，你就按照以前怎么读写，现在还是怎么读写 byte[] bys = new byte[1024]; int len = 0; while ((len = sis.read(bys)) != -1) { bos.write(bys, 0, len); } bos.close(); sis.close(); }} Demo2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.SequenceInputStream;import java.util.Enumeration;import java.util.Vector;/* * 以前的操作： * a.txt -- b.txt * c.txt -- d.txt * e.txt -- f.txt * * 现在想要： * a.txt+b.txt+c.txt -- d.txt */public class SequenceInputStreamDemo2 { public static void main(String[] args) throws IOException { // 需求：把下面的三个文件的内容复制到Copy.java中 // ByteArrayStreamDemo.java,CopyFileDemo.java,DataStreamDemo.java // SequenceInputStream(Enumeration e) // 通过简单的回顾我们知道了Enumeration是Vector中的一个方法的返回值类型。 // Enumeration&lt;E&gt; elements() Vector&lt;InputStream&gt; v = new Vector&lt;InputStream&gt;(); InputStream s1 = new FileInputStream(&quot;ByteArrayStreamDemo.java&quot;); InputStream s2 = new FileInputStream(&quot;CopyFileDemo.java&quot;); InputStream s3 = new FileInputStream(&quot;DataStreamDemo.java&quot;); v.add(s1); v.add(s2); v.add(s3); Enumeration&lt;InputStream&gt; en = v.elements(); SequenceInputStream sis = new SequenceInputStream(en); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;Copy.java&quot;)); // 如何写读写呢，其实很简单，你就按照以前怎么读写，现在还是怎么读写 byte[] bys = new byte[1024]; int len = 0; while ((len = sis.read(bys)) != -1) { bos.write(bys, 0, len); } bos.close(); sis.close(); }} 12.序列化流 序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象 – 流数据(ObjectOutputStream) 反序列化流:把文本文件中的流对象数据或者网络中的流对象数据还原成对象。流数据 – 对象(ObjectInputStream) Demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // 由于我们要对对象进行序列化，所以我们先自定义一个类 // 序列化数据其实就是把对象写到文本文件 write(); read(); } private static void read() throws IOException, ClassNotFoundException { // 创建反序列化对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream( &quot;oos.txt&quot;)); // 还原对象 Object obj = ois.readObject(); // 释放资源 ois.close(); // 输出对象 System.out.println(obj); } private static void write() throws IOException { // 创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream( &quot;oos.txt&quot;)); // 创建对象 Person p = new Person(&quot;林青霞&quot;, 27); // public final void writeObject(Object obj) oos.writeObject(p); // 释放资源 oos.close(); }}import java.io.Serializable;/* * 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 * 该接口居然没有任何方法，类似于这种没有方法的接口被称为标记接口。 * 注意： * 我一个类中可能有很多的成员变量，有些我不想进行序列化。请问该怎么办呢? * 使用transient关键字声明不需要序列化的成员变量 */public class Person implements Serializable { private static final long serialVersionUID = -2071565876962058344L; private String name; // private int age; private transient int age; // int age; public Person() { super(); } public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; }} 13.Properties Hashtable的子类，说明是一个Map集合。属性集合类。是一个可以和IO流相结合使用的集合类。 Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 Demo:123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;import java.io.Writer;import java.util.Properties;/* * 这里的集合必须是Properties集合： * public void load(Reader reader):把文件中的数据读取到集合中 * public void store(Writer writer,String comments):把集合中的数据存储到文件*/public class PropertiesDemo3 { public static void main(String[] args) throws IOException { myLoad(); // myStore(); } private static void myStore() throws IOException { // 创建集合对象 Properties prop = new Properties(); prop.setProperty(&quot;林青霞&quot;, &quot;27&quot;); prop.setProperty(&quot;武鑫&quot;, &quot;30&quot;); prop.setProperty(&quot;刘晓曲&quot;, &quot;18&quot;); // public void store(Writer writer,String comments):把集合中的数据存储到文件 Writer w = new FileWriter(&quot;name.txt&quot;); prop.store(w, &quot;helloworld&quot;); w.close(); } private static void myLoad() throws IOException { Properties prop = new Properties(); // public void load(Reader reader):把文件中的数据读取到集合中 // 注意：这个文件的数据必须是键值对形式 Reader r = new FileReader(&quot;prop.txt&quot;); prop.load(r); r.close(); System.out.println(&quot;prop:&quot; + prop); }} 14.NIO NIO其实就是新IO的意思。JDK4出现NIO。新IO和传统的IO有相同的目的，都是用于进行输入输出的，但新IO使用了不同的方式来处理输入输出，采用内存映射文件的方式，将文件或者文件的一段区域映射到内存中，就可以像访问内存一样的来访问文件了，这种方式效率比旧IO要高很多 Java NIO提供了与标准IO不同的IO工作方式：Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。Selectors（选择器）：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 Demo:1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Paths;import java.util.ArrayList;/* * nio包在JDK4出现，提供了IO流的操作效率。但是目前还不是大范围的使用。 * 有空的话了解下，有问题再问我。 * * JDK7的之后的nio： * Path:路径 * Paths:有一个静态方法返回一个路径 * public static Path get(URI uri) * Files:提供了静态方法供我们使用 * public static long copy(Path source,OutputStream out):复制文件 * public static Path write(Path path,Iterable&lt;? extends CharSequence&gt; lines,Charset cs,OpenOption... options) */public class NIODemo { public static void main(String[] args) throws IOException { // public static long copy(Path source,OutputStream out) // Files.copy(Paths.get(&quot;ByteArrayStreamDemo.java&quot;), new // FileOutputStream( // &quot;Copy.java&quot;)); ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); Files.write(Paths.get(&quot;array.txt&quot;), array, Charset.forName(&quot;GBK&quot;)); }}","link":"/2017/06/03/JAVA基础系列（七） IO流/"}],"tags":[{"name":"线程池","slug":"线程池","link":"/tags/线程池/"},{"name":"优化","slug":"优化","link":"/tags/优化/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/categories/ElasticSearch/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"JAVA基础系列","slug":"JAVA基础系列","link":"/categories/JAVA基础系列/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/categories/JavaWeb/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"Oracle","slug":"Oracle","link":"/categories/Oracle/"},{"name":"SpringBoot2.0","slug":"SpringBoot2-0","link":"/categories/SpringBoot2-0/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"JavaWeb框架","slug":"JavaWeb框架","link":"/categories/JavaWeb框架/"},{"name":"源码","slug":"源码","link":"/categories/源码/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/数据结构与算法/"},{"name":"flowable","slug":"flowable","link":"/categories/flowable/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"编程","slug":"编程","link":"/categories/编程/"},{"name":"java","slug":"编程/java","link":"/categories/编程/java/"},{"name":"在线编程","slug":"在线编程","link":"/categories/在线编程/"},{"name":"Hadoop","slug":"Hadoop","link":"/categories/Hadoop/"}]}