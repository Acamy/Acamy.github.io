{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/03/hello-world/"},{"title":"你好, Hexo","text":"","link":"/2018/11/03/你好-Hexo/"},{"title":"采用线程池处理异步任务并获取最终结果","text":"以前对线程池的理解大多处于理论阶段，知道为什么要用以及怎么用，各个参数的含意设置及原理，也明白submit和excute的区别，但是在实际工作时遇到对异步任务处理时却不知道怎么先批量提交到线程池，利用线程池批量处理后再批量获取返回结果，通过同事指点再知道invokeAll方法，因此看了一下源码并写了一个简单的demo invokeAll是AbstractExecutorService抽象类下的一个方法，源码如下, 该方法主要是接受一个异步任务列表，这段代码主要是有两个for循环，第一个for循环是将列表中的任务添加到线程池运行起来，第二个for循环是通过f.get来阻塞所有未完成的任务直到完成，最后finally里面尝试取消出现异常完成的任务。 123456789101112131415161718192021222324252627282930public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException { if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try { for (Callable&lt;T&gt; t : tasks) { RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); execute(f); } for (int i = 0, size = futures.size(); i &lt; size; i++) { Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) { try { f.get(); } catch (CancellationException ignore) { } catch (ExecutionException ignore) { } } } done = true; return futures; } finally { if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); }} 使用线程池调用invokeAll的demo：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.ArrayList;import java.util.List;import java.util.concurrent.*;public class ThreadPoolDemo { public static void main(String[] args) { new ThreadPoolDemo().execute(); } public void execute(){ ThreadPoolExecutor executor = new ThreadPoolExecutor(12, 12, 2000, TimeUnit.MICROSECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000)); List&lt;Handler&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 100; i++){ list.add(new Handler(String.valueOf(i))); } try { //会按照添加到List的次序返回，该方法阻塞至所有任务完成 List&lt;Future&lt;String&gt;&gt; results = executor.invokeAll(list); results.stream().forEach( future -&gt; { try { System.out.println(future.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }); } catch (Exception e) { e.printStackTrace(); } //关闭线程池 executor.shutdown(); } private class Handler implements Callable&lt;String&gt; { //模拟传参，实际可为对象类型 String value; public Handler(String value){ this.value = value; } public String call(){ try { //模拟任务的处理过程0-1000ms Thread.sleep((int)(Math.random()*1000)); } catch (InterruptedException e) { e.printStackTrace(); } //模拟返回参数，实际可为对象类型 System.out.println(value); return value + &quot;value&quot;; } }} 运行结果: 如上图所示，所有任务添加到线程池后执行并没有次序，但最后返回的结果是按照最初添加list的顺序，即利用了线程池并发处理的特点，又有序获取到了所有异步任务的最终执行结果。","link":"/2018/11/03/采用线程池处理异步任务并获取最终结果/"}],"tags":[{"name":"线程池","slug":"线程池","link":"/tags/线程池/"},{"name":"优化","slug":"优化","link":"/tags/优化/"}],"categories":[{"name":"编程 java","slug":"编程-java","link":"/categories/编程-java/"},{"name":"编程","slug":"编程","link":"/categories/编程/"},{"name":"java","slug":"编程/java","link":"/categories/编程/java/"}]}